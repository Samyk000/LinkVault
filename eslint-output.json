[{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\api\\fetch-metadata\\route.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ;","line":28,"column":50,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file app/api/fetch-metadata/route.ts\r\n * @description API route to fetch URL metadata (Open Graph tags)\r\n * @created 2025-10-18\r\n */\r\n\r\nimport axios from 'axios';\r\nimport * as cheerio from 'cheerio';\r\nimport { NextResponse } from 'next/server';\r\nimport { z } from 'zod';\r\nimport { sanitizeString } from '@/lib/utils/sanitization';\r\nimport { createRateLimiter, createRateLimitResponse } from '@/lib/middleware/rate-limit';\r\n\r\n// Configure this route to run on Node.js runtime (not Edge)\r\nexport const runtime = 'nodejs';\r\nexport const dynamic = 'force-dynamic';\r\n\r\n// OPTIMIZED: Add caching headers for better performance\r\nexport const revalidate = 3600; // Revalidate every hour\r\n\r\n// CRITICAL: Rate limiting configuration\r\nconst rateLimiter = createRateLimiter({\r\n  interval: 60 * 1000, // 1 minute\r\n  maxRequests: 10, // 10 requests per minute per IP\r\n});\r\n\r\n// Simple in-memory cache for metadata (in production, use Redis or similar)\r\nconst metadataCache = new Map<string, { data: any; timestamp: number; errorCount?: number }>();\r\nconst CACHE_TTL = 60 * 60 * 1000; // 1 hour cache\r\nconst ERROR_CACHE_TTL = 15 * 60 * 1000; // 15 minutes for errors\r\nconst MAX_CACHE_SIZE = 500; // Reduced cache size to prevent memory issues\r\nconst RATE_LIMIT_DELAY = 1000; // 1 second delay between requests\r\nconst MAX_RECENT_ERRORS = 3; // Max errors before temporarily blocking\r\n\r\n// Validation schema for request body\r\nconst RequestSchema = z.object({\r\n  url: z.string()\r\n    .min(1, 'URL is required')\r\n    .url('Invalid URL format')\r\n    .refine((url) => {\r\n      // Additional URL validation\r\n      try {\r\n        const parsedUrl = new URL(url);\r\n        // Only allow http and https protocols\r\n        return ['http:', 'https:'].includes(parsedUrl.protocol);\r\n      } catch {\r\n        return false;\r\n      }\r\n    }, 'URL must use http or https protocol')\r\n    .refine((url) => {\r\n      // Prevent localhost/private IP access in production\r\n      if (process.env.NODE_ENV === 'production') {\r\n        try {\r\n          const parsedUrl = new URL(url);\r\n          const hostname = parsedUrl.hostname.toLowerCase();\r\n          \r\n          // Block localhost, private IPs, and internal domains\r\n          const blockedPatterns = [\r\n            /^localhost$/i,\r\n            /^127\\./,\r\n            /^10\\./,\r\n            /^172\\.(1[6-9]|2[0-9]|3[0-1])\\./,\r\n            /^192\\.168\\./,\r\n            /^169\\.254\\./,\r\n            /^::1$/,\r\n            /^fc00:/,\r\n            /^fe80:/,\r\n            /\\.local$/i,\r\n            /\\.internal$/i,\r\n          ];\r\n          \r\n          return !blockedPatterns.some(pattern => pattern.test(hostname));\r\n        } catch {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }, 'URL not allowed in production environment'),\r\n});\r\n\r\n// Response schema for type safety\r\nconst MetadataResponseSchema = z.object({\r\n  title: z.string().optional(),\r\n  description: z.string().optional(),\r\n  image: z.string().url().optional(),\r\n  siteName: z.string().optional(),\r\n  url: z.string().url(),\r\n  favicon: z.string().optional(),\r\n  domain: z.string().optional(),\r\n});\r\n\r\n/**\r\n * Checks if URL is a YouTube video\r\n */\r\nfunction isYouTubeUrl(url: string): boolean {\r\n  const youtubePatterns = [\r\n    /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/|youtube\\.com\\/embed\\/)([^&\\?\\/]+)/,\r\n    /youtube\\.com\\/shorts\\/([^&\\?\\/]+)/\r\n  ];\r\n  return youtubePatterns.some(pattern => pattern.test(url));\r\n}\r\n\r\n/**\r\n * Extracts YouTube video ID from URL\r\n */\r\nfunction getYouTubeVideoId(url: string): string | null {\r\n  const patterns = [\r\n    /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/)([^&\\?\\/]+)/,\r\n    /youtube\\.com\\/embed\\/([^&\\?\\/]+)/,\r\n    /youtube\\.com\\/shorts\\/([^&\\?\\/]+)/\r\n  ];\r\n  \r\n  for (const pattern of patterns) {\r\n    const match = url.match(pattern);\r\n    if (match && match[1]) {\r\n      return match[1];\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Fetches YouTube metadata using oEmbed API (no API key required)\r\n */\r\nasync function fetchYouTubeMetadata(url: string) {\r\n  const videoId = getYouTubeVideoId(url);\r\n  if (!videoId) {\r\n    throw new Error('Invalid YouTube URL');\r\n  }\r\n\r\n  // Use YouTube's official oEmbed API (works on serverless)\r\n  const oEmbedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;\r\n  \r\n  const response = await axios.get(oEmbedUrl, {\r\n    timeout: 10000,\r\n  });\r\n\r\n  const data = response.data;\r\n\r\n  return {\r\n    title: data.title || 'YouTube Video',\r\n    description: `Watch \"${data.title}\" by ${data.author_name}`,\r\n    image: data.thumbnail_url || `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,\r\n    siteName: 'YouTube',\r\n    favicon: 'https://www.youtube.com/favicon.ico',\r\n    domain: 'youtube.com',\r\n  };\r\n}\r\n\r\n/**\r\n * POST handler for metadata fetching with enhanced error handling and retry logic\r\n * @param {Request} req - Next.js request object\r\n * @returns {Promise<NextResponse>} JSON response with metadata or error\r\n */\r\nexport async function POST(req: Request) {\r\n  let requestedUrl: string = '';\r\n  const startTime = Date.now();\r\n\r\n  // CRITICAL: Apply rate limiting\r\n  const rateLimit = rateLimiter.check(req);\r\n  \r\n  if (!rateLimit.allowed) {\r\n    return createRateLimitResponse(\r\n      rateLimit.allowed,\r\n      rateLimit.remaining,\r\n      rateLimit.resetTime\r\n    );\r\n  }\r\n\r\n  try {\r\n    // Parse and validate request body with timeout protection\r\n    const bodyPromise = req.json();\r\n    const timeoutPromise = new Promise<never>((_, reject) =>\r\n      setTimeout(() => reject(new Error('Request parsing timeout')), 5000)\r\n    );\r\n\r\n    const body = await Promise.race([bodyPromise, timeoutPromise]);\r\n\r\n    // Validate input using Zod schema\r\n    const validationResult = RequestSchema.safeParse(body);\r\n\r\n    if (!validationResult.success) {\r\n      const errorMessage = validationResult.error.issues[0]?.message || 'Invalid request data';\r\n      return NextResponse.json(\r\n        {\r\n          error: errorMessage,\r\n          details: validationResult.error.issues,\r\n          processingTime: Date.now() - startTime\r\n        },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const { url } = validationResult.data;\r\n    requestedUrl = url;\r\n\r\n    // ENHANCED: Check cache first with better cache management\r\n    const cacheKey = `metadata:${url}`;\r\n    const cached = metadataCache.get(cacheKey);\r\n    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\r\n      console.log(`Cache hit for URL: ${url}`);\r\n      return NextResponse.json({\r\n        ...cached.data,\r\n        processingTime: Date.now() - startTime,\r\n        cached: true\r\n      }, {\r\n        headers: {\r\n          'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',\r\n          'X-Cache': 'HIT'\r\n        }\r\n      });\r\n    }\r\n\r\n    // ENHANCED: Clean cache if it's too large (more aggressive cleanup)\r\n    if (metadataCache.size >= MAX_CACHE_SIZE) {\r\n      // Remove oldest 20% of entries\r\n      const entries = Array.from(metadataCache.entries())\r\n        .sort((a, b) => a[1].timestamp - b[1].timestamp);\r\n\r\n      const toRemove = Math.ceil(entries.length * 0.2);\r\n      for (let i = 0; i < toRemove; i++) {\r\n        metadataCache.delete(entries[i][0]);\r\n      }\r\n      console.log(`Cleaned ${toRemove} old cache entries`);\r\n    }\r\n\r\n    // Check if URL has too many recent errors\r\n    const errorCacheKey = `error:${url}`;\r\n    const errorEntry = metadataCache.get(errorCacheKey);\r\n    if (errorEntry && (errorEntry.errorCount || 0) >= MAX_RECENT_ERRORS) {\r\n      const errorAge = Date.now() - errorEntry.timestamp;\r\n      if (errorAge < ERROR_CACHE_TTL) {\r\n        console.log(`URL temporarily blocked due to repeated errors: ${url}`);\r\n        return NextResponse.json({\r\n          error: 'This URL has failed multiple times recently. Please try a different URL or wait before retrying.',\r\n          processingTime: Date.now() - startTime,\r\n          temporarilyBlocked: true\r\n        }, { status: 429 });\r\n      } else {\r\n        metadataCache.delete(errorCacheKey);\r\n      }\r\n    }\r\n\r\n    // Check if it's a YouTube URL - use oEmbed API\r\n    if (isYouTubeUrl(url)) {\r\n      try {\r\n        const metadata = await fetchYouTubeMetadata(url);\r\n        // Cache the result\r\n        metadataCache.set(cacheKey, { data: { ...metadata, processingTime: Date.now() - startTime, cached: false }, timestamp: Date.now() });\r\n        return NextResponse.json({ ...metadata, processingTime: Date.now() - startTime, cached: false }, {\r\n          headers: {\r\n            'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',\r\n            'X-Cache': 'MISS'\r\n          }\r\n        });\r\n      } catch (error: any) {\r\n        console.error('YouTube oEmbed error:', error.message);\r\n        // Fall back to generic scraping if oEmbed fails\r\n      }\r\n    }\r\n\r\n    // Try metadata.party for other URLs\r\n    try {\r\n      const res = await axios.get(`https://metadata.party/api?url=${encodeURIComponent(url)}`, {\r\n        timeout: 3000,\r\n        signal: AbortSignal.timeout(3000),\r\n      });\r\n      let data;\r\n      try {\r\n        data = typeof res.data === 'string' ? JSON.parse(res.data) : res.data;\r\n      } catch (parseError) {\r\n        console.log('metadata.party returned invalid JSON for', url);\r\n        throw new Error('Invalid JSON response');\r\n      }\r\n      const metadata = {\r\n        title: data.title?.slice(0, 200) || 'Untitled',\r\n        description: data.description?.slice(0, 500) || data.excerpt?.slice(0, 500) || '',\r\n        image: data.image || data['og:image'] || data['twitter:image'] || '',\r\n        siteName: data.siteName || new URL(url).hostname,\r\n        url: url,\r\n        favicon: data.favicon || `https://${new URL(url).hostname}/favicon.ico`,\r\n        domain: new URL(url).hostname,\r\n      };\r\n      // Validate and resolve image URL\r\n      if (metadata.image && !metadata.image.startsWith('http')) {\r\n        try {\r\n          const urlObj = new URL(url);\r\n          metadata.image = new URL(metadata.image, urlObj.origin).toString();\r\n        } catch {\r\n          metadata.image = '';\r\n        }\r\n      }\r\n      // Cache and return\r\n      metadataCache.set(cacheKey, { data: { ...metadata, processingTime: Date.now() - startTime, cached: false }, timestamp: Date.now() });\r\n      return NextResponse.json({ ...metadata, processingTime: Date.now() - startTime, cached: false }, {\r\n        headers: {\r\n          'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',\r\n          'X-Cache': 'MISS'\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.log('metadata.party failed for', url, error instanceof Error ? error.message : 'Unknown error');\r\n    }\r\n\r\n    // Rate limiting delay between requests\r\n    await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));\r\n\r\n    // For remaining URLs, scrape with improved headers and enhanced retry logic\r\n    // ENHANCED: Better timeout management and error handling\r\n    let response;\r\n    let lastError: unknown = null;\r\n    const maxRetries = 2; // REDUCED: Fewer retries to be less aggressive\r\n\r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        console.log(`Fetching metadata for ${url} (attempt ${attempt + 1}/${maxRetries + 1})`);\r\n\r\n        response = await axios.get(url, {\r\n          headers: {\r\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\r\n            'Accept-Language': 'en-US,en;q=0.9',\r\n            'Accept-Encoding': 'gzip, deflate, br',\r\n            'DNT': '1',\r\n            'Connection': 'keep-alive',\r\n            'Upgrade-Insecure-Requests': '1',\r\n            'Cache-Control': 'no-cache',\r\n            'Pragma': 'no-cache',\r\n          },\r\n          timeout: 5000, // REDUCED: Shorter timeout to fail faster\r\n          maxRedirects: 3, // REDUCED: Fewer redirects\r\n          validateStatus: (status) => status < 500, // Don't throw on 4xx errors\r\n          signal: AbortSignal.timeout(5000),\r\n        });\r\n\r\n        console.log(`Successfully fetched ${url} with status ${response.status}`);\r\n        // If we got a response (even if error status), break retry loop\r\n        break;\r\n      } catch (error: unknown) {\r\n        lastError = error;\r\n        console.warn(`Attempt ${attempt + 1} failed for ${url}:`, error instanceof Error ? error.message : 'Unknown error');\r\n\r\n        // Track errors for this URL\r\n        const errorCacheKey = `error:${url}`;\r\n        const existingErrorEntry = metadataCache.get(errorCacheKey);\r\n        const newErrorCount = (existingErrorEntry?.errorCount || 0) + 1;\r\n        \r\n        metadataCache.set(errorCacheKey, {\r\n          data: null,\r\n          timestamp: Date.now(),\r\n          errorCount: newErrorCount\r\n        });\r\n\r\n        // Don't retry on client errors (4xx) - these won't change\r\n        if (axios.isAxiosError(error) && error.response && error.response.status >= 400 && error.response.status < 500) {\r\n          console.log(`Client error ${error.response.status} for ${url}, not retrying`);\r\n          break; // Don't throw, just break to return cached error\r\n        }\r\n\r\n        // Don't retry on specific errors that won't improve\r\n        if (axios.isAxiosError(error) && error.code === 'ENOTFOUND') {\r\n          console.log(`DNS resolution failed for ${url}, not retrying`);\r\n          break;\r\n        }\r\n\r\n        // Retry on network errors, timeouts, or server errors (5xx)\r\n        if (attempt < maxRetries) {\r\n          // Shorter delay between retries\r\n          const delay = 500 + (attempt * 250); // Start with 500ms, increase by 250ms each retry\r\n          console.log(`Retrying ${url} in ${delay}ms`);\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n          continue;\r\n        }\r\n\r\n        // Last attempt failed, don't throw - return fallback\r\n        console.error(`All retry attempts failed for ${url}`);\r\n      }\r\n    }\r\n\r\n    if (!response) {\r\n      // Return fallback metadata instead of throwing error\r\n      const fallbackData = {\r\n        title: new URL(url).hostname,\r\n        description: 'Unable to fetch metadata. Please add a description manually.',\r\n        image: '',\r\n        siteName: new URL(url).hostname,\r\n        url: url,\r\n        favicon: `https://${new URL(url).hostname}/favicon.ico`,\r\n        domain: new URL(url).hostname,\r\n        processingTime: Date.now() - startTime,\r\n        cached: false,\r\n        fallback: true\r\n      };\r\n\r\n      // Cache the fallback result\r\n      const cacheKey = `metadata:${url}`;\r\n      metadataCache.set(cacheKey, {\r\n        data: fallbackData,\r\n        timestamp: Date.now()\r\n      });\r\n\r\n      console.log(`Returning fallback metadata for ${url}`);\r\n      return NextResponse.json(fallbackData, {\r\n        headers: {\r\n          'Cache-Control': 'public, s-maxage=1800, stale-while-revalidate=3600', // 30 min cache for fallbacks\r\n          'X-Cache': 'FALLBACK'\r\n        }\r\n      });\r\n    }\r\n\r\n    // Load HTML into Cheerio with error handling\r\n    let $: ReturnType<typeof cheerio.load>;\r\n    try {\r\n      $ = cheerio.load(response.data as string);\r\n    } catch (error) {\r\n      console.error('Failed to parse HTML for', url, error);\r\n      throw new Error('Invalid HTML response from website');\r\n    }\r\n\r\n    // Extract Open Graph metadata with comprehensive fallbacks\r\n    const metadata = {\r\n      title:\r\n        $('meta[property=\"og:title\"]').attr('content') ||\r\n        $('meta[name=\"twitter:title\"]').attr('content') ||\r\n        $('title').first().text() ||\r\n        $('h1').first().text() ||\r\n        'No title found',\r\n\r\n      image:\r\n        $('meta[property=\"og:image\"]').attr('content') ||\r\n        $('meta[property=\"og:image:url\"]').attr('content') ||\r\n        $('meta[name=\"twitter:image\"]').attr('content') ||\r\n        $('meta[name=\"twitter:image:src\"]').attr('content') ||\r\n        $('link[rel=\"image_src\"]').attr('href') ||\r\n        '',\r\n\r\n      description:\r\n        $('meta[property=\"og:description\"]').attr('content') ||\r\n        $('meta[name=\"description\"]').attr('content') ||\r\n        $('meta[name=\"twitter:description\"]').attr('content') ||\r\n        $('meta[property=\"og:site_name\"]').attr('content') ||\r\n        '',\r\n\r\n      siteName:\r\n        $('meta[property=\"og:site_name\"]').attr('content') ||\r\n        $('meta[name=\"application-name\"]').attr('content') ||\r\n        new URL(url).hostname,\r\n\r\n      url: url, // Include the original URL for reference\r\n\r\n      favicon:\r\n        $('link[rel=\"icon\"]').attr('href') ||\r\n        $('link[rel=\"shortcut icon\"]').attr('href') ||\r\n        `https://${new URL(url).hostname}/favicon.ico`,\r\n\r\n      domain: new URL(url).hostname,\r\n    };\r\n\r\n    // Clean up the data with better sanitization\r\n    metadata.title = sanitizeString(metadata.title.trim().substring(0, 200));\r\n    metadata.description = sanitizeString(metadata.description.trim().substring(0, 500));\r\n    metadata.siteName = sanitizeString(metadata.siteName?.trim().substring(0, 100) || '');\r\n\r\n    // Resolve relative image URLs to absolute with better error handling\r\n    if (metadata.image && !metadata.image.startsWith('http')) {\r\n      try {\r\n        const urlObj = new URL(url);\r\n        const resolvedUrl = new URL(metadata.image, urlObj.origin).toString();\r\n        // Validate the resolved URL\r\n        new URL(resolvedUrl); // This will throw if invalid\r\n        metadata.image = resolvedUrl;\r\n      } catch (error) {\r\n        console.warn('Error resolving image URL:', metadata.image, error);\r\n        metadata.image = ''; // Clear invalid image URLs\r\n      }\r\n    }\r\n\r\n    // Resolve relative favicon URLs\r\n    if (metadata.favicon && !metadata.favicon.startsWith('http')) {\r\n      try {\r\n        const urlObj = new URL(url);\r\n        const resolvedUrl = new URL(metadata.favicon, urlObj.origin).toString();\r\n        new URL(resolvedUrl);\r\n        metadata.favicon = resolvedUrl;\r\n      } catch (error) {\r\n        console.warn('Error resolving favicon URL:', metadata.favicon, error);\r\n        metadata.favicon = `https://${new URL(url).hostname}/favicon.ico`;\r\n      }\r\n    }\r\n\r\n    // Validate final metadata\r\n    if (!metadata.title || metadata.title === 'No title found') {\r\n      console.warn('No valid title found for', url);\r\n    }\r\n\r\n    // Cache the result with processing time\r\n    const processingTime = Date.now() - startTime;\r\n    const cacheData = {\r\n      ...metadata,\r\n      processingTime,\r\n      cached: false,\r\n      fetchedAt: new Date().toISOString()\r\n    };\r\n\r\n    metadataCache.set(cacheKey, { data: cacheData, timestamp: Date.now() });\r\n\r\n    console.log(`Successfully processed metadata for ${url} in ${processingTime}ms`);\r\n\r\n    return NextResponse.json(cacheData, {\r\n      headers: {\r\n        'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',\r\n        'X-Cache': 'MISS',\r\n        'X-Processing-Time': processingTime.toString()\r\n      }\r\n    });\r\n  } catch (error: unknown) {\r\n    const processingTime = Date.now() - startTime;\r\n\r\n    // Handle different error types with user-friendly messages and enhanced logging\r\n    if (axios.isAxiosError(error)) {\r\n      // Network/timeout errors\r\n      if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT' || error.message.includes('timeout')) {\r\n        console.error('Metadata fetch timeout:', {\r\n          url: requestedUrl,\r\n          processingTime,\r\n          timeout: true\r\n        });\r\n\r\n        return NextResponse.json(\r\n          {\r\n            error: 'Request timeout. The website took too long to respond. Please try again.',\r\n            processingTime,\r\n            timeout: true\r\n          },\r\n          { status: 408 }\r\n        );\r\n      }\r\n\r\n      // HTTP status errors\r\n      if (error.response) {\r\n        const status = error.response.status;\r\n        console.warn('Metadata fetch HTTP error:', {\r\n          url: requestedUrl,\r\n          status,\r\n          processingTime\r\n        });\r\n\r\n        if (status === 403 || status === 401) {\r\n          return NextResponse.json(\r\n            {\r\n              error: 'This website has restrictions preventing metadata fetching. You can still add the link manually by entering the title and description yourself.',\r\n              restriction: true,\r\n              processingTime\r\n            },\r\n            { status: 403 }\r\n          );\r\n        }\r\n\r\n        if (status === 404) {\r\n          return NextResponse.json(\r\n            {\r\n              error: 'URL not found. Please check the URL and try again.',\r\n              processingTime\r\n            },\r\n            { status: 404 }\r\n          );\r\n        }\r\n\r\n        if (status === 429) {\r\n          return NextResponse.json(\r\n            {\r\n              error: 'Too many requests. Please wait a moment and try again.',\r\n              processingTime,\r\n              rateLimited: true\r\n            },\r\n            { status: 429 }\r\n          );\r\n        }\r\n\r\n        if (status >= 500) {\r\n          return NextResponse.json(\r\n            {\r\n              error: 'The website is experiencing issues. Please try again later.',\r\n              processingTime,\r\n              serverError: true\r\n            },\r\n            { status: 500 }\r\n          );\r\n        }\r\n      }\r\n\r\n      // CORS or network errors\r\n      if (error.message.includes('CORS') || error.message.includes('network') || error.message.includes('Failed to fetch')) {\r\n        console.warn('Metadata fetch network/CORS error:', {\r\n          url: requestedUrl,\r\n          error: error.message,\r\n          processingTime\r\n        });\r\n\r\n        return NextResponse.json(\r\n          {\r\n            error: 'This website has restrictions preventing metadata fetching. You can still add the link manually.',\r\n            restriction: true,\r\n            processingTime,\r\n            corsError: true\r\n          },\r\n          { status: 403 }\r\n        );\r\n      }\r\n    }\r\n\r\n    // Log detailed error for server-side debugging with structured logging\r\n    console.error('Metadata fetch error:', {\r\n      message: error instanceof Error ? error.message : 'Unknown error',\r\n      code: axios.isAxiosError(error) ? error.code : undefined,\r\n      status: axios.isAxiosError(error) ? error.response?.status : undefined,\r\n      requestedUrl: requestedUrl,\r\n      processingTime,\r\n      timestamp: new Date().toISOString(),\r\n      errorType: error instanceof Error ? error.constructor.name : 'Unknown'\r\n    });\r\n\r\n    // Generic error message with processing time\r\n    return NextResponse.json(\r\n      {\r\n        error: 'Unable to fetch link details. The website may have restrictions or be temporarily unavailable. You can still add the link manually.',\r\n        restriction: true,\r\n        processingTime,\r\n        fallback: true\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\api\\folders\\[id]\\share\\route.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":8,"column":10,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient } from '@/lib/supabase/server';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport const runtime = 'nodejs';\r\n\r\nexport async function POST(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ id: string }> }\r\n) {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Authenticate user\r\n    const {\r\n      data: { user },\r\n      error: authError\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return NextResponse.json(\r\n        { error: 'Authentication required' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    const { id: folderId } = await params;\r\n\r\n    // Verify folder exists and belongs to user\r\n    const { data: folder, error: folderError } = await supabase\r\n      .from('folders')\r\n      .select('*')\r\n      .eq('id', folderId)\r\n      .eq('user_id', user.id)\r\n      .single();\r\n\r\n    if (folderError || !folder) {\r\n      return NextResponse.json(\r\n        { error: 'Folder not found or access denied' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Generate share ID if not exists\r\n    let shareId = folder.share_id;\r\n    if (!shareId) {\r\n      shareId = `share_${uuidv4()}`;\r\n      \r\n      // Update folder with sharing info\r\n      const { error: updateError } = await supabase\r\n        .from('folders')\r\n        .update({\r\n          shareable: true,\r\n          share_id: shareId,\r\n          share_created_at: new Date().toISOString()\r\n        })\r\n        .eq('id', folderId)\r\n        .eq('user_id', user.id);\r\n\r\n      if (updateError) {\r\n        return NextResponse.json(\r\n          { error: 'Failed to enable sharing' },\r\n          { status: 500 }\r\n        );\r\n      }\r\n\r\n      // Create share record\r\n      console.log('Creating share record with data:', {\r\n        folder_id: folderId,\r\n        share_id: shareId,\r\n        user_id: user.id,\r\n        created_by: user.id\r\n      });\r\n      \r\n      const { data, error: shareError } = await supabase\r\n        .from('folder_shares')\r\n        .insert({\r\n          folder_id: folderId,\r\n          share_id: shareId,\r\n          user_id: user.id,\r\n          created_by: user.id\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      console.log('Share record creation result:', { data, shareError });\r\n\r\n      if (shareError) {\r\n        console.error('Share record creation failed:', shareError);\r\n        return NextResponse.json(\r\n          { error: 'Failed to create share record', details: shareError.message },\r\n          { status: 500 }\r\n        );\r\n      }\r\n    }\r\n\r\n    const baseUrl = request.nextUrl.origin;\r\n    const shareUrl = `${baseUrl}/share/folder/${shareId}`;\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      shareUrl,\r\n      shareId,\r\n      message: 'Folder sharing enabled successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Share folder error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function DELETE(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ id: string }> }\r\n) {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Authenticate user\r\n    const {\r\n      data: { user },\r\n      error: authError\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return NextResponse.json(\r\n        { error: 'Authentication required' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    const { id: folderId } = await params;\r\n\r\n    // Verify folder exists and belongs to user\r\n    const { data: folder, error: folderError } = await supabase\r\n      .from('folders')\r\n      .select('*')\r\n      .eq('id', folderId)\r\n      .eq('user_id', user.id)\r\n      .single();\r\n\r\n    if (folderError || !folder) {\r\n      return NextResponse.json(\r\n        { error: 'Folder not found or access denied' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Disable sharing\r\n    const { error: updateError } = await supabase\r\n      .from('folders')\r\n      .update({\r\n        shareable: false,\r\n        share_id: null,\r\n        share_created_at: null\r\n      })\r\n      .eq('id', folderId)\r\n      .eq('user_id', user.id);\r\n\r\n    if (updateError) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to disable sharing' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // Delete share record and analytics\r\n    await supabase\r\n      .from('share_analytics')\r\n      .delete()\r\n      .eq('share_id', folder.share_id);\r\n\r\n    await supabase\r\n      .from('folder_shares')\r\n      .delete()\r\n      .eq('share_id', folder.share_id);\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: 'Folder sharing disabled successfully'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Disable sharing error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\api\\share\\[shareId]\\route.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":7,"column":10,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient } from '@/lib/supabase/server';\r\nimport { NextResponse } from 'next/server';\r\n\r\nexport const runtime = 'nodejs';\r\n\r\nexport async function GET(\r\n  request: Request,\r\n  { params }: { params: Promise<{ shareId: string }> }\r\n) {\r\n  try {\r\n    const supabase = await createClient();\r\n    const { shareId } = await params;\r\n\r\n    // Get folder and links for sharing\r\n    const { data: folderData, error } = await supabase\r\n      .from('folders')\r\n      .select(`\r\n        id,\r\n        name,\r\n        description,\r\n        color,\r\n        icon,\r\n        shareable,\r\n        share_id,\r\n        share_created_at,\r\n        links (\r\n          id,\r\n          title,\r\n          description,\r\n          url,\r\n          thumbnail,\r\n          favicon_url,\r\n          platform,\r\n          is_favorite,\r\n          tags,\r\n          created_at\r\n        )\r\n      `)\r\n      .eq('share_id', shareId)\r\n      .eq('shareable', true)\r\n      .single();\r\n\r\n    if (error || !folderData) {\r\n      return NextResponse.json(\r\n        { error: 'Shared folder not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Track view analytics (non-blocking)\r\n    const clientIP = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown';\r\n    const userAgent = request.headers.get('user-agent') || 'unknown';\r\n    const referrer = request.headers.get('referer') || null;\r\n\r\n    // Track view analytics (fire and forget)\r\n    try {\r\n      await supabase\r\n        .from('share_analytics')\r\n        .insert({\r\n          share_id: shareId,\r\n          viewer_ip: clientIP,\r\n          user_agent: userAgent,\r\n          referral_source: referrer\r\n        });\r\n\r\n      // Increment view count\r\n      await supabase.rpc('increment_share_view_count', { share_id_param: shareId });\r\n    } catch (err) {\r\n      console.warn('Analytics tracking failed:', err);\r\n    }\r\n\r\n    // Transform data for frontend\r\n    const transformedData = {\r\n      id: folderData.id,\r\n      name: folderData.name,\r\n      description: folderData.description,\r\n      color: folderData.color,\r\n      icon: folderData.icon,\r\n      shareId: folderData.share_id,\r\n      shareCreatedAt: folderData.share_created_at,\r\n      links: folderData.links || [],\r\n      createdAt: folderData.share_created_at\r\n    };\r\n\r\n    return NextResponse.json(transformedData);\r\n\r\n  } catch (error) {\r\n    console.error('Get shared folder error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\api\\shares\\[shareId]\\route.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":6,"column":10,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\nexport async function GET(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ shareId: string }> }\r\n) {\r\n  try {\r\n    const { shareId } = await params;\r\n    const supabase = await createClient();\r\n    \r\n    // Get share information with folder and links\r\n    const { data: share, error: shareError } = await supabase\r\n      .from('folder_shares')\r\n      .select(`\r\n        *,\r\n        folders (\r\n          id,\r\n          name,\r\n          icon_name,\r\n          color,\r\n          description,\r\n          user_id\r\n        ),\r\n        folders:links (\r\n          id,\r\n          url,\r\n          title,\r\n          description:metadata->>description,\r\n          image:metadata->>image,\r\n          created_at\r\n        )\r\n      `)\r\n      .eq('id', shareId)\r\n      .single();\r\n\r\n    if (shareError || !share || !share.folders) {\r\n      logger.warn('Share validation failed:', { shareId, error: shareError });\r\n      return NextResponse.json(\r\n        { valid: false, error: 'Share not found or expired' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Return share information with links\r\n    return NextResponse.json({\r\n      valid: true,\r\n      data: {\r\n        id: share.id,\r\n        folder: {\r\n          id: share.folders.id,\r\n          name: share.folders.name,\r\n          iconName: share.folders.icon_name,\r\n          color: share.folders.color,\r\n          description: share.folders.description,\r\n          userId: share.folders.user_id,\r\n        },\r\n        links: share.folders_links || [],\r\n        createdAt: share.created_at,\r\n      },\r\n    });\r\n\r\n  } catch (error) {\r\n    logger.error('Share validation error:', error);\r\n    return NextResponse.json(\r\n      { valid: false, error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function DELETE(\r\n  request: NextRequest,\r\n  { params }: { params: Promise<{ shareId: string }> }\r\n) {\r\n  try {\r\n    const { shareId } = await params;\r\n    const supabase = await createClient();\r\n    \r\n    // Check authentication\r\n    const {\r\n      data: { user },\r\n      error: authError,\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Authentication required' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // Verify the share belongs to the user\r\n    const { data: share, error: shareError } = await supabase\r\n      .from('folder_shares')\r\n      .select('id, user_id')\r\n      .eq('id', shareId)\r\n      .eq('user_id', user.id)\r\n      .single();\r\n\r\n    if (shareError || !share) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Share not found or access denied' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Delete the share\r\n    const { error: deleteError } = await supabase\r\n      .from('folder_shares')\r\n      .delete()\r\n      .eq('id', shareId);\r\n\r\n    if (deleteError) {\r\n      logger.error('Share deletion error:', deleteError);\r\n      return NextResponse.json(\r\n        { success: false, error: 'Failed to delete share' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: 'Share link revoked successfully',\r\n    });\r\n\r\n  } catch (error) {\r\n    logger.error('Share deletion error:', error);\r\n    return NextResponse.json(\r\n      { success: false, error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\api\\shares\\route.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":4,"column":35,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { createClient } from '@/lib/supabase/server';\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    console.log('Share creation request received');\r\n    const supabase = await createClient();\r\n    \r\n    // Check authentication\r\n    const {\r\n      data: { user },\r\n      error: authError,\r\n    } = await supabase.auth.getUser();\r\n    \r\n    console.log('Authentication check:', { hasUser: !!user, authError: !!authError });\r\n\r\n    if (authError || !user) {\r\n      console.log('Authentication failed:', { authError });\r\n      return NextResponse.json(\r\n        { error: 'Authentication required' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    console.log('User authenticated:', { userId: user.id });\r\n\r\n    const body = await request.json();\r\n    console.log('Request body:', body);\r\n    \r\n    const { folderId } = body;\r\n\r\n    // Validate required fields\r\n    if (!folderId) {\r\n      console.log('Folder ID missing');\r\n      return NextResponse.json(\r\n        { error: 'Folder ID is required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    console.log('Validating folder:', { folderId, userId: user.id });\r\n\r\n    // Validate folder exists and belongs to user\r\n    const { data: folder, error: folderError } = await supabase\r\n      .from('folders')\r\n      .select('id, name, user_id')\r\n      .eq('id', folderId)\r\n      .eq('user_id', user.id)\r\n      .single();\r\n\r\n    console.log('Folder query result:', { folder, folderError });\r\n\r\n    if (folderError || !folder) {\r\n      return NextResponse.json(\r\n        { error: 'Folder not found or access denied' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    console.log('Folder validated:', { folderId: folder.id, folderName: folder.name });\r\n\r\n    // Generate share ID (UUID format for database compatibility)\r\n    const shareId = crypto.randomUUID();\r\n    \r\n    // Set expiration time to 1 hour from now\r\n    const expiresAt = new Date(Date.now() + 60 * 60 * 1000).toISOString(); // 1 hour\r\n\r\n    console.log('Creating share record:', { shareId, folderId, userId: user.id, expiresAt });\r\n\r\n    // Insert share record (simplified - no password or expiration)\r\n    const { data: share, error: insertError } = await supabase\r\n      .from('folder_shares')\r\n      .insert({\r\n        id: shareId,\r\n        folder_id: folderId,\r\n        user_id: user.id,\r\n        created_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString(),\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    console.log('Share creation result:', { share, insertError });\r\n\r\n    if (insertError) {\r\n      console.error('Share creation error:', { insertError, shareId, folderId, userId: user.id });\r\n      return NextResponse.json(\r\n        { error: `Failed to create share link: ${insertError.message}` },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // Return share information\r\n    const baseUrl = request.nextUrl.origin;\r\n    const shareUrl = `${baseUrl}/shared/${shareId}`;\r\n\r\n    console.log('Share created successfully:', {\r\n      shareId: share.id,\r\n      shareData: share,\r\n      shareUrl\r\n    });\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: {\r\n        id: share.id,\r\n        shareUrl,\r\n        folder: {\r\n          id: folder.id,\r\n          name: folder.name,\r\n        },\r\n        createdAt: share.created_at,\r\n      },\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Share creation error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const supabase = await createClient();\r\n    \r\n    // Get all shares for the authenticated user\r\n    const {\r\n      data: { user },\r\n      error: authError,\r\n    } = await supabase.auth.getUser();\r\n\r\n    if (authError || !user) {\r\n      return NextResponse.json(\r\n        { error: 'Authentication required' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // Get user's shares with folder information\r\n    const { data: shares, error: sharesError } = await supabase\r\n      .from('folder_shares')\r\n      .select(`\r\n        *,\r\n        folders (id, name)\r\n      `)\r\n      .eq('user_id', user.id)\r\n      .order('created_at', { ascending: false });\r\n\r\n    if (sharesError) {\r\n      console.error('Get shares error:', sharesError);\r\n      return NextResponse.json(\r\n        { error: 'Failed to retrieve shares' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    const baseUrl = request.nextUrl.origin;\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: shares.map((share: any) => ({\r\n        id: share.id,\r\n        shareUrl: `${baseUrl}/shared/${share.id}`,\r\n        folder: share.folders,\r\n        createdAt: share.created_at,\r\n        updatedAt: share.updated_at,\r\n      })),\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Get shares error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\app\\app-client.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":36,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file app/app/app-client.tsx\r\n * @description Client component for app page with hydrated data\r\n * @created 2025-01-XX\r\n */\r\n\r\n\"use client\";\r\n\r\nimport React, { useMemo, useState, useEffect, useCallback, useDeferredValue } from \"react\";\r\nimport { Star, Trash2, RotateCcw, Search } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { usePerformanceMonitor } from \"@/hooks/use-performance-monitor\";\r\nimport { Header } from \"@/components/layout/header\";\r\nimport { Sidebar } from \"@/components/layout/sidebar\";\r\nimport { LinkGrid } from \"@/components/links/link-grid\";\r\nimport { MobileFAB } from \"@/components/common/mobile-fab\";\r\nimport { EmptyState } from \"@/components/common/empty-state\";\r\nimport { BulkActionBar } from \"@/components/common/bulk-action-bar\";\r\nimport {\r\n  LazyAddLinkModal,\r\n  LazyCreateFolderModal,\r\n  LazyEmptyTrashModal,\r\n  LazyRestoreAllModal\r\n} from \"@/components/lazy\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { useKeyboardShortcuts } from \"@/hooks/use-keyboard-shortcuts\";\r\nimport { useSpecificFolderDescendants } from \"@/hooks/use-folder-descendants\";\r\nimport { useDebounce } from \"@/hooks/use-debounce\";\r\nimport { SEARCH_DEBOUNCE_DELAY } from \"@/constants\";\r\nimport { useAuth } from \"@/lib/contexts/auth-context\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { Link, Folder } from \"@/types\";\r\n\r\ninterface AppClientProps {\r\n  initialLinks?: Link[];\r\n  initialFolders?: Folder[];\r\n}\r\n\r\n/**\r\n * OPTIMIZED: Client component that receives server-rendered initial data\r\n * This improves initial load time and LCP\r\n */\r\nexport function AppClient({ initialLinks = [], initialFolders = [] }: AppClientProps) {\r\n  const router = useRouter();\r\n  const { user, loading: authLoading } = useAuth();\r\n\r\n  // Use selective store selectors with shallow comparison to minimize re-renders\r\n  const links = useStore((state) => state.links.length > 0 ? state.links : initialLinks);\r\n  const folders = useStore((state) => state.folders.length > 0 ? state.folders : initialFolders);\r\n  const selectedFolderId = useStore((state) => state.selectedFolderId);\r\n  const currentView = useStore((state) => state.currentView);\r\n  const searchFilters = useStore((state) => state.searchFilters);\r\n  const isHydrated = useStore((state) => state.isHydrated);\r\n  const isLoadingLinks = useStore((state) => state.isLoadingLinks);\r\n\r\n  const setSearchFilters = useStore((state) => state.setSearchFilters);\r\n  const setAddLinkModalOpen = useStore((state) => state.setAddLinkModalOpen);\r\n  const emptyTrash = useStore((state) => state.emptyTrash);\r\n  const restoreAllFromTrash = useStore((state) => state.restoreAllFromTrash);\r\n  const isAddLinkModalOpen = useStore((state) => state.isAddLinkModalOpen);\r\n  const isCreateFolderModalOpen = useStore((state) => state.isCreateFolderModalOpen);\r\n  const { toast } = useToast();\r\n\r\n  // Show loading skeleton while store is hydrating OR while links are loading\r\n  // OPTIMIZED: Use initial data to show content immediately\r\n  const isInitialLoading = !isHydrated && initialLinks.length === 0;\r\n\r\n  // Performance monitoring - disabled to reduce overhead\r\n  const { trackMetric, trackInteraction, trackError } = usePerformanceMonitor({\r\n    componentName: 'AppPage',\r\n    trackRenders: false,\r\n    trackInteractions: true,\r\n    trackErrors: true\r\n  });\r\n\r\n\r\n  const [selectedIds, setSelectedIds] = useState<string[]>([]);\r\n  const [showEmptyTrashModal, setShowEmptyTrashModal] = useState(false);\r\n  const [showRestoreAllModal, setShowRestoreAllModal] = useState(false);\r\n\r\n  // Debounce search query for better performance\r\n  const debouncedSearchQuery = useDebounce(searchFilters.query, SEARCH_DEBOUNCE_DELAY);\r\n\r\n  // Derived state for search loading\r\n  const isDebouncing = searchFilters.query !== debouncedSearchQuery;\r\n\r\n  // Defer expensive computations to avoid blocking initial render\r\n  const deferredLinks = useDeferredValue(links);\r\n  const deferredFolders = useDeferredValue(folders);\r\n  const deferredSelectedFolderId = useDeferredValue(selectedFolderId);\r\n  const deferredCurrentView = useDeferredValue(currentView);\r\n  const deferredSearchQuery = useDeferredValue(debouncedSearchQuery);\r\n\r\n  // Get all descendant folder IDs for the selected folder\r\n  const descendantFolderIds = useSpecificFolderDescendants(\r\n    isLoadingLinks ? null : deferredSelectedFolderId,\r\n    deferredFolders\r\n  );\r\n\r\n  // Filter links based on view, folder, and search query\r\n  const filteredLinks = useMemo(() => {\r\n    if (isLoadingLinks && initialLinks.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    let filtered = deferredLinks;\r\n\r\n    // Filter by view\r\n    if (deferredCurrentView === 'trash') {\r\n      filtered = filtered.filter((link) => link.deletedAt !== null);\r\n    } else {\r\n      filtered = filtered.filter((link) => link.deletedAt === null);\r\n\r\n      if (deferredCurrentView === 'favorites') {\r\n        filtered = filtered.filter((link) => link.isFavorite);\r\n      } else {\r\n        if (deferredSelectedFolderId && descendantFolderIds.length > 0) {\r\n          filtered = filtered.filter((link) =>\r\n            link.folderId && descendantFolderIds.includes(link.folderId)\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Filter by search query\r\n    if (deferredSearchQuery) {\r\n      const query = deferredSearchQuery.toLowerCase();\r\n      filtered = filtered.filter(\r\n        (link) =>\r\n          link.title.toLowerCase().includes(query) ||\r\n          link.description.toLowerCase().includes(query) ||\r\n          link.url.toLowerCase().includes(query) ||\r\n          (link.tags && link.tags.some(tag => tag.toLowerCase().includes(query)))\r\n      );\r\n    }\r\n\r\n    // Sort by date (newest first)\r\n    return [...filtered].sort(\r\n      (a, b) =>\r\n        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\r\n    );\r\n  }, [deferredLinks, deferredSelectedFolderId, deferredCurrentView, deferredSearchQuery, descendantFolderIds, isLoadingLinks, initialLinks.length]);\r\n\r\n  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const startTime = performance.now();\r\n    const query = e.target.value;\r\n\r\n    try {\r\n      setSearchFilters({ query });\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('search_input_time', duration, {\r\n        queryLength: query.length.toString(),\r\n        hasQuery: (!!query).toString()\r\n      });\r\n\r\n      trackInteraction('input', 'search_query', {\r\n        queryLength: query.length.toString(),\r\n        hasQuery: (!!query).toString(),\r\n        duration: duration.toString()\r\n      });\r\n    } catch (error) {\r\n      trackError('Search input error', {\r\n        action: 'search_input',\r\n        queryLength: query.length\r\n      });\r\n    }\r\n  }, [setSearchFilters, trackMetric, trackInteraction, trackError]);\r\n\r\n  // Memoize callbacks\r\n  const handleToggleSelect = useCallback((linkId: string) => {\r\n    setSelectedIds(prev =>\r\n      prev.includes(linkId)\r\n        ? prev.filter(id => id !== linkId)\r\n        : [...prev, linkId]\r\n    );\r\n  }, []);\r\n\r\n  const handleClearSelection = useCallback(() => {\r\n    trackInteraction('click', 'clear_selection', {\r\n      selectedCount: selectedIds.length.toString()\r\n    });\r\n    setSelectedIds([]);\r\n  }, [selectedIds.length, trackInteraction]);\r\n\r\n  const handleSelectAllEvent = useCallback(() => {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const visibleLinkIds = filteredLinks.map(link => link.id);\r\n      setSelectedIds(prev => {\r\n        const allSelected = visibleLinkIds.every(id => prev.includes(id));\r\n        if (allSelected) {\r\n          return prev.filter(id => !visibleLinkIds.includes(id));\r\n        } else {\r\n          const newSelection = [...prev];\r\n          visibleLinkIds.forEach(id => {\r\n            if (!newSelection.includes(id)) {\r\n              newSelection.push(id);\r\n            }\r\n          });\r\n          return newSelection;\r\n        }\r\n      });\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('select_all_time', duration, {\r\n        visibleLinksCount: visibleLinkIds.length.toString(),\r\n        currentView\r\n      });\r\n    } catch (error) {\r\n      trackError('Select all toggle error', {\r\n        action: 'select_all_toggle',\r\n        visibleLinksCount: filteredLinks.length\r\n      });\r\n    }\r\n  }, [filteredLinks, currentView, trackMetric, trackError]); // trackInteraction removed - not used in callback\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('selectAllVisible', handleSelectAllEvent);\r\n    return () => window.removeEventListener('selectAllVisible', handleSelectAllEvent);\r\n  }, [handleSelectAllEvent]);\r\n\r\n  const handleEmptyTrash = useCallback(() => {\r\n    emptyTrash();\r\n    toast({\r\n      title: \"Trash emptied\",\r\n      description: `(${filteredLinks.length})`,\r\n      variant: \"success\",\r\n    });\r\n  }, [emptyTrash, toast, filteredLinks.length]);\r\n\r\n  const handleRestoreAll = useCallback(() => {\r\n    const count = filteredLinks.length;\r\n    restoreAllFromTrash();\r\n    toast({\r\n      title: \"All items restored\",\r\n      description: `(${count})`,\r\n      variant: \"success\",\r\n      icon: <RotateCcw className=\"size-4\" />,\r\n    });\r\n  }, [restoreAllFromTrash, toast, filteredLinks.length]);\r\n\r\n  const pageTitle = useMemo(() => {\r\n    if (isLoadingLinks) return 'Loading...';\r\n    if (deferredCurrentView === 'favorites') return 'Favorites';\r\n    if (deferredCurrentView === 'trash') return 'Trash';\r\n    if (deferredSelectedFolderId) {\r\n      const folder = deferredFolders.find(f => f.id === deferredSelectedFolderId);\r\n      return folder?.name || 'All Links';\r\n    }\r\n    return 'All Links';\r\n  }, [deferredCurrentView, deferredSelectedFolderId, deferredFolders, isLoadingLinks]);\r\n\r\n  const titleClassName = useMemo(() => {\r\n    const length = pageTitle.length;\r\n    if (length > 30) return 'text-sm sm:text-base md:text-base lg:text-lg';\r\n    if (length > 20) return 'text-base sm:text-lg md:text-lg lg:text-xl';\r\n    if (length > 12) return 'text-lg sm:text-xl md:text-xl lg:text-2xl';\r\n    return 'text-xl sm:text-2xl md:text-2xl lg:text-3xl';\r\n  }, [pageTitle]);\r\n\r\n  useEffect(() => {\r\n    setSelectedIds([]);\r\n  }, [currentView]);\r\n\r\n  useKeyboardShortcuts([\r\n    {\r\n      key: 'k',\r\n      ctrlKey: true,\r\n      callback: () => setAddLinkModalOpen(true),\r\n    },\r\n  ]);\r\n\r\n  if (isInitialLoading) {\r\n    return (\r\n      <div className=\"flex h-screen flex-col\">\r\n        <Header />\r\n        <div className=\"flex flex-1 overflow-hidden\">\r\n          <Sidebar />\r\n          <main className=\"flex-1 overflow-y-auto\">\r\n            <div className=\"container p-4 md:p-6\">\r\n              <div className=\"mb-6 h-8 w-48 animate-pulse rounded bg-muted\" />\r\n              <div className=\"grid grid-cols-2 gap-4 sm:gap-6 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4\">\r\n                {Array.from({ length: 8 }).map((_, i) => (\r\n                  <div key={i} className=\"rounded-lg border bg-card overflow-hidden\">\r\n                    <div className=\"h-28 sm:h-32 w-full animate-pulse bg-muted\" />\r\n                    <div className=\"p-3 sm:p-4 space-y-2\">\r\n                      <div className=\"h-3 w-3/4 animate-pulse rounded bg-muted\" />\r\n                      <div className=\"h-2.5 w-full animate-pulse rounded bg-muted\" />\r\n                      <div className=\"h-2.5 w-2/3 animate-pulse rounded bg-muted\" />\r\n                    </div>\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          </main>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Rest of the component JSX is the same as original AppPage\r\n  return (\r\n    <div className=\"flex h-screen flex-col\">\r\n      <Header />\r\n      <div className=\"flex flex-1 overflow-hidden\">\r\n        <Sidebar />\r\n        <main className=\"flex-1 overflow-y-auto\">\r\n          <div className=\"container mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-8\">\r\n            <div className=\"mb-8 sm:mb-10\">\r\n              <div className=\"flex flex-col gap-4 sm:gap-5 md:flex-row md:items-center md:justify-between md:gap-6\">\r\n                <div className=\"flex items-baseline gap-3 sm:gap-4 min-w-0 md:order-1 md:flex-1\">\r\n                  <h1 className={`${titleClassName} font-bold tracking-tight truncate text-foreground`}>\r\n                    {pageTitle}\r\n                  </h1>\r\n                  <span className=\"text-sm sm:text-base text-muted-foreground flex-shrink-0 font-medium tabular-nums\">\r\n                    ({isLoadingLinks ? '...' : filteredLinks.length})\r\n                  </span>\r\n                </div>\r\n\r\n                {/* Search Bar - Right aligned on desktop */}\r\n                <div className=\"w-full md:w-64 lg:w-72 md:order-2 relative z-10\">\r\n                  <div className=\"relative\">\r\n                    <Search className=\"absolute left-2.5 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground pointer-events-none\" />\r\n                    <Input\r\n                      type=\"text\"\r\n                      placeholder=\"Search links...\"\r\n                      value={searchFilters.query}\r\n                      onChange={handleSearchChange}\r\n                      className=\"pl-9 h-9 w-full bg-background border-input focus:border-primary focus-visible:ring-1 focus-visible:ring-primary transition-all shadow-sm\"\r\n                    />\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {deferredCurrentView === 'trash' && !isLoadingLinks && filteredLinks.length > 0 && (\r\n                <div className=\"flex justify-end mt-4 sm:mt-5\">\r\n                  <div className=\"flex items-center gap-2 sm:gap-3\">\r\n                    <Button\r\n                      variant=\"ghost\"\r\n                      size=\"icon\"\r\n                      onClick={() => setShowRestoreAllModal(true)}\r\n                      className=\"h-11 w-11 text-green-600 hover:text-green-700 hover:bg-green-600/10 dark:text-green-500 dark:hover:text-green-400 dark:hover:bg-green-500/10 transition-all duration-200 rounded-lg\"\r\n                      title=\"Restore all\"\r\n                      aria-label=\"Restore all items\"\r\n                    >\r\n                      <RotateCcw className=\"h-5 w-5\" />\r\n                    </Button>\r\n                    <Button\r\n                      variant=\"ghost\"\r\n                      size=\"icon\"\r\n                      onClick={() => setShowEmptyTrashModal(true)}\r\n                      className=\"h-11 w-11 text-destructive hover:text-destructive/90 hover:bg-destructive/10 transition-all duration-200 rounded-lg\"\r\n                      title=\"Empty trash\"\r\n                      aria-label=\"Empty trash permanently\"\r\n                    >\r\n                      <Trash2 className=\"h-5 w-5\" />\r\n                    </Button>\r\n                  </div>\r\n                </div>\r\n              )}\r\n            </div>\r\n            {!isLoadingLinks && deferredCurrentView === 'favorites' && filteredLinks.length === 0 && deferredLinks.length > 0 ? (\r\n              <EmptyState\r\n                icon={Star}\r\n                title=\"No favorites yet\"\r\n                description=\"Click the star icon on any link card to mark it as a favorite and see it here.\"\r\n              />\r\n            ) : !isLoadingLinks && deferredCurrentView === 'trash' && filteredLinks.length === 0 ? (\r\n              <EmptyState\r\n                icon={Trash2}\r\n                title=\"Trash is empty\"\r\n                description=\"Deleted links will appear here. You'll be able to restore them or delete them permanently.\"\r\n              />\r\n            ) : (\r\n              <LinkGrid\r\n                links={filteredLinks}\r\n                isInTrash={deferredCurrentView === 'trash'}\r\n                isLoading={isDebouncing || isLoadingLinks}\r\n                selectedIds={selectedIds}\r\n                onToggleSelect={handleToggleSelect}\r\n                isSelectionModeActive={selectedIds.length > 0}\r\n              />\r\n            )}\r\n          </div>\r\n        </main>\r\n      </div>\r\n\r\n      {/* Lazy-loaded modals */}\r\n      {isAddLinkModalOpen && (\r\n        <React.Suspense fallback={null}>\r\n          <LazyAddLinkModal />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      {isCreateFolderModalOpen && (\r\n        <React.Suspense fallback={null}>\r\n          <LazyCreateFolderModal />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      {showEmptyTrashModal && (\r\n        <React.Suspense fallback={null}>\r\n          <LazyEmptyTrashModal\r\n            isOpen={showEmptyTrashModal}\r\n            onClose={() => setShowEmptyTrashModal(false)}\r\n            onConfirm={handleEmptyTrash}\r\n            trashCount={filteredLinks.length}\r\n          />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      {showRestoreAllModal && (\r\n        <React.Suspense fallback={null}>\r\n          <LazyRestoreAllModal\r\n            isOpen={showRestoreAllModal}\r\n            onClose={() => setShowRestoreAllModal(false)}\r\n            onConfirm={handleRestoreAll}\r\n            trashCount={filteredLinks.length}\r\n          />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      <MobileFAB />\r\n\r\n      <BulkActionBar\r\n        selectedIds={selectedIds}\r\n        onClearSelection={handleClearSelection}\r\n        totalVisibleItems={filteredLinks.length}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\app\\page.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ]","line":82,"column":57,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file app/app/page.tsx\r\n * @description Main application page for authenticated users\r\n * @created 2025-01-01\r\n */\r\n\r\n\"use client\";\r\n\r\nimport React, { useMemo, useState, useEffect, useCallback, useDeferredValue } from \"react\";\r\nimport { Star, Trash2, RotateCcw, Search } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { usePerformanceMonitor } from \"@/hooks/use-performance-monitor\";\r\nimport { Header } from \"@/components/layout/header\";\r\nimport { Sidebar } from \"@/components/layout/sidebar\";\r\nimport { LinkGrid } from \"@/components/links/link-grid\";\r\nimport { MobileFAB } from \"@/components/common/mobile-fab\";\r\nimport { EmptyState } from \"@/components/common/empty-state\";\r\nimport { BulkActionBar } from \"@/components/common/bulk-action-bar\";\r\nimport {\r\n  LazyAddLinkModal,\r\n  LazyCreateFolderModal,\r\n  LazyEmptyTrashModal,\r\n  LazyRestoreAllModal\r\n} from \"@/components/lazy\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { useKeyboardShortcuts } from \"@/hooks/use-keyboard-shortcuts\";\r\nimport { useSpecificFolderDescendants } from \"@/hooks/use-folder-descendants\";\r\nimport { useDebounce } from \"@/hooks/use-debounce\";\r\nimport { SEARCH_DEBOUNCE_DELAY } from \"@/constants\";\r\nimport { useAuth } from \"@/lib/contexts/auth-context\";\r\nimport { useRouter } from \"next/navigation\";\r\n\r\n/**\r\n * Main application page component for authenticated users.\r\n * Displays links in grid/list view with search, filtering, and bulk actions.\r\n * Supports folder navigation, favorites, and trash views.\r\n * @returns {JSX.Element} Application page component\r\n */\r\nexport default function AppPage() {\r\n  const router = useRouter();\r\n  const { user, loading: authLoading } = useAuth();\r\n\r\n  // Redirect to login if not authenticated (edge case: session expired during use)\r\n  useEffect(() => {\r\n    if (!authLoading && !user) {\r\n      router.replace('/login?expired=true');\r\n    }\r\n  }, [user, authLoading, router]);\r\n\r\n  // Use selective store selectors with shallow comparison to minimize re-renders\r\n  const links = useStore((state) => state.links);\r\n  const folders = useStore((state) => state.folders);\r\n  const selectedFolderId = useStore((state) => state.selectedFolderId);\r\n  const currentView = useStore((state) => state.currentView);\r\n  const searchFilters = useStore((state) => state.searchFilters);\r\n  const isHydrated = useStore((state) => state.isHydrated);\r\n  const isLoadingLinks = useStore((state) => state.isLoadingLinks);\r\n\r\n  const setSearchFilters = useStore((state) => state.setSearchFilters);\r\n  const setAddLinkModalOpen = useStore((state) => state.setAddLinkModalOpen);\r\n  const emptyTrash = useStore((state) => state.emptyTrash);\r\n  const restoreAllFromTrash = useStore((state) => state.restoreAllFromTrash);\r\n  const isAddLinkModalOpen = useStore((state) => state.isAddLinkModalOpen);\r\n  const isCreateFolderModalOpen = useStore((state) => state.isCreateFolderModalOpen);\r\n  const { toast } = useToast();\r\n\r\n  // Show loading skeleton while store is hydrating OR while links are loading\r\n  const isInitialLoading = !isHydrated || isLoadingLinks;\r\n  const isLoadingData = useStore((state) => state.isLoadingData);\r\n\r\n  // Performance monitoring for main app page - disabled to reduce overhead\r\n  const { trackMetric, trackInteraction, trackError } = usePerformanceMonitor({\r\n    componentName: 'AppPage',\r\n    trackRenders: false, // Disabled to reduce overhead - only track interactions and errors\r\n    trackInteractions: true,\r\n    trackErrors: true\r\n  });\r\n\r\n\r\n  const [selectedIds, setSelectedIds] = useState<string[]>([]);\r\n  const [showEmptyTrashModal, setShowEmptyTrashModal] = useState(false);\r\n  const [showRestoreAllModal, setShowRestoreAllModal] = useState(false);\r\n\r\n  // Debounce search query for better performance\r\n  const debouncedSearchQuery = useDebounce(searchFilters.query, SEARCH_DEBOUNCE_DELAY);\r\n\r\n  // Derived state for search loading\r\n  const isDebouncing = searchFilters.query !== debouncedSearchQuery;\r\n\r\n  // Defer expensive computations to avoid blocking initial render\r\n  const deferredLinks = useDeferredValue(links);\r\n  const deferredFolders = useDeferredValue(folders);\r\n  const deferredSelectedFolderId = useDeferredValue(selectedFolderId);\r\n  const deferredCurrentView = useDeferredValue(currentView);\r\n  const deferredSearchQuery = useDeferredValue(debouncedSearchQuery);\r\n\r\n  // Get all descendant folder IDs for the selected folder (includes parent + all sub-folders)\r\n  // Only compute when not loading to avoid blocking\r\n  const descendantFolderIds = useSpecificFolderDescendants(\r\n    isLoadingLinks ? null : deferredSelectedFolderId,\r\n    deferredFolders\r\n  );\r\n\r\n  // Filter links based on view, folder, and search query\r\n  // Use deferred values to prevent blocking initial render\r\n  const filteredLinks = useMemo(() => {\r\n    // Early return if still loading to prevent expensive computation\r\n    if (isLoadingLinks && links.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    let filtered = deferredLinks;\r\n\r\n    // Filter by view\r\n    if (deferredCurrentView === 'trash') {\r\n      // Show only deleted links in trash\r\n      filtered = filtered.filter((link) => link.deletedAt !== null);\r\n    } else {\r\n      // Exclude deleted links from all other views\r\n      filtered = filtered.filter((link) => link.deletedAt === null);\r\n\r\n      if (deferredCurrentView === 'favorites') {\r\n        filtered = filtered.filter((link) => link.isFavorite);\r\n      } else {\r\n        // Filter by folder in 'all' view - includes all sub-folders recursively\r\n        if (deferredSelectedFolderId && descendantFolderIds.length > 0) {\r\n          filtered = filtered.filter((link) =>\r\n            link.folderId && descendantFolderIds.includes(link.folderId)\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Filter by debounced search query\r\n    if (deferredSearchQuery) {\r\n      const query = deferredSearchQuery.toLowerCase();\r\n      filtered = filtered.filter(\r\n        (link) =>\r\n          link.title.toLowerCase().includes(query) ||\r\n          link.description.toLowerCase().includes(query) ||\r\n          link.url.toLowerCase().includes(query) ||\r\n          (link.tags && link.tags.some(tag => tag.toLowerCase().includes(query)))\r\n      );\r\n    }\r\n\r\n    // Sort by date (newest first) - create new array to avoid mutating\r\n    return [...filtered].sort(\r\n      (a, b) =>\r\n        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\r\n    );\r\n  }, [deferredLinks, deferredSelectedFolderId, deferredCurrentView, deferredSearchQuery, descendantFolderIds, isLoadingLinks, links.length]);\r\n\r\n  // Memoize callbacks to prevent unnecessary re-renders\r\n  const handleToggleSelect = useCallback((linkId: string) => {\r\n    setSelectedIds(prev =>\r\n      prev.includes(linkId)\r\n        ? prev.filter(id => id !== linkId)\r\n        : [...prev, linkId]\r\n    );\r\n  }, []);\r\n\r\n  const handleClearSelection = useCallback(() => {\r\n    trackInteraction('click', 'clear_selection', {\r\n      selectedCount: selectedIds.length.toString()\r\n    });\r\n    setSelectedIds([]);\r\n  }, [selectedIds.length, trackInteraction]);\r\n\r\n  // Memoize select all handler\r\n  const handleSelectAllEvent = useCallback(() => {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const visibleLinkIds = filteredLinks.map(link => link.id);\r\n      setSelectedIds(prev => {\r\n        const allSelected = visibleLinkIds.every(id => prev.includes(id));\r\n        if (allSelected) {\r\n          return prev.filter(id => !visibleLinkIds.includes(id));\r\n        } else {\r\n          const newSelection = [...prev];\r\n          visibleLinkIds.forEach(id => {\r\n            if (!newSelection.includes(id)) {\r\n              newSelection.push(id);\r\n            }\r\n          });\r\n          return newSelection;\r\n        }\r\n      });\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('select_all_time', duration, {\r\n        visibleLinksCount: visibleLinkIds.length.toString(),\r\n        currentView\r\n      });\r\n\r\n      trackInteraction('click', 'select_all_toggle', {\r\n        visibleLinksCount: visibleLinkIds.length.toString(),\r\n        currentView,\r\n        duration: duration.toString()\r\n      });\r\n    } catch (error) {\r\n      trackError('Select all toggle error', {\r\n        action: 'select_all_toggle',\r\n        visibleLinksCount: filteredLinks.length\r\n      });\r\n    }\r\n  }, [filteredLinks, currentView, trackMetric, trackInteraction, trackError]);\r\n\r\n  // Listen for select all event from bulk action bar\r\n  useEffect(() => {\r\n    window.addEventListener('selectAllVisible', handleSelectAllEvent);\r\n    return () => window.removeEventListener('selectAllVisible', handleSelectAllEvent);\r\n  }, [handleSelectAllEvent]);\r\n\r\n  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const startTime = performance.now();\r\n    const query = e.target.value;\r\n\r\n    try {\r\n      // Update search filters immediately for responsive UI\r\n      setSearchFilters({ query });\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('search_input_time', duration, {\r\n        queryLength: query.length.toString(),\r\n        hasQuery: (!!query).toString()\r\n      });\r\n\r\n      trackInteraction('input', 'search_query', {\r\n        queryLength: query.length.toString(),\r\n        hasQuery: (!!query).toString(),\r\n        duration: duration.toString()\r\n      });\r\n    } catch (error) {\r\n      trackError('Search input error', {\r\n        action: 'search_input',\r\n        queryLength: query.length\r\n      });\r\n    }\r\n  }, [setSearchFilters, trackMetric, trackInteraction, trackError]);\r\n\r\n  // Memoize modal handlers\r\n  const handleEmptyTrash = useCallback(() => {\r\n    emptyTrash();\r\n    toast({\r\n      title: \"Trash emptied\",\r\n      description: `(${filteredLinks.length})`,\r\n      variant: \"success\",\r\n    });\r\n  }, [emptyTrash, toast, filteredLinks.length]);\r\n\r\n  const handleRestoreAll = useCallback(() => {\r\n    const count = filteredLinks.length;\r\n    restoreAllFromTrash();\r\n    toast({\r\n      title: \"All items restored\",\r\n      description: `(${count})`,\r\n      variant: \"success\",\r\n      icon: <RotateCcw className=\"size-4\" />,\r\n    });\r\n  }, [restoreAllFromTrash, toast, filteredLinks.length]);\r\n\r\n  // Memoize page title and title class name - use deferred values for performance\r\n  const pageTitle = useMemo(() => {\r\n    if (isLoadingLinks) return 'Loading...';\r\n    if (deferredCurrentView === 'favorites') return 'Favorites';\r\n    if (deferredCurrentView === 'trash') return 'Trash';\r\n    if (deferredSelectedFolderId) {\r\n      const folder = deferredFolders.find(f => f.id === deferredSelectedFolderId);\r\n      return folder?.name || 'All Links';\r\n    }\r\n    return 'All Links';\r\n  }, [deferredCurrentView, deferredSelectedFolderId, deferredFolders, isLoadingLinks]);\r\n\r\n  const titleClassName = useMemo(() => {\r\n    const length = pageTitle.length;\r\n    if (length > 30) return 'text-sm sm:text-base md:text-base lg:text-lg';\r\n    if (length > 20) return 'text-base sm:text-lg md:text-lg lg:text-xl';\r\n    if (length > 12) return 'text-lg sm:text-xl md:text-xl lg:text-2xl';\r\n    return 'text-xl sm:text-2xl md:text-2xl lg:text-3xl';\r\n  }, [pageTitle]);\r\n\r\n  // Clear selection when switching views\r\n  useEffect(() => {\r\n    setSelectedIds([]);\r\n  }, [currentView]);\r\n\r\n  // Keyboard shortcuts\r\n  useKeyboardShortcuts([\r\n    {\r\n      key: 'k',\r\n      ctrlKey: true,\r\n      callback: () => setAddLinkModalOpen(true),\r\n    },\r\n  ]);\r\n\r\n  // Remove the isInitialLoading condition completely\r\n  // All UI elements should be persistent and always visible\r\n\r\n  return (\r\n    <div className=\"flex h-screen flex-col\">\r\n      <Header />\r\n      <div className=\"flex flex-1 overflow-hidden\">\r\n        <Sidebar />\r\n        <main className=\"flex-1 overflow-y-auto\">\r\n          <div className=\"container mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-8\">\r\n            <div className=\"mb-8 sm:mb-10\">\r\n              {/* Mobile: Search first, then title below */}\r\n              {/* Desktop: Title left, search right */}\r\n              <div className=\"flex flex-col gap-4 sm:gap-5 md:flex-row md:items-center md:justify-between md:gap-6\">\r\n                {/* Title + Count - Below search on mobile, left on desktop */}\r\n                <div className=\"flex items-baseline gap-3 sm:gap-4 min-w-0 md:order-1 md:flex-1\">\r\n                  <h1 className={`${titleClassName} font-bold tracking-tight truncate text-foreground`}>\r\n                    {isLoadingData ? 'Loading...' : pageTitle}\r\n                  </h1>\r\n                  <span className=\"text-sm sm:text-base text-muted-foreground flex-shrink-0 font-medium tabular-nums\">\r\n                    ({isLoadingData ? '...' : filteredLinks.length})\r\n                  </span>\r\n                </div>\r\n\r\n                {/* Search Bar - Right aligned on desktop */}\r\n                <div className=\"w-full md:w-64 lg:w-72 md:order-2\">\r\n                  <div className=\"relative\">\r\n                    <Search className=\"absolute left-2.5 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground pointer-events-none\" />\r\n                    <Input\r\n                      type=\"text\"\r\n                      placeholder=\"Search links...\"\r\n                      value={searchFilters.query}\r\n                      onChange={handleSearchChange}\r\n                      className=\"pl-9 h-9 w-full bg-background border-input focus:border-primary focus-visible:ring-1 focus-visible:ring-primary transition-all shadow-sm\"\r\n                    />\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Trash Actions Row - Only in trash view, below view toggle */}\r\n              {deferredCurrentView === 'trash' && !isLoadingData && filteredLinks.length > 0 && (\r\n                <div className=\"flex justify-end mt-4 sm:mt-5\">\r\n                  <div className=\"flex items-center gap-2 sm:gap-3\">\r\n                    <Button\r\n                      variant=\"ghost\"\r\n                      size=\"icon\"\r\n                      onClick={() => setShowRestoreAllModal(true)}\r\n                      className=\"h-11 w-11 text-green-600 hover:text-green-700 hover:bg-green-600/10 dark:text-green-500 dark:hover:text-green-400 dark:hover:bg-green-500/10 transition-all duration-200 rounded-lg\"\r\n                      title=\"Restore all\"\r\n                      aria-label=\"Restore all items\"\r\n                    >\r\n                      <RotateCcw className=\"h-5 w-5\" />\r\n                    </Button>\r\n                    <Button\r\n                      variant=\"ghost\"\r\n                      size=\"icon\"\r\n                      onClick={() => setShowEmptyTrashModal(true)}\r\n                      className=\"h-11 w-11 text-destructive hover:text-destructive/90 hover:bg-destructive/10 transition-all duration-200 rounded-lg\"\r\n                      title=\"Empty trash\"\r\n                      aria-label=\"Empty trash permanently\"\r\n                    >\r\n                      <Trash2 className=\"h-5 w-5\" />\r\n                    </Button>\r\n                  </div>\r\n                </div>\r\n              )}\r\n            </div>\r\n            {/* Show skeleton loading ONLY for the content area, not the persistent UI */}\r\n            {isLoadingData || (filteredLinks.length === 0 && folders.length === 0 && deferredLinks.length === 0) ? (\r\n              // Show skeleton loading when:\r\n              // 1. Data is actively loading (isLoadingData)\r\n              // 2. OR no data has loaded yet (no links, no folders, no deferred links)\r\n              // This ensures skeleton loading shows until actual user data is available\r\n              <div className=\"grid grid-cols-1 gap-4 sm:gap-6 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4\">\r\n                {Array.from({ length: 12 }).map((_, i) => (\r\n                  <div key={i} className=\"rounded-lg border bg-card overflow-hidden\">\r\n                    <div className=\"h-28 sm:h-32 w-full animate-pulse bg-muted\" />\r\n                    <div className=\"p-3 sm:p-4 space-y-2\">\r\n                      <div className=\"h-3 w-3/4 animate-pulse rounded bg-muted\" />\r\n                      <div className=\"h-2.5 w-full animate-pulse rounded bg-muted\" />\r\n                      <div className=\"h-2.5 w-2/3 animate-pulse rounded bg-muted\" />\r\n                    </div>\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            ) : deferredCurrentView === 'favorites' && filteredLinks.length === 0 && deferredLinks.length > 0 ? (\r\n              <EmptyState\r\n                icon={Star}\r\n                title=\"No favorites yet\"\r\n                description=\"Click the star icon on any link card to mark it as a favorite and see it here.\"\r\n              />\r\n            ) : deferredCurrentView === 'trash' && filteredLinks.length === 0 ? (\r\n              <EmptyState\r\n                icon={Trash2}\r\n                title=\"Trash is empty\"\r\n                description=\"Deleted links will appear here. You'll be able to restore them or delete them permanently.\"\r\n              />\r\n            ) : filteredLinks.length === 0 ? (\r\n              <EmptyState\r\n                icon={deferredCurrentView === 'favorites' ? Star : Trash2}\r\n                title={deferredCurrentView === 'favorites' ? \"No favorites yet\" : \"No links found\"}\r\n                description={\r\n                  deferredCurrentView === 'favorites'\r\n                    ? \"Click the star icon on any link card to mark it as a favorite and see it here.\"\r\n                    : \"Your links will appear here. Add your first link to get started.\"\r\n                }\r\n              />\r\n            ) : (\r\n              <LinkGrid\r\n                links={filteredLinks}\r\n                isInTrash={deferredCurrentView === 'trash'}\r\n                isLoading={isDebouncing || isLoadingLinks}\r\n                selectedIds={selectedIds}\r\n                onToggleSelect={handleToggleSelect}\r\n                isSelectionModeActive={selectedIds.length > 0}\r\n              />\r\n            )}\r\n          </div>\r\n        </main>\r\n      </div>\r\n\r\n      {/* Lazy-loaded modals - only render when needed */}\r\n      {isAddLinkModalOpen && (\r\n        <React.Suspense fallback={null}>\r\n          <LazyAddLinkModal />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      {isCreateFolderModalOpen && (\r\n        <React.Suspense fallback={null}>\r\n          <LazyCreateFolderModal />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      {showEmptyTrashModal && (\r\n        <React.Suspense fallback={null}>\r\n          <LazyEmptyTrashModal\r\n            isOpen={showEmptyTrashModal}\r\n            onClose={() => setShowEmptyTrashModal(false)}\r\n            onConfirm={handleEmptyTrash}\r\n            trashCount={filteredLinks.length}\r\n          />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      {showRestoreAllModal && (\r\n        <React.Suspense fallback={null}>\r\n          <LazyRestoreAllModal\r\n            isOpen={showRestoreAllModal}\r\n            onClose={() => setShowRestoreAllModal(false)}\r\n            onConfirm={handleRestoreAll}\r\n            trashCount={filteredLinks.length}\r\n          />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      <MobileFAB />\r\n\r\n      {/* Bulk Action Bar */}\r\n      <BulkActionBar\r\n        selectedIds={selectedIds}\r\n        onClearSelection={handleClearSelection}\r\n        totalVisibleItems={filteredLinks.length}\r\n      />\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\error.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":9,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useEffect } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { AlertCircle, RefreshCw, Home } from 'lucide-react';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface ErrorProps {\r\n  error: Error & { digest?: string };\r\n  reset: () => void;\r\n}\r\n\r\nexport default function GlobalError({ error, reset }: ErrorProps) {\r\n  useEffect(() => {\r\n    // Log the error to our logging service\r\n    logger.error('Global error caught:', {\r\n      message: error.message,\r\n      stack: error.stack,\r\n      digest: error.digest,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }, [error]);\r\n\r\n  return (\r\n    <html>\r\n      <body>\r\n        <div className=\"min-h-screen flex items-center justify-center bg-background p-4\">\r\n          <Card className=\"w-full max-w-2xl\">\r\n            <CardHeader className=\"text-center\">\r\n              <div className=\"mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-destructive/10\">\r\n                <AlertCircle className=\"h-8 w-8 text-destructive\" />\r\n              </div>\r\n              <CardTitle className=\"text-2xl font-bold text-destructive\">\r\n                Something went wrong\r\n              </CardTitle>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-6\">\r\n              <div className=\"text-center\">\r\n                <p className=\"text-muted-foreground mb-4\">\r\n                  We apologize for the inconvenience. An unexpected error has occurred.\r\n                </p>\r\n                \r\n                {process.env.NODE_ENV === 'development' && (\r\n                  <div className=\"mt-6 rounded-lg border border-destructive/20 bg-destructive/5 p-4 text-left\">\r\n                    <h3 className=\"mb-2 font-semibold text-destructive\">Error Details</h3>\r\n                    <p className=\"mb-2 font-mono text-sm\">\r\n                      <strong>Error:</strong> {error.message}\r\n                    </p>\r\n                    {error.digest && (\r\n                      <p className=\"mb-2 font-mono text-sm\">\r\n                        <strong>Digest:</strong> {error.digest}\r\n                      </p>\r\n                    )}\r\n                    <details className=\"mt-2\">\r\n                      <summary className=\"cursor-pointer text-sm text-muted-foreground\">\r\n                        View stack trace\r\n                      </summary>\r\n                      <pre className=\"mt-2 overflow-x-auto rounded bg-muted p-3 font-mono text-xs\">\r\n                        {error.stack}\r\n                      </pre>\r\n                    </details>\r\n                  </div>\r\n                )}\r\n              </div>\r\n\r\n              <div className=\"flex flex-col gap-3 sm:flex-row sm:justify-center\">\r\n                <Button\r\n                  onClick={reset}\r\n                  variant=\"outline\"\r\n                  className=\"flex-1 sm:flex-none\"\r\n                >\r\n                  <RefreshCw className=\"mr-2 h-4 w-4\" />\r\n                  Try Again\r\n                </Button>\r\n                \r\n                <Button\r\n                  onClick={() => window.location.reload()}\r\n                  variant=\"outline\"\r\n                  className=\"flex-1 sm:flex-none\"\r\n                >\r\n                  <RefreshCw className=\"mr-2 h-4 w-4\" />\r\n                  Refresh Page\r\n                </Button>\r\n                \r\n                <Button\r\n                  onClick={() => window.location.href = '/app'}\r\n                  className=\"flex-1 sm:flex-none\"\r\n                >\r\n                  <Home className=\"mr-2 h-4 w-4\" />\r\n                  Go to Home\r\n                </Button>\r\n              </div>\r\n\r\n              <div className=\"mt-6 border-t pt-4 text-center\">\r\n                <p className=\"text-sm text-muted-foreground\">\r\n                  If this problem persists, please contact support.\r\n                </p>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      </body>\r\n    </html>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\layout-client.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":14,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { ThemeProvider } from '@/components/providers/theme-provider';\r\nimport { QueryProvider } from '@/components/providers/query-provider';\r\nimport { AuthProvider, useAuth } from '@/lib/contexts/auth-context';\r\nimport { StoreInitializer } from '@/components/providers/store-initializer';\r\nimport { ResourceHints } from '@/components/providers/resource-hints';\r\nimport { OfflineIndicator } from '@/components/common/offline-indicator';\r\nimport { Toaster } from '@/components/ui/toaster';\r\nimport { PerformanceDashboard } from '@/components/debug/performance-dashboard';\r\nimport { ShareFolderModal } from '@/components/modals/share-folder-modal';\r\nimport { AuthUser } from '@/lib/types/auth';\r\n\r\ninterface LayoutClientProps {\r\n  children: React.ReactNode;\r\n  initialUser?: AuthUser | null;\r\n}\r\n\r\n/**\r\n * Wrapper component to render PerformanceDashboard only for authenticated users\r\n */\r\nfunction AuthenticatedPerformanceDashboard() {\r\n  const { user } = useAuth();\r\n\r\n  // Only render performance dashboard if user is authenticated\r\n  // This prevents it from running on login page and respects user privacy\r\n  if (!user) {\r\n    return null;\r\n  }\r\n\r\n  return <PerformanceDashboard />;\r\n}\r\n\r\nexport function LayoutClient({ children, initialUser }: LayoutClientProps) {\r\n  return (\r\n    <ThemeProvider\r\n      attribute=\"class\"\r\n      defaultTheme=\"system\"\r\n      enableSystem\r\n      disableTransitionOnChange\r\n    >\r\n      <QueryProvider>\r\n        <ResourceHints />\r\n        <AuthProvider initialUser={initialUser}>\r\n          <StoreInitializer />\r\n          <OfflineIndicator />\r\n          {children}\r\n          <Toaster />\r\n          {/* Only show PerformanceDashboard for authenticated users */}\r\n          <AuthenticatedPerformanceDashboard />\r\n        </AuthProvider>\r\n        <ShareFolderModal />\r\n      </QueryProvider>\r\n    </ThemeProvider>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\layout.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token {","line":1,"column":13,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Metadata } from \"next\";\r\nimport { Inter, Space_Grotesk, JetBrains_Mono } from \"next/font/google\";\r\nimport \"./globals.css\";\r\nimport { LayoutClient } from \"./layout-client\";\r\nimport { createClient } from \"@/lib/supabase/server\";\r\n\r\n// OPTIMIZED: Font with display swap to prevent blocking LCP\r\nconst inter = Inter({\r\n  subsets: [\"latin\"],\r\n  display: 'swap',\r\n  preload: true,\r\n  adjustFontFallback: true,\r\n});\r\n\r\nconst spaceGrotesk = Space_Grotesk({\r\n  subsets: [\"latin\"],\r\n  display: 'swap',\r\n  variable: '--font-space-grotesk',\r\n});\r\n\r\nconst jetbrainsMono = JetBrains_Mono({\r\n  subsets: [\"latin\"],\r\n  display: 'swap',\r\n  variable: '--font-jetbrains-mono',\r\n});\r\n\r\nexport const metadata: Metadata = {\r\n  title: \"LinksVault - Your Personal Link Manager\",\r\n  description: \"Save, organize, and rediscover your digital content with LinkVault\",\r\n};\r\n\r\nexport default async function RootLayout({\r\n  children,\r\n}: Readonly<{\r\n  children: React.ReactNode;\r\n}>) {\r\n  const supabase = await createClient();\r\n  const { data: { user } } = await supabase.auth.getUser();\r\n\r\n  let authUser = null;\r\n  if (user) {\r\n    const [profileResult, settingsResult] = await Promise.all([\r\n      supabase.from('user_profiles').select('*').eq('id', user.id).single(),\r\n      supabase.from('user_settings').select('*').eq('user_id', user.id).single()\r\n    ]);\r\n\r\n    authUser = {\r\n      ...user,\r\n      profile: profileResult.data || undefined,\r\n      settings: settingsResult.data || undefined\r\n    };\r\n  }\r\n\r\n  return (\r\n    <html lang=\"en\" suppressHydrationWarning>\r\n      <body className={`${inter.className} ${spaceGrotesk.variable} ${jetbrainsMono.variable}`}>\r\n        <LayoutClient initialUser={authUser}>\r\n          {children}\r\n        </LayoutClient>\r\n      </body>\r\n    </html>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\login\\page.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":13,"column":22,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file app/login/page.tsx\r\n * @description Main login page with sophisticated yet minimalist design\r\n * @created 2025-01-01\r\n */\r\n\r\nimport React, { Suspense } from 'react';\r\nimport { Metadata } from 'next';\r\nimport Link from 'next/link';\r\nimport { Share2, FolderTree, DownloadCloud, Search } from 'lucide-react';\r\nimport { LoginForm } from '@/components/auth/login-form';\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'Login | LinksVault',\r\n  description: 'Sign in to your LinksVault account to organize and manage your links.',\r\n  keywords: ['login', 'sign in', 'authentication', 'link management', 'bookmark organizer'],\r\n};\r\n\r\n/**\r\n * Main login page component with hero section and authentication form\r\n * @returns {JSX.Element} Login page component\r\n */\r\nexport default function LoginPage(): React.JSX.Element {\r\n  return (\r\n    <div className=\"min-h-screen bg-white text-black font-sans selection:bg-[#FF4D00] selection:text-white overflow-hidden relative flex flex-col\">\r\n      {/* Background Grid */}\r\n      <div className=\"absolute inset-0 z-0 pointer-events-none opacity-50\" style={{\r\n        backgroundImage: `\r\n            linear-gradient(to right, rgba(0, 0, 0, 0.05) 1px, transparent 1px),\r\n            linear-gradient(to bottom, rgba(0, 0, 0, 0.05) 1px, transparent 1px)\r\n          `,\r\n        backgroundSize: '40px 40px'\r\n      }}></div>\r\n\r\n      {/* Navigation / Logo */}\r\n      <nav className=\"fixed top-0 left-0 w-full z-50 h-20 flex items-center justify-center pointer-events-none\">\r\n        <div className=\"w-full max-w-[1600px] px-6 flex items-center justify-between\">\r\n          <div className=\"flex items-center gap-4 pointer-events-auto\">\r\n            <div className=\"w-3 h-3 bg-[#FF4D00]\"></div>\r\n            <span className=\"font-display font-bold text-xl tracking-tight uppercase\">LinksVault<span className=\"text-[#FF4D00]\">.</span></span>\r\n          </div>\r\n          <Link href=\"/\" className=\"pointer-events-auto font-mono text-xs font-bold uppercase tracking-wider hover:text-[#FF4D00] transition-colors\">\r\n            Back to Home\r\n          </Link>\r\n        </div>\r\n      </nav>\r\n\r\n      <div className=\"flex-1 w-full max-w-[1600px] mx-auto grid grid-cols-1 lg:grid-cols-2 gap-0 relative z-10 px-6\">\r\n        {/* Left Column: Typography / Hero (Hidden on mobile/tablet to focus on login) */}\r\n        <div className=\"hidden lg:flex flex-col justify-center p-12 xl:p-20 border-r border-gray-100 bg-white/50 backdrop-blur-sm\">\r\n          <div className=\"max-w-xl\">\r\n            <div className=\"inline-flex items-center gap-2 border border-black px-3 py-1 rounded-full mb-8 bg-white\">\r\n              <span className=\"w-2 h-2 rounded-full bg-[#FF4D00] animate-pulse\"></span>\r\n              <span className=\"font-mono text-xs uppercase font-bold\">Secure Access</span>\r\n            </div>\r\n\r\n            <h1 className=\"font-display text-6xl xl:text-7xl font-bold leading-[0.9] tracking-tighter mb-8 uppercase\">\r\n              Enter <br />\r\n              <span className=\"text-transparent\" style={{ WebkitTextStroke: '2px black' }}>The Vault</span>\r\n            </h1>\r\n\r\n            <p className=\"font-sans text-lg text-gray-600 leading-relaxed border-l-2 border-[#FF4D00] pl-6 mb-12\">\r\n              Stop emailing yourself links. It's embarrassing.\r\n            </p>\r\n\r\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-8 font-mono text-xs text-gray-500\">\r\n              <div className=\"flex gap-4 items-start group\">\r\n                <div className=\"p-2 border border-black bg-white group-hover:bg-[#FF4D00] group-hover:text-white transition-colors duration-300\">\r\n                  <Share2 className=\"w-4 h-4\" />\r\n                </div>\r\n                <div>\r\n                  <span className=\"block text-black font-bold mb-1 uppercase tracking-wider\">Shareable Collections</span>\r\n                  <p className=\"leading-relaxed max-w-xs\">\r\n                    Turn any folder into a public link.\r\n                  </p>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"flex gap-4 items-start group\">\r\n                <div className=\"p-2 border border-black bg-white group-hover:bg-[#FF4D00] group-hover:text-white transition-colors duration-300\">\r\n                  <FolderTree className=\"w-4 h-4\" />\r\n                </div>\r\n                <div>\r\n                  <span className=\"block text-black font-bold mb-1 uppercase tracking-wider\">Infinite Nesting</span>\r\n                  <p className=\"leading-relaxed max-w-xs\">\r\n                    Nest folders until you forget where you are.\r\n                  </p>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"flex gap-4 items-start group\">\r\n                <div className=\"p-2 border border-black bg-white group-hover:bg-[#FF4D00] group-hover:text-white transition-colors duration-300\">\r\n                  <DownloadCloud className=\"w-4 h-4\" />\r\n                </div>\r\n                <div>\r\n                  <span className=\"block text-black font-bold mb-1 uppercase tracking-wider\">Auto-Fetch</span>\r\n                  <p className=\"leading-relaxed max-w-xs\">\r\n                    Paste a URL, we grab the rest.\r\n                  </p>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"flex gap-4 items-start group\">\r\n                <div className=\"p-2 border border-black bg-white group-hover:bg-[#FF4D00] group-hover:text-white transition-colors duration-300\">\r\n                  <Search className=\"w-4 h-4\" />\r\n                </div>\r\n                <div>\r\n                  <span className=\"block text-black font-bold mb-1 uppercase tracking-wider\">Semantic Search</span>\r\n                  <p className=\"leading-relaxed max-w-xs\">\r\n                    Find things by how you remember them.\r\n                  </p>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Right Column: Login Form */}\r\n        <div className=\"flex flex-col justify-center items-center p-6 sm:p-12 lg:p-20\">\r\n          <div className=\"w-full max-w-md\">\r\n            {/* Mobile Logo removed to prevent overlap with fixed header */}\r\n            <div className=\"lg:hidden mb-8\"></div>\r\n\r\n            <Suspense fallback={\r\n              <div className=\"flex items-center justify-center py-12\">\r\n                <div className=\"animate-spin-gpu rounded-full h-8 w-8 border-b-2 border-[#FF4D00]\"></div>\r\n              </div>\r\n            }>\r\n              <LoginForm />\r\n            </Suspense>\r\n\r\n            <div className=\"mt-8 text-center font-mono text-[10px] text-gray-400 uppercase\">\r\n              <p>\r\n                By accessing the system, you agree to our{' '}\r\n                <a href=\"/terms\" className=\"text-black hover:text-[#FF4D00] underline decoration-1 underline-offset-2\">Terms</a>\r\n                {' '}and{' '}\r\n                <a href=\"/privacy\" className=\"text-black hover:text-[#FF4D00] underline decoration-1 underline-offset-2\">Privacy Policy</a>\r\n              </p>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\login\\template.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":9,"column":51,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file app/login/template.tsx\r\n * @description Template component for login page transitions\r\n * @created 2025-01-01\r\n */\r\n\r\nimport React from 'react';\r\n\r\nexport default function LoginTemplate({ children }: { children: React.ReactNode }) {\r\n    return (\r\n        <div className=\"animate-in fade-in slide-in-from-bottom-4 duration-700 ease-out\">\r\n            {children}\r\n        </div>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\not-found.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":6,"column":9,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Link from \"next/link\"\r\nimport { Button } from \"@/components/ui/button\"\r\n\r\nexport default function NotFound() {\r\n    return (\r\n        <div className=\"flex h-screen w-full flex-col items-center justify-center bg-background text-foreground\">\r\n            <h1 className=\"text-9xl font-black tracking-tighter opacity-10\">404</h1>\r\n            <div className=\"absolute flex flex-col items-center gap-4\">\r\n                <h2 className=\"text-2xl font-bold md:text-4xl\">Page Not Found</h2>\r\n                <p className=\"text-muted-foreground text-center max-w-[500px]\">\r\n                    The page you are looking for doesn't exist or has been moved.\r\n                </p>\r\n                <Button asChild className=\"mt-4\">\r\n                    <Link href=\"/\">Return Home</Link>\r\n                </Button>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\page.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":33,"column":7,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file app/page.tsx\r\n * @description Root page that shows landing page for unauthenticated users and redirects authenticated users to /app\r\n * @created 2025-01-01\r\n */\r\n\r\nimport React, { useEffect } from \"react\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { useAuth } from \"@/lib/contexts/auth-context\";\r\nimport { LandingPage } from \"@/components/landing/landing-page\";\r\n\r\n/**\r\n * Root page component that handles authentication-based routing.\r\n * Shows landing page for unauthenticated users and redirects authenticated users to /app.\r\n * @returns {JSX.Element} Root page component\r\n */\r\nexport default function Home() {\r\n  const router = useRouter();\r\n  const { user, loading } = useAuth();\r\n\r\n  // Redirect authenticated users to /app\r\n  useEffect(() => {\r\n    if (!loading && user) {\r\n      router.push('/app');\r\n    }\r\n  }, [user, loading, router]);\r\n\r\n  // Show loading state while checking authentication\r\n  if (loading) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center bg-black\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin-gpu rounded-full h-8 w-8 border-b-2 border-orange-500 mx-auto mb-4\"></div>\r\n          <p className=\"text-gray-400\">Loading...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Show landing page for unauthenticated users\r\n  if (!user) {\r\n    return <LandingPage />;\r\n  }\r\n\r\n  // This should not be reached due to the redirect above, but just in case\r\n  return null;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\share\\folder\\[shareId]\\page.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":10,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { notFound } from 'next/navigation';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Card } from '@/components/ui/card';\r\nimport { ExternalLink, Briefcase, Folder as FolderIcon, Heart, Star, Bookmark, Box, Settings, Home, Globe, FileText, Calendar, Clock, Code, Database, Terminal, Cpu, Lightbulb, Image as ImageIcon, Video, Music, ShoppingCart, Map, Users, User, Shield, AlertTriangle, Info, Mail, Lock, Key, Mic, Headphones, Gamepad, Play, Tag } from 'lucide-react';\r\nimport Image from 'next/image';\r\n\r\ninterface SharedLink {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  url: string;\r\n  thumbnail: string | null;\r\n  favicon_url: string | null;\r\n  platform: string;\r\n  is_favorite: boolean;\r\n  tags: string[] | null;\r\n  created_at: string;\r\n}\r\n\r\ninterface SharedFolderData {\r\n  id: string;\r\n  name: string;\r\n  description: string | null;\r\n  color: string;\r\n  icon: string;\r\n  shareId: string;\r\n  shareCreatedAt: string;\r\n  links: SharedLink[];\r\n  createdAt: string;\r\n}\r\n\r\nasync function getSharedFolder(shareId: string): Promise<SharedFolderData | null> {\r\n  try {\r\n    // Use relative path to avoid BASE_URL dependency\r\n    const response = await fetch(`/api/share/${shareId}`, {\r\n      cache: 'no-store'\r\n    });\r\n\r\n    if (!response.ok) {\r\n      return null;\r\n    }\r\n\r\n    return response.json();\r\n  } catch (error) {\r\n    console.error('Error fetching shared folder:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Remove all debug logging from shared page\r\nconst logger = {\r\n  info: () => { },\r\n  warn: () => { },\r\n  error: () => { },\r\n  debug: () => { }\r\n};\r\n\r\nexport default function SharedFolderPage({\r\n  params\r\n}: {\r\n  params: Promise<{ shareId: string }>\r\n}) {\r\n  const { shareId } = React.use(params);\r\n  const [folderData, setFolderData] = useState<SharedFolderData | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  useEffect(() => {\r\n    const fetchData = async () => {\r\n      try {\r\n        const data = await getSharedFolder(shareId);\r\n        if (data) {\r\n          setFolderData(data);\r\n        } else {\r\n          notFound();\r\n        }\r\n      } catch (error) {\r\n        // Silent error handling to avoid debug logs\r\n        notFound();\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n  }, [shareId]);\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"min-h-screen bg-gradient-to-br from-orange-50 to-red-50 flex items-center justify-center\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin-gpu rounded-full h-12 w-12 border-b-2 border-orange-500 mx-auto\"></div>\r\n          <p className=\"mt-4 text-gray-600\">Loading shared folder...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!folderData) {\r\n    notFound();\r\n  }\r\n\r\n  const formatDate = (dateString: string) => {\r\n    return new Date(dateString).toLocaleDateString('en-US', {\r\n      year: 'numeric',\r\n      month: 'long',\r\n      day: 'numeric'\r\n    });\r\n  };\r\n\r\n  // Icon mapping for folder icons using shadcn LucideReact components\r\n  const getFolderIconComponent = (iconName: string | null | undefined) => {\r\n    if (!iconName) {\r\n      return <FolderIcon className=\"h-6 w-6\" />;\r\n    }\r\n\r\n    const iconMap: Record<string, React.ReactNode> = {\r\n      'Briefcase': <Briefcase className=\"h-6 w-6\" />,\r\n      'Folder': <FolderIcon className=\"h-6 w-6\" />,\r\n      'Bookmark': <Bookmark className=\"h-6 w-6\" />,\r\n      'Star': <Star className=\"h-6 w-6\" />,\r\n      'Heart': <Heart className=\"h-6 w-6\" />,\r\n      'Box': <Box className=\"h-6 w-6\" />,\r\n      'Settings': <Settings className=\"h-6 w-6\" />,\r\n      'User': <User className=\"h-6 w-6\" />,\r\n      'Users': <Users className=\"h-6 w-6\" />,\r\n      'Home': <Home className=\"h-6 w-6\" />,\r\n      'Globe': <Globe className=\"h-6 w-6\" />,\r\n      'FileText': <FileText className=\"h-6 w-6\" />,\r\n      'Calendar': <Calendar className=\"h-6 w-6\" />,\r\n      'Clock': <Clock className=\"h-6 w-6\" />,\r\n      'Code': <Code className=\"h-6 w-6\" />,\r\n      'Database': <Database className=\"h-6 w-6\" />,\r\n      'Terminal': <Terminal className=\"h-6 w-6\" />,\r\n      'Cpu': <Cpu className=\"h-6 w-6\" />,\r\n      'Lightbulb': <Lightbulb className=\"h-6 w-6\" />,\r\n      'Image': <ImageIcon className=\"h-6 w-6\" />,\r\n      'Video': <Video className=\"h-6 w-6\" />,\r\n      'Music': <Music className=\"h-6 w-6\" />,\r\n      'ShoppingCart': <ShoppingCart className=\"h-6 w-6\" />,\r\n      'Map': <Map className=\"h-6 w-6\" />,\r\n      'Shield': <Shield className=\"h-6 w-6\" />,\r\n      'AlertTriangle': <AlertTriangle className=\"h-6 w-6\" />,\r\n      'Info': <Info className=\"h-6 w-6\" />,\r\n      'Mail': <Mail className=\"h-6 w-6\" />,\r\n      'Lock': <Lock className=\"h-6 w-6\" />,\r\n      'Key': <Key className=\"h-6 w-6\" />,\r\n      'Mic': <Mic className=\"h-6 w-6\" />,\r\n      'Headphones': <Headphones className=\"h-6 w-6\" />,\r\n      'Gamepad': <Gamepad className=\"h-6 w-6\" />,\r\n      'Play': <Play className=\"h-6 w-6\" />,\r\n      'ShoppingBag': <ShoppingCart className=\"h-6 w-6\" />,\r\n      'DollarSign': <ShoppingCart className=\"h-6 w-6\" />\r\n    };\r\n\r\n    // Return mapped icon component or fallback to default folder icon\r\n    return iconMap[iconName] || <FolderIcon className=\"h-6 w-6\" />;\r\n  };\r\n\r\n  const getFaviconUrl = (url: string, fallback?: string) => {\r\n    try {\r\n      const urlObj = new URL(url);\r\n      return fallback || `https://www.google.com/s2/favicons?domain=${urlObj.hostname}`;\r\n    } catch {\r\n      return fallback || `https://www.google.com/s2/favicons?domain=${url}`;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-background\">\r\n      {/* Header with Minimalist Branding */}\r\n      <header className=\"border-b bg-card\">\r\n        <div className=\"max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-4\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <div className=\"flex items-center space-x-3\">\r\n              <div className=\"h-8 w-8 border-2 border-foreground rounded-lg flex items-center justify-center\">\r\n                <span className=\"text-foreground font-semibold text-sm\">L</span>\r\n              </div>\r\n              <div>\r\n                <h1 className=\"text-lg font-semibold text-foreground\">LinkVault</h1>\r\n                <p className=\"text-xs text-muted-foreground\">Your links, beautifully organized</p>\r\n              </div>\r\n            </div>\r\n\r\n            {/* CTA Buttons - Minimalist */}\r\n            <div className=\"flex space-x-2\">\r\n              <Button\r\n                asChild\r\n                variant=\"outline\"\r\n                className=\"text-sm font-medium border-muted-foreground/20\"\r\n              >\r\n                <a href=\"/signup\">Sign Up</a>\r\n              </Button>\r\n              <Button\r\n                asChild\r\n                variant=\"ghost\"\r\n                className=\"text-sm\"\r\n              >\r\n                <a href=\"/login\">Sign In</a>\r\n              </Button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </header>\r\n\r\n      {/* Shared Content */}\r\n      <main className=\"max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8\">\r\n        {/* Folder Header */}\r\n        <div className=\"text-center mb-8\">\r\n          <div className=\"flex justify-center mb-4\">\r\n            <div className=\"h-12 w-12 border-2 border-foreground rounded-lg flex items-center justify-center\">\r\n              <div className=\"text-foreground\">\r\n                {getFolderIconComponent(folderData.icon)}\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <h1 className=\"text-2xl font-bold text-foreground mb-2\">{folderData.name}</h1>\r\n          {folderData.description && (\r\n            <p className=\"text-sm text-muted-foreground mb-4\">{folderData.description}</p>\r\n          )}\r\n          <div className=\"inline-flex items-center space-x-2 text-sm text-muted-foreground\">\r\n            <span>{folderData.links.length} {folderData.links.length === 1 ? 'link' : 'links'}</span>\r\n            <span>ΓÇó</span>\r\n            <span>Shared on {formatDate(folderData.shareCreatedAt)}</span>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Links Grid */}\r\n        {folderData.links.length > 0 ? (\r\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-8\">\r\n            {folderData.links.map((link) => (\r\n              <Card\r\n                key={link.id}\r\n                className=\"group cursor-pointer hover:shadow-md transition-all duration-200 border-muted-foreground/20\"\r\n                onClick={() => window.open(link.url, '_blank')}\r\n              >\r\n                <div className=\"relative h-32 bg-muted rounded-t-md overflow-hidden\">\r\n                  {link.thumbnail ? (\r\n                    <Image\r\n                      src={link.thumbnail}\r\n                      alt=\"\"\r\n                      fill\r\n                      className=\"object-cover group-hover:scale-105 transition-transform duration-200\"\r\n                    />\r\n                  ) : (\r\n                    <div className=\"w-full h-full flex items-center justify-center\">\r\n                      <ExternalLink className=\"h-8 w-8 text-muted-foreground\" />\r\n                    </div>\r\n                  )}\r\n                  <div className=\"absolute bottom-2 right-2\">\r\n                    <ExternalLink className=\"h-3 w-3 text-white/80\" />\r\n                  </div>\r\n                </div>\r\n\r\n                <div className=\"p-3\">\r\n                  <h3 className=\"font-medium text-foreground line-clamp-2 mb-1 text-sm\">\r\n                    {link.title}\r\n                  </h3>\r\n                  <p className=\"text-xs text-muted-foreground line-clamp-2 mb-2\">\r\n                    {link.description}\r\n                  </p>\r\n\r\n                  {/* Link Footer */}\r\n                  <div className=\"flex items-center justify-between text-xs text-muted-foreground\">\r\n                    <div className=\"flex items-center space-x-1\">\r\n                      {link.favicon_url && (\r\n                        <Image\r\n                          src={link.favicon_url}\r\n                          alt=\"\"\r\n                          width={10}\r\n                          height={10}\r\n                          className=\"rounded-sm\"\r\n                        />\r\n                      )}\r\n                      <span className=\"truncate max-w-[100px] font-mono\">\r\n                        {new URL(link.url).hostname}\r\n                      </span>\r\n                    </div>\r\n                    <div className=\"flex items-center space-x-1\">\r\n                      {link.is_favorite && (\r\n                        <Heart className=\"h-2 w-2 text-muted-foreground fill-muted-foreground\" />\r\n                      )}\r\n                      {link.tags && link.tags.length > 0 && (\r\n                        <div className=\"flex space-x-0.5\">\r\n                          {link.tags.slice(0, 1).map((tag) => (\r\n                            <div key={tag} className=\"flex items-center\">\r\n                              <Tag className=\"h-2 w-2 text-muted-foreground\" />\r\n                              <span className=\"ml-0.5 text-[10px] truncate max-w-[40px]\">{tag}</span>\r\n                            </div>\r\n                          ))}\r\n                          {link.tags.length > 1 && (\r\n                            <span className=\"text-muted-foreground text-[10px]\">\r\n                              +{link.tags.length - 1}\r\n                            </span>\r\n                          )}\r\n                        </div>\r\n                      )}\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </Card>\r\n            ))}\r\n          </div>\r\n        ) : (\r\n          <div className=\"text-center py-12\">\r\n            <div className=\"text-foreground mb-4\">\r\n              <span className=\"text-4xl\">≡ƒô¡</span>\r\n            </div>\r\n            <h2 className=\"text-lg font-semibold text-foreground mb-2\">No links yet</h2>\r\n            <p className=\"text-sm text-muted-foreground mb-6\">This folder is currently empty.</p>\r\n          </div>\r\n        )}\r\n\r\n        {/* Footer CTA */}\r\n        <div className=\"text-center border-t pt-8\">\r\n          <h3 className=\"text-lg font-semibold text-foreground mb-4\">\r\n            Love this collection?\r\n          </h3>\r\n          <p className=\"text-sm text-muted-foreground mb-6 max-w-md mx-auto\">\r\n            Join thousands of users who organize their favorite links with LinkVault.\r\n            Create your own collections, share them with the world, and never lose a great link again.\r\n          </p>\r\n          <div className=\"flex flex-col sm:flex-row gap-2 justify-center\">\r\n            <Button\r\n              asChild\r\n              className=\"text-sm font-medium\"\r\n            >\r\n              <a href=\"/signup\">Get Started for Free</a>\r\n            </Button>\r\n            <Button\r\n              asChild\r\n              variant=\"outline\"\r\n              className=\"text-sm font-medium border-muted-foreground/20\"\r\n            >\r\n              <a href=\"/login\">Sign In</a>\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </main>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\shared\\[shareId]\\page.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":15,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { notFound, redirect } from 'next/navigation';\r\nimport { createClient } from '@/lib/supabase/server';\r\nimport { createAdminClient } from '@/lib/supabase/admin';\r\nimport { LinkCard } from '@/components/links/link-card';\r\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Link as LinkIcon, Clock, Lock, ArrowLeft, User } from 'lucide-react';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport Link from 'next/link';\r\n\r\n// Force dynamic rendering to prevent caching issues with shared folders\r\nexport const dynamic = 'force-dynamic';\r\n\r\ninterface SharedFolderPageProps {\r\n  params: Promise<{\r\n    shareId: string;\r\n  }>;\r\n}\r\n\r\nexport default async function SharedFolderPage({ params }: SharedFolderPageProps) {\r\n  // Next.js 15 parameter handling\r\n  const { shareId } = await params;\r\n\r\n  // Critical configuration check\r\n  if (!process.env.SUPABASE_SERVICE_ROLE_KEY) {\r\n    logger.error('CRITICAL: SUPABASE_SERVICE_ROLE_KEY is not defined. Shared folders require this key to bypass RLS.');\r\n    if (process.env.NODE_ENV === 'development') {\r\n      return (\r\n        <div className=\"min-h-screen flex items-center justify-center bg-red-50 p-4\">\r\n          <div className=\"max-w-md w-full bg-white p-6 rounded-lg shadow-lg border border-red-200\">\r\n            <h1 className=\"text-xl font-bold text-red-700 mb-2\">Configuration Error</h1>\r\n            <p className=\"text-red-600 mb-4\">\r\n              <code>SUPABASE_SERVICE_ROLE_KEY</code> is missing in your environment variables.\r\n            </p>\r\n            <p className=\"text-sm text-gray-600\">\r\n              Shared folders require the Service Role Key to allow public access to private data.\r\n              Please add this key to your <code>.env.local</code> file.\r\n            </p>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n    // In production, we still have to 404 or 500, but the log will be there.\r\n    notFound();\r\n  }\r\n\r\n  try {\r\n    const supabase = await createClient();\r\n    const { data: { user } } = await supabase.auth.getUser();\r\n\r\n    // Use admin client for fetching share data to ensure access\r\n    // We control access via the user check below\r\n    const adminSupabase = createAdminClient();\r\n\r\n    // Get headers for analytics\r\n    const headersList = await import('next/headers');\r\n    const headers = await headersList.headers();\r\n    const clientIP = headers.get('x-forwarded-for') || headers.get('x-real-ip') || 'unknown';\r\n    const userAgent = headers.get('user-agent') || 'unknown';\r\n    const referrer = headers.get('referer') || null;\r\n\r\n    // Get share information with folder and links using Admin Client\r\n    logger.info('DEBUG: Fetching share with ID:', { shareId, hasServiceKey: !!process.env.SUPABASE_SERVICE_ROLE_KEY });\r\n\r\n    // SIMPLIFIED QUERY: Fetch share first, then folder details separately if needed\r\n    // This helps isolate if the join is causing the null result\r\n    const { data: share, error: shareError } = await adminSupabase\r\n      .from('folder_shares')\r\n      .select('*')\r\n      .eq('share_id', shareId.toString())\r\n      .single();\r\n\r\n    if (shareError) {\r\n      logger.error('DEBUG: Share fetch error (simple):', shareError);\r\n    }\r\n\r\n    if (!share) {\r\n      logger.warn('DEBUG: Share not found (simple query)');\r\n      notFound();\r\n    }\r\n\r\n    // Now fetch the folder details manually since we have the share\r\n    // Renamed to fetchedFolder to avoid collision with later variable\r\n    const { data: fetchedFolder, error: folderError } = await adminSupabase\r\n      .from('folders')\r\n      .select(`\r\n        id,\r\n        name,\r\n        icon_name,\r\n        color,\r\n        description,\r\n        user_id,\r\n        links (\r\n          id,\r\n          url,\r\n          title,\r\n          description:metadata->>description,\r\n          image:metadata->>image,\r\n          created_at\r\n        )\r\n      `)\r\n      .eq('id', share.folder_id)\r\n      .single();\r\n\r\n    if (folderError || !fetchedFolder) {\r\n      logger.error('DEBUG: Folder fetch error:', folderError);\r\n      notFound();\r\n    }\r\n\r\n    // Reconstruct the object structure expected by the rest of the component\r\n    const finalShare = {\r\n      ...share,\r\n      folders: fetchedFolder\r\n    };\r\n\r\n    // Fetch sharer profile\r\n    const { data: sharerProfile } = await adminSupabase\r\n      .from('profiles')\r\n      .select('full_name, username')\r\n      .eq('id', finalShare.user_id)\r\n      .single();\r\n\r\n    const sharerName = sharerProfile?.full_name || sharerProfile?.username || 'A LinkVault User';\r\n\r\n    // Check if share has expired (1 hour limit)\r\n    const createdAt = new Date(finalShare.created_at);\r\n    const now = new Date();\r\n    const hoursElapsed = (now.getTime() - createdAt.getTime()) / (1000 * 60 * 60);\r\n\r\n    if (hoursElapsed > 1) {\r\n      logger.warn('Shared folder expired:', { shareId, hoursElapsed });\r\n\r\n      return (\r\n        <div className=\"min-h-screen bg-background flex items-center justify-center p-4\">\r\n          <Card className=\"max-w-md w-full\">\r\n            <CardContent className=\"pt-6 text-center\">\r\n              <div className=\"mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-orange-100 mb-4\">\r\n                <Clock className=\"h-6 w-6 text-orange-600\" />\r\n              </div>\r\n              <h1 className=\"text-2xl font-bold text-foreground mb-2\">\r\n                Share Expired\r\n              </h1>\r\n              <p className=\"text-muted-foreground mb-6\">\r\n                This shared folder link has expired after 1 hour for security reasons.\r\n              </p>\r\n              <Button asChild className=\"w-full\">\r\n                <Link href=\"/app\">Return to LinkVault</Link>\r\n              </Button>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // REQUIRE LOGIN: If user is not logged in, show login prompt\r\n    if (!user) {\r\n      return (\r\n        <div className=\"min-h-screen bg-gray-50/50 flex items-center justify-center p-4\">\r\n          <Card className=\"max-w-md w-full shadow-lg border-orange-100/50\">\r\n            <CardHeader className=\"text-center pb-2\">\r\n              <div className=\"mx-auto w-16 h-16 bg-orange-100 rounded-full flex items-center justify-center mb-4 shadow-inner\">\r\n                <Lock className=\"w-8 h-8 text-orange-600\" />\r\n              </div>\r\n              <CardTitle className=\"text-2xl\">Login to View Folder</CardTitle>\r\n              <CardDescription className=\"text-base mt-2\">\r\n                <span className=\"font-semibold text-foreground\">{sharerName}</span> has shared the folder <span className=\"font-semibold text-foreground\">\"{finalShare.folders.name}\"</span> with you.\r\n              </CardDescription>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-4 pt-4\">\r\n              <div className=\"bg-muted/50 p-4 rounded-lg text-sm text-center mb-4\">\r\n                Please log in or create an account to view this shared content securely.\r\n              </div>\r\n              <Button className=\"w-full h-11 text-base\" asChild>\r\n                <Link href={`/login?next=/shared/${shareId}`}>\r\n                  Log In to View\r\n                </Link>\r\n              </Button>\r\n              <div className=\"text-center text-sm text-muted-foreground pt-2\">\r\n                New to LinkVault?{' '}\r\n                <Link href={`/login?tab=signup&next=/shared/${shareId}`} className=\"text-primary hover:underline font-medium\">\r\n                  Create an account\r\n                </Link>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // Track view analytics (non-blocking)\r\n    try {\r\n      // Track view analytics (fire and forget)\r\n      // Use admin client for analytics insert as well to ensure it works for anon users\r\n      await adminSupabase\r\n        .from('share_analytics')\r\n        .insert({\r\n          share_id: finalShare.id,\r\n          viewer_ip: clientIP,\r\n          user_agent: userAgent,\r\n          referral_source: referrer,\r\n          viewer_id: user.id // Track who viewed it\r\n        });\r\n\r\n      // Increment view count\r\n      await adminSupabase.rpc('increment_share_view_count', { share_id_param: finalShare.id });\r\n    } catch (err) {\r\n      logger.warn('Analytics tracking failed:', err);\r\n    }\r\n\r\n    const folder = finalShare.folders;\r\n    const links = folder.links || [];\r\n\r\n    return (\r\n      <div className=\"min-h-screen bg-background\">\r\n        {/* Header Section */}\r\n        <div className=\"border-b bg-card sticky top-0 z-10 shadow-sm\">\r\n          <div className=\"container mx-auto py-4 px-4 sm:px-6 lg:px-8\">\r\n            <div className=\"flex flex-col sm:flex-row sm:items-center justify-between gap-4\">\r\n\r\n              {/* Left: Title & Info */}\r\n              <div className=\"flex items-start gap-4\">\r\n                <div className=\"p-2 bg-primary/10 rounded-lg hidden sm:block\">\r\n                  <LinkIcon className=\"h-6 w-6 text-primary\" />\r\n                </div>\r\n                <div>\r\n                  <div className=\"flex items-center gap-2 flex-wrap\">\r\n                    <h1 className=\"text-2xl font-bold text-foreground\">\r\n                      {folder.name}\r\n                    </h1>\r\n                    <Badge variant=\"secondary\" className=\"bg-orange-100 text-orange-800 hover:bg-orange-200\">\r\n                      Shared\r\n                    </Badge>\r\n                  </div>\r\n\r\n                  <div className=\"flex items-center gap-2 text-sm text-muted-foreground mt-1\">\r\n                    <User className=\"h-3.5 w-3.5\" />\r\n                    <span>Shared by <span className=\"font-medium text-foreground\">{sharerName}</span></span>\r\n                    <span>ΓÇó</span>\r\n                    <span>{links.length} {links.length === 1 ? 'link' : 'links'}</span>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* Right: Actions */}\r\n              <div className=\"flex items-center gap-3\">\r\n                <Button variant=\"outline\" asChild className=\"gap-2\">\r\n                  <Link href=\"/app\">\r\n                    <ArrowLeft className=\"h-4 w-4\" />\r\n                    Back to App\r\n                  </Link>\r\n                </Button>\r\n              </div>\r\n            </div>\r\n\r\n            {folder.description && (\r\n              <p className=\"text-muted-foreground mt-4 text-sm max-w-3xl\">\r\n                {folder.description}\r\n              </p>\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        {/* Links Grid */}\r\n        <div className=\"container mx-auto py-8 px-4 sm:px-6 lg:px-8\">\r\n          {links.length === 0 ? (\r\n            <div className=\"text-center py-16 bg-card/50 rounded-xl border border-dashed\">\r\n              <div className=\"mx-auto w-12 h-12 bg-muted rounded-full flex items-center justify-center mb-4\">\r\n                <LinkIcon className=\"h-6 w-6 text-muted-foreground\" />\r\n              </div>\r\n              <h3 className=\"text-lg font-medium mb-1\">No links yet</h3>\r\n              <p className=\"text-sm text-muted-foreground\">This shared folder is currently empty.</p>\r\n            </div>\r\n          ) : (\r\n            <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6\">\r\n              {links.map((link: any) => (\r\n                <LinkCard\r\n                  key={link.id}\r\n                  link={{\r\n                    id: link.id,\r\n                    url: link.url,\r\n                    title: link.title || 'Untitled',\r\n                    description: link.description || '',\r\n                    thumbnail: link.image || '',\r\n                    folderId: folder.id,\r\n                    isFavorite: false,\r\n                    createdAt: link.created_at,\r\n                    updatedAt: link.created_at,\r\n                    platform: 'other',\r\n                    deletedAt: null,\r\n                    userId: share.user_id,\r\n                    syncedAt: link.created_at,\r\n                  }}\r\n                  isInTrash={false}\r\n                  isSelected={false}\r\n                  onToggleSelect={() => { }}\r\n                  isSelectionModeActive={false}\r\n                  // Disable actions for shared view\r\n                  showActions={false}\r\n                />\r\n              ))}\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n    );\r\n\r\n  } catch (error) {\r\n    logger.error('Error loading shared folder:', error);\r\n    notFound();\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\app\\signup\\page.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":16,"column":37,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file app/signup/page.tsx\r\n * @description Signup page that redirects to login page with signup tab active\r\n * @created 2025-01-01\r\n */\r\n\r\n'use client';\r\n\r\nimport React, { useEffect } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\n\r\n/**\r\n * Signup page component that redirects to login with signup tab\r\n * @returns {JSX.Element} Signup page component\r\n */\r\nexport default function SignupPage(): React.JSX.Element {\r\n  const router = useRouter();\r\n\r\n  useEffect(() => {\r\n    // Redirect to login page with signup tab active\r\n    router.replace('/login?tab=signup');\r\n  }, [router]);\r\n\r\n  return (\r\n    <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 via-white to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900\">\r\n      <div className=\"text-center\">\r\n        <div className=\"animate-spin-gpu rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4\"></div>\r\n        <p className=\"text-gray-600 dark:text-gray-400\">Redirecting to signup...</p>\r\n      </div>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\auth\\login-form.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token {","line":22,"column":13,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/auth/login-form.tsx\r\n * @description Main login form component with email/password authentication\r\n * @created 2025-01-01\r\n */\r\n\r\n'use client';\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport { logger } from \"@/lib/utils/logger\";\r\nimport { useRouter, useSearchParams } from 'next/navigation';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\r\nimport { Alert, AlertDescription } from '@/components/ui/alert';\r\nimport { useAuth } from '@/lib/contexts/auth-context';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { Eye, EyeOff, Mail, Lock, User, AlertCircle, Loader2, CheckCircle } from 'lucide-react';\r\nimport type { SignInData, SignUpData } from '@/lib/types/auth';\r\nimport { AUTH_CONSTANTS, AUTH_ERROR_MESSAGES } from '@/constants/auth.constants';\r\n\r\ninterface FormErrors {\r\n  email?: string;\r\n  password?: string;\r\n  confirmPassword?: string;\r\n  displayName?: string;\r\n  general?: string;\r\n}\r\n\r\n/**\r\n * Main login form component with sign in and sign up options\r\n * @returns {JSX.Element} Login form component\r\n */\r\nexport function LoginForm(): React.JSX.Element {\r\n  const router = useRouter();\r\n  const searchParams = useSearchParams();\r\n  const { signIn, signUp, error, loading, clearError, user } = useAuth();\r\n  const { toast } = useToast();\r\n\r\n  // Redirect if already logged in\r\n  useEffect(() => {\r\n    if (!loading && user) {\r\n      const redirectTo = searchParams?.get('redirectTo') || '/app';\r\n      router.replace(redirectTo);\r\n    }\r\n  }, [user, loading, router, searchParams]);\r\n\r\n  // Form state\r\n  const [activeTab, setActiveTab] = useState<'signin' | 'signup'>('signin');\r\n  const [isSigningIn, setIsSigningIn] = useState(false);\r\n  const [isSigningUp, setIsSigningUp] = useState(false);\r\n  const [signInError, setSignInError] = useState<string | null>(null);\r\n\r\n  // Handle URL tab parameter\r\n  useEffect(() => {\r\n    try {\r\n      const tab = searchParams?.get('tab');\r\n      if (tab === 'signup') {\r\n        setActiveTab('signup');\r\n      }\r\n\r\n      // Show message if session expired\r\n      const expired = searchParams?.get('expired');\r\n      if (expired === 'true') {\r\n        toast({\r\n          title: \"Session expired\",\r\n          description: \"Please sign in again\",\r\n          variant: \"destructive\",\r\n        });\r\n        // Remove expired param from URL\r\n        router.replace('/login');\r\n      }\r\n    } catch (error) {\r\n      // Handle search params error gracefully\r\n      logger.warn('Error reading search params:', error);\r\n    }\r\n  }, [searchParams, router, toast]);\r\n  const [showPassword, setShowPassword] = useState(false);\r\n  const [showConfirmPassword, setShowConfirmPassword] = useState(false);\r\n  const [formErrors, setFormErrors] = useState<FormErrors>({});\r\n\r\n  // Sign in form data\r\n  const [signInData, setSignInData] = useState<SignInData>({\r\n    email: '',\r\n    password: '',\r\n  });\r\n\r\n  // Sign up form data\r\n  const [signUpData, setSignUpData] = useState<SignUpData>({\r\n    email: '',\r\n    password: '',\r\n    displayName: '',\r\n  });\r\n  const [confirmPassword, setConfirmPassword] = useState('');\r\n\r\n  /**\r\n   * Clear errors when user starts typing\r\n   */\r\n  const handleSignInEmailChange = (value: string) => {\r\n    setSignInData({ ...signInData, email: value });\r\n    if (formErrors.email || formErrors.general) {\r\n      setFormErrors({ ...formErrors, email: undefined, general: undefined });\r\n    }\r\n  };\r\n\r\n  const handleSignInPasswordChange = (value: string) => {\r\n    setSignInData({ ...signInData, password: value });\r\n    if (formErrors.password || formErrors.general) {\r\n      setFormErrors({ ...formErrors, password: undefined, general: undefined });\r\n    }\r\n  };\r\n\r\n  const handleSignUpEmailChange = (value: string) => {\r\n    setSignUpData({ ...signUpData, email: value });\r\n    if (formErrors.email || formErrors.general) {\r\n      setFormErrors({ ...formErrors, email: undefined, general: undefined });\r\n    }\r\n  };\r\n\r\n  const handleSignUpPasswordChange = (value: string) => {\r\n    setSignUpData({ ...signUpData, password: value });\r\n    if (formErrors.password || formErrors.general) {\r\n      setFormErrors({ ...formErrors, password: undefined, general: undefined });\r\n    }\r\n  };\r\n\r\n  const handleSignUpNameChange = (value: string) => {\r\n    setSignUpData({ ...signUpData, displayName: value });\r\n    if (formErrors.displayName || formErrors.general) {\r\n      setFormErrors({ ...formErrors, displayName: undefined, general: undefined });\r\n    }\r\n  };\r\n\r\n  const handleConfirmPasswordChange = (value: string) => {\r\n    setConfirmPassword(value);\r\n    if (formErrors.confirmPassword || formErrors.general) {\r\n      setFormErrors({ ...formErrors, confirmPassword: undefined, general: undefined });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validates email format\r\n   * @param {string} email - Email to validate\r\n   * @returns {boolean} Whether email is valid\r\n   */\r\n  const isValidEmail = (email: string): boolean => {\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return emailRegex.test(email);\r\n  };\r\n\r\n  /**\r\n   * Validates password strength\r\n   * @param {string} password - Password to validate\r\n   * @returns {boolean} Whether password meets requirements\r\n   */\r\n  const isValidPassword = (password: string): boolean => {\r\n    return password.length >= 8;\r\n  };\r\n\r\n  /**\r\n   * Validates sign in form\r\n   * @returns {boolean} Whether form is valid\r\n   */\r\n  const validateSignInForm = (): boolean => {\r\n    const errors: FormErrors = {};\r\n\r\n    if (!signInData.email) {\r\n      errors.email = 'Email is required';\r\n    } else if (!isValidEmail(signInData.email)) {\r\n      errors.email = 'Please enter a valid email address';\r\n    }\r\n\r\n    if (!signInData.password) {\r\n      errors.password = 'Password is required';\r\n    }\r\n\r\n    setFormErrors(errors);\r\n    return Object.keys(errors).length === 0;\r\n  };\r\n\r\n  /**\r\n   * Validates sign up form\r\n   * @returns {boolean} Whether form is valid\r\n   */\r\n  const validateSignUpForm = (): boolean => {\r\n    const errors: FormErrors = {};\r\n\r\n    if (!signUpData.email) {\r\n      errors.email = 'Email is required';\r\n    } else if (!isValidEmail(signUpData.email)) {\r\n      errors.email = 'Please enter a valid email address';\r\n    }\r\n\r\n    if (!signUpData.password) {\r\n      errors.password = 'Password is required';\r\n    } else if (!isValidPassword(signUpData.password)) {\r\n      errors.password = 'Password must be at least 8 characters long';\r\n    }\r\n\r\n    if (!confirmPassword) {\r\n      errors.confirmPassword = 'Please confirm your password';\r\n    } else if (signUpData.password !== confirmPassword) {\r\n      errors.confirmPassword = 'Passwords do not match';\r\n    }\r\n\r\n    if (!signUpData.displayName?.trim()) {\r\n      errors.displayName = 'Display name is required';\r\n    }\r\n\r\n    setFormErrors(errors);\r\n    return Object.keys(errors).length === 0;\r\n  };\r\n\r\n  /**\r\n   * Handles sign in form submission with immediate redirect\r\n   * @param {React.FormEvent} e - Form event\r\n   */\r\n  const handleSignIn = async (e: React.FormEvent): Promise<void> => {\r\n    e.preventDefault();\r\n    setFormErrors({});\r\n\r\n    if (!validateSignInForm()) return;\r\n\r\n    // Prevent double submission\r\n    if (isSigningIn) return;\r\n\r\n    try {\r\n      setIsSigningIn(true);\r\n\r\n      // Check if offline\r\n      if (typeof navigator !== 'undefined' && !navigator.onLine) {\r\n        setFormErrors({\r\n          general: 'You are currently offline. Please check your internet connection and try again.',\r\n        });\r\n        setIsSigningIn(false);\r\n        return;\r\n      }\r\n\r\n      const { error } = await signIn(signInData);\r\n\r\n      if (!error) {\r\n        // Clear form after successful sign in\r\n        setSignInData({ email: '', password: '' });\r\n\r\n        // Redirect immediately - the AuthProvider will handle session setup\r\n        router.push('/app');\r\n      } else {\r\n        // Enhanced error messages\r\n        let errorMessage = error.message || AUTH_ERROR_MESSAGES.UNEXPECTED_ERROR;\r\n\r\n        // User-friendly error messages\r\n        if (error.message?.includes('Invalid login credentials') ||\r\n          error.message?.includes('Invalid email or password')) {\r\n          errorMessage = AUTH_ERROR_MESSAGES.INVALID_CREDENTIALS;\r\n        } else if (error.message?.includes('Email not confirmed')) {\r\n          errorMessage = AUTH_ERROR_MESSAGES.EMAIL_NOT_CONFIRMED;\r\n        } else if (error.message?.includes('Too many requests')) {\r\n          errorMessage = AUTH_ERROR_MESSAGES.TOO_MANY_REQUESTS;\r\n        } else if (error.message?.includes('network') || error.message?.includes('fetch')) {\r\n          errorMessage = AUTH_ERROR_MESSAGES.NETWORK_ERROR;\r\n        }\r\n\r\n        setFormErrors({\r\n          general: errorMessage,\r\n        });\r\n        setIsSigningIn(false);\r\n      }\r\n    } catch (err) {\r\n      logger.error('Sign in error:', err);\r\n      setFormErrors({\r\n        general: 'An unexpected error occurred. Please try again.',\r\n      });\r\n      setIsSigningIn(false);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Handles sign up form submission with better error handling\r\n   * @param {React.FormEvent} e - Form event\r\n   */\r\n  const handleSignUp = async (e: React.FormEvent): Promise<void> => {\r\n    e.preventDefault();\r\n    setFormErrors({});\r\n\r\n    if (!validateSignUpForm()) return;\r\n\r\n    // Prevent double submission\r\n    if (isSigningUp) return;\r\n\r\n    try {\r\n      setIsSigningUp(true);\r\n\r\n      // Check if offline\r\n      if (typeof navigator !== 'undefined' && !navigator.onLine) {\r\n        setFormErrors({\r\n          general: 'You are currently offline. Please check your internet connection and try again.',\r\n        });\r\n        setIsSigningUp(false);\r\n        return;\r\n      }\r\n\r\n      const { error } = await signUp(signUpData);\r\n\r\n      if (!error) {\r\n        // Show email verification notification\r\n        toast({\r\n          title: \"Check your email\",\r\n          description: \"Verification link sent\",\r\n          variant: \"success\",\r\n          icon: <CheckCircle className=\"size-4\" />,\r\n        });\r\n\r\n        // Switch to sign in tab\r\n        setActiveTab('signin');\r\n\r\n        // Clear the signup form\r\n        setSignUpData({ email: '', password: '', displayName: '' });\r\n        setConfirmPassword('');\r\n      } else {\r\n        // Enhanced error messages\r\n        let errorMessage = error.message || 'An unexpected error occurred. Please try again.';\r\n\r\n        // User-friendly error messages\r\n        if (error.message?.includes('already registered') || error.message?.includes('already exists')) {\r\n          errorMessage = 'An account with this email already exists. Please sign in instead.';\r\n        } else if (error.message?.includes('password')) {\r\n          errorMessage = 'Password does not meet requirements. Please use a stronger password (minimum 10 characters).';\r\n        } else if (error.message?.includes('network') || error.message?.includes('fetch')) {\r\n          errorMessage = 'Network error. Please check your internet connection and try again.';\r\n        }\r\n\r\n        setFormErrors({\r\n          general: errorMessage,\r\n        });\r\n      }\r\n    } catch (err) {\r\n      logger.error('Sign up error:', err);\r\n      setFormErrors({\r\n        general: 'An unexpected error occurred. Please try again.',\r\n      });\r\n    } finally {\r\n      setIsSigningUp(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Card className=\"w-full max-w-md mx-auto border border-black bg-white shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] rounded-none transition-all duration-300\">\r\n        <CardHeader className=\"text-center pb-6 border-b border-gray-100\">\r\n          <CardTitle className=\"text-2xl sm:text-3xl font-display font-bold text-black mb-2 uppercase tracking-tight\">\r\n            {activeTab === 'signin' ? 'Welcome Back' : 'Create Account'}\r\n          </CardTitle>\r\n          <CardDescription className=\"text-gray-500 font-mono text-xs uppercase tracking-wider\">\r\n            {activeTab === 'signin' ? '// Authenticate to continue' : '// Join the system'}\r\n          </CardDescription>\r\n        </CardHeader>\r\n\r\n        <CardContent className=\"px-6 sm:px-8 pb-6\">\r\n          {error && (\r\n            <Alert className=\"mb-5 border-2 border-red-500/50 bg-red-500/10 backdrop-blur-sm\">\r\n              <AlertCircle className=\"size-4 text-red-400\" />\r\n              <AlertDescription className=\"text-red-200 text-sm\">\r\n                {error.message}\r\n              </AlertDescription>\r\n            </Alert>\r\n          )}\r\n\r\n          <Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as 'signin' | 'signup')}>\r\n            <TabsList className=\"grid w-full grid-cols-2 mb-8 h-12 bg-gray-100 p-1 rounded-none border border-gray-200\">\r\n              <TabsTrigger value=\"signin\" className=\"text-xs font-mono font-bold uppercase data-[state=active]:bg-white data-[state=active]:text-black data-[state=active]:shadow-sm data-[state=active]:border data-[state=active]:border-black rounded-none transition-all\">Sign In</TabsTrigger>\r\n              <TabsTrigger value=\"signup\" className=\"text-xs font-mono font-bold uppercase data-[state=active]:bg-white data-[state=active]:text-black data-[state=active]:shadow-sm data-[state=active]:border data-[state=active]:border-black rounded-none transition-all\">Sign Up</TabsTrigger>\r\n            </TabsList>\r\n\r\n            <div className=\"relative overflow-hidden\">\r\n              <TabsContent value=\"signin\" className=\"mt-0 focus-visible:ring-0 focus-visible:ring-offset-0\">\r\n                <div key=\"signin\" className=\"animate-in fade-in slide-in-from-right-8 duration-500 ease-out fill-mode-both\">\r\n                  <form onSubmit={handleSignIn} className=\"space-y-5\">\r\n                    <div className=\"space-y-2.5\">\r\n                      <Label htmlFor=\"signin-email\" className=\"text-xs font-mono font-bold uppercase text-gray-500\">\r\n                        Email Address\r\n                      </Label>\r\n                      <div className=\"relative\">\r\n                        <Mail className=\"absolute left-3.5 top-1/2 transform -translate-y-1/2 size-4 text-gray-400 pointer-events-none\" />\r\n                        <Input\r\n                          id=\"signin-email\"\r\n                          type=\"email\"\r\n                          placeholder=\"Enter your email\"\r\n                          value={signInData.email}\r\n                          onChange={(e) => handleSignInEmailChange(e.target.value)}\r\n                          className={`pl-10 pr-4 h-12 bg-gray-50 border border-gray-300 text-black placeholder:text-gray-400 focus:bg-white focus:border-black focus:ring-0 rounded-none font-mono text-sm transition-all duration-200 hover:border-gray-400 ${formErrors.email\r\n                            ? 'border-red-500 focus:border-red-500'\r\n                            : ''\r\n                            }`}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          autoComplete=\"email\"\r\n                          aria-describedby={formErrors.email ? 'signin-email-error' : undefined}\r\n                        />\r\n                      </div>\r\n                      {formErrors.email && (\r\n                        <p id=\"signin-email-error\" className=\"text-sm text-red-300 mt-1\">\r\n                          {formErrors.email}\r\n                        </p>\r\n                      )}\r\n                    </div>\r\n\r\n                    <div className=\"space-y-2.5\">\r\n                      <Label htmlFor=\"signin-password\" className=\"text-xs font-mono font-bold uppercase text-gray-500\">\r\n                        Password\r\n                      </Label>\r\n                      <div className=\"relative\">\r\n                        <Lock className=\"absolute left-3.5 top-1/2 transform -translate-y-1/2 size-4 text-gray-400 pointer-events-none\" />\r\n                        <Input\r\n                          id=\"signin-password\"\r\n                          type={showPassword ? 'text' : 'password'}\r\n                          placeholder=\"Enter your password\"\r\n                          value={signInData.password}\r\n                          onChange={(e) => handleSignInPasswordChange(e.target.value)}\r\n                          className={`pl-10 pr-12 h-12 bg-gray-50 border border-gray-300 text-black placeholder:text-gray-400 focus:bg-white focus:border-black focus:ring-0 rounded-none font-mono text-sm transition-all duration-200 hover:border-gray-400 ${formErrors.password\r\n                            ? 'border-red-500 focus:border-red-500'\r\n                            : ''\r\n                            }`}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          autoComplete=\"current-password\"\r\n                          aria-describedby={formErrors.password ? 'signin-password-error' : undefined}\r\n                        />\r\n                        <Button\r\n                          type=\"button\"\r\n                          variant=\"ghost\"\r\n                          size=\"icon\"\r\n                          className=\"absolute right-1 top-1/2 transform -translate-y-1/2 h-9 w-9 p-0 text-gray-400 hover:text-black hover:bg-transparent\"\r\n                          onClick={() => setShowPassword(!showPassword)}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          aria-label={showPassword ? 'Hide password' : 'Show password'}\r\n                        >\r\n                          {showPassword ? <EyeOff className=\"size-4\" /> : <Eye className=\"size-4\" />}\r\n                        </Button>\r\n                      </div>\r\n                      {formErrors.password && (\r\n                        <p id=\"signin-password-error\" className=\"text-sm text-red-300 mt-1\">\r\n                          {formErrors.password}\r\n                        </p>\r\n                      )}\r\n                    </div>\r\n\r\n                    <Button\r\n                      type=\"submit\"\r\n                      className=\"w-full h-12 bg-[#FF4D00] hover:bg-black hover:text-white text-white font-mono font-bold uppercase tracking-widest text-sm rounded-none transition-all duration-300 shadow-sm hover:shadow-md active:transform active:scale-[0.98]\"\r\n                      disabled={isSigningIn}\r\n                    >\r\n                      {isSigningIn ? (\r\n                        <>\r\n                          <Loader2 className=\"mr-2 size-4 animate-spin-gpu\" />\r\n                          Logging in...\r\n                        </>\r\n                      ) : (\r\n                        'Initialize Session'\r\n                      )}\r\n                    </Button>\r\n                  </form>\r\n                </div>\r\n              </TabsContent>\r\n\r\n              <TabsContent value=\"signup\" className=\"mt-0 focus-visible:ring-0 focus-visible:ring-offset-0\">\r\n                <div key=\"signup\" className=\"animate-in fade-in slide-in-from-right-8 duration-500 ease-out fill-mode-both\">\r\n                  <form onSubmit={handleSignUp} className=\"space-y-5\">\r\n                    <div className=\"space-y-2.5\">\r\n                      <Label htmlFor=\"signup-name\" className=\"text-xs font-mono font-bold uppercase text-gray-500\">\r\n                        Display Name\r\n                      </Label>\r\n                      <div className=\"relative\">\r\n                        <User className=\"absolute left-3.5 top-1/2 transform -translate-y-1/2 size-4 text-gray-400 pointer-events-none\" />\r\n                        <Input\r\n                          id=\"signup-name\"\r\n                          type=\"text\"\r\n                          placeholder=\"Enter your display name\"\r\n                          value={signUpData.displayName}\r\n                          onChange={(e) => handleSignUpNameChange(e.target.value)}\r\n                          className={`pl-10 pr-4 h-12 bg-gray-50 border border-gray-300 text-black placeholder:text-gray-400 focus:bg-white focus:border-black focus:ring-0 rounded-none font-mono text-sm transition-all duration-200 hover:border-gray-400 ${formErrors.displayName\r\n                            ? 'border-red-500 focus:border-red-500'\r\n                            : ''\r\n                            }`}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          autoComplete=\"name\"\r\n                          aria-describedby={formErrors.displayName ? 'signup-name-error' : undefined}\r\n                        />\r\n                      </div>\r\n                      {formErrors.displayName && (\r\n                        <p id=\"signup-name-error\" className=\"text-sm text-red-300 mt-1\">\r\n                          {formErrors.displayName}\r\n                        </p>\r\n                      )}\r\n                    </div>\r\n\r\n                    <div className=\"space-y-2.5\">\r\n                      <Label htmlFor=\"signup-email\" className=\"text-xs font-mono font-bold uppercase text-gray-500\">\r\n                        Email Address\r\n                      </Label>\r\n                      <div className=\"relative\">\r\n                        <Mail className=\"absolute left-3.5 top-1/2 transform -translate-y-1/2 size-4 text-gray-400 pointer-events-none\" />\r\n                        <Input\r\n                          id=\"signup-email\"\r\n                          type=\"email\"\r\n                          placeholder=\"Enter your email\"\r\n                          value={signUpData.email}\r\n                          onChange={(e) => handleSignUpEmailChange(e.target.value)}\r\n                          className={`pl-10 pr-4 h-12 bg-gray-50 border border-gray-300 text-black placeholder:text-gray-400 focus:bg-white focus:border-black focus:ring-0 rounded-none font-mono text-sm transition-all duration-200 hover:border-gray-400 ${formErrors.email\r\n                            ? 'border-red-500 focus:border-red-500'\r\n                            : ''\r\n                            }`}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          autoComplete=\"email\"\r\n                          aria-describedby={formErrors.email ? 'signup-email-error' : undefined}\r\n                        />\r\n                      </div>\r\n                      {formErrors.email && (\r\n                        <p id=\"signup-email-error\" className=\"text-sm text-red-300 mt-1\">\r\n                          {formErrors.email}\r\n                        </p>\r\n                      )}\r\n                    </div>\r\n\r\n                    <div className=\"space-y-2.5\">\r\n                      <Label htmlFor=\"signup-password\" className=\"text-xs font-mono font-bold uppercase text-gray-500\">\r\n                        Password\r\n                      </Label>\r\n                      <div className=\"relative\">\r\n                        <Lock className=\"absolute left-3.5 top-1/2 transform -translate-y-1/2 size-4 text-gray-400 pointer-events-none\" />\r\n                        <Input\r\n                          id=\"signup-password\"\r\n                          type={showPassword ? 'text' : 'password'}\r\n                          placeholder=\"Create a password (min. 8 characters)\"\r\n                          value={signUpData.password}\r\n                          onChange={(e) => handleSignUpPasswordChange(e.target.value)}\r\n                          className={`pl-10 pr-12 h-12 bg-gray-50 border border-gray-300 text-black placeholder:text-gray-400 focus:bg-white focus:border-black focus:ring-0 rounded-none font-mono text-sm transition-all duration-200 hover:border-gray-400 ${formErrors.password\r\n                            ? 'border-red-500 focus:border-red-500'\r\n                            : ''\r\n                            }`}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          autoComplete=\"new-password\"\r\n                          aria-describedby={formErrors.password ? 'signup-password-error' : undefined}\r\n                        />\r\n                        <Button\r\n                          type=\"button\"\r\n                          variant=\"ghost\"\r\n                          size=\"icon\"\r\n                          className=\"absolute right-1 top-1/2 transform -translate-y-1/2 h-9 w-9 p-0 text-gray-400 hover:text-black hover:bg-transparent\"\r\n                          onClick={() => setShowPassword(!showPassword)}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          aria-label={showPassword ? 'Hide password' : 'Show password'}\r\n                        >\r\n                          {showPassword ? <EyeOff className=\"size-4\" /> : <Eye className=\"size-4\" />}\r\n                        </Button>\r\n                      </div>\r\n                      {formErrors.password && (\r\n                        <p id=\"signup-password-error\" className=\"text-sm text-red-300 mt-1\">\r\n                          {formErrors.password}\r\n                        </p>\r\n                      )}\r\n                    </div>\r\n\r\n                    <div className=\"space-y-2.5\">\r\n                      <Label htmlFor=\"confirm-password\" className=\"text-xs font-mono font-bold uppercase text-gray-500\">\r\n                        Confirm Password\r\n                      </Label>\r\n                      <div className=\"relative\">\r\n                        <Lock className=\"absolute left-3.5 top-1/2 transform -translate-y-1/2 size-4 text-gray-400 pointer-events-none\" />\r\n                        <Input\r\n                          id=\"confirm-password\"\r\n                          type={showConfirmPassword ? 'text' : 'password'}\r\n                          placeholder=\"Confirm your password\"\r\n                          value={confirmPassword}\r\n                          onChange={(e) => handleConfirmPasswordChange(e.target.value)}\r\n                          className={`pl-10 pr-12 h-12 bg-gray-50 border border-gray-300 text-black placeholder:text-gray-400 focus:bg-white focus:border-black focus:ring-0 rounded-none font-mono text-sm transition-all duration-200 hover:border-gray-400 ${formErrors.confirmPassword\r\n                            ? 'border-red-500 focus:border-red-500'\r\n                            : ''\r\n                            }`}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          autoComplete=\"new-password\"\r\n                          aria-describedby={formErrors.confirmPassword ? 'confirm-password-error' : undefined}\r\n                        />\r\n                        <Button\r\n                          type=\"button\"\r\n                          variant=\"ghost\"\r\n                          size=\"icon\"\r\n                          className=\"absolute right-1 top-1/2 transform -translate-y-1/2 h-9 w-9 p-0 text-gray-400 hover:text-black hover:bg-transparent\"\r\n                          onClick={() => setShowConfirmPassword(!showConfirmPassword)}\r\n                          disabled={isSigningIn || isSigningUp}\r\n                          aria-label={showConfirmPassword ? 'Hide password' : 'Show password'}\r\n                        >\r\n                          {showConfirmPassword ? <EyeOff className=\"size-4\" /> : <Eye className=\"size-4\" />}\r\n                        </Button>\r\n                      </div>\r\n                      {formErrors.confirmPassword && (\r\n                        <p id=\"confirm-password-error\" className=\"text-sm text-red-300 mt-1\">\r\n                          {formErrors.confirmPassword}\r\n                        </p>\r\n                      )}\r\n                    </div>\r\n\r\n                    <Button\r\n                      type=\"submit\"\r\n                      className=\"w-full h-12 bg-[#FF4D00] hover:bg-black hover:text-white text-white font-mono font-bold uppercase tracking-widest text-sm rounded-none transition-all duration-300 shadow-sm hover:shadow-md active:transform active:scale-[0.98]\"\r\n                      disabled={isSigningUp}\r\n                    >\r\n                      {isSigningUp ? (\r\n                        <>\r\n                          <Loader2 className=\"mr-2 size-4 animate-spin-gpu\" />\r\n                          Creating Account...\r\n                        </>\r\n                      ) : (\r\n                        'Create Account'\r\n                      )}\r\n                    </Button>\r\n                  </form>\r\n                </div>\r\n              </TabsContent>\r\n            </div>\r\n          </Tabs>\r\n        </CardContent>\r\n      </Card>\r\n    </>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\common\\bulk-action-bar.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":19,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/common/bulk-action-bar.tsx\r\n * @description Floating bulk action bar for selected items\r\n * @created 2025-10-25\r\n */\r\n\r\n\"use client\";\r\n\r\nimport React, { useState, useEffect, useMemo, useCallback, memo } from \"react\";\r\nimport { Folder, Star, Trash2, CheckSquare, Square, X, Undo2 } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Checkbox } from \"@/components/ui/checkbox\";\r\nimport { useLinksStore, useUIStore } from \"@/store\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { ToastAction } from \"@/components/ui/toast\";\r\nimport { LazyBulkMoveModal } from \"@/components/lazy\";\r\nimport { useComponentTheme, cn } from \"@/lib/theme\";\r\n\r\ninterface BulkActionBarProps {\r\n  selectedIds: string[];\r\n  onClearSelection: () => void;\r\n  totalVisibleItems: number;\r\n}\r\n\r\n/**\r\n * Floating bulk action bar that appears when items are selected.\r\n * Provides actions for moving, favoriting, and deleting multiple items.\r\n * @param {BulkActionBarProps} props - Component props\r\n * @returns {JSX.Element | null} Bulk action bar component or null if no selection\r\n */\r\nexport const BulkActionBar = memo(function BulkActionBar({\r\n  selectedIds,\r\n  onClearSelection,\r\n  totalVisibleItems,\r\n}: BulkActionBarProps) {\r\n  // Use selector function to prevent unnecessary re-renders\r\n  const { links, bulkToggleFavoriteLinks, bulkDeleteLinks, bulkRestoreLinks } = useLinksStore();\r\n  const { toast } = useToast();\r\n  const theme = useComponentTheme('bulkActionBar');\r\n\r\n  const [showMoveModal, setShowMoveModal] = useState(false);\r\n\r\n  // Memoize selection state calculations\r\n  const allSelected = useMemo(() =>\r\n    selectedIds.length === totalVisibleItems && totalVisibleItems > 0,\r\n    [selectedIds.length, totalVisibleItems]\r\n  );\r\n  const someSelected = useMemo(() =>\r\n    selectedIds.length > 0 && selectedIds.length < totalVisibleItems,\r\n    [selectedIds.length, totalVisibleItems]\r\n  );\r\n  const noneSelected = useMemo(() =>\r\n    selectedIds.length === 0,\r\n    [selectedIds.length]\r\n  );\r\n\r\n  // Memoize selected links to prevent recalculation on every render\r\n  const selectedLinks = useMemo(() =>\r\n    links.filter(link => selectedIds.includes(link.id)),\r\n    [links, selectedIds]\r\n  );\r\n\r\n  // Memoize has favorites check\r\n  const hasFavorites = useMemo(() =>\r\n    selectedLinks.some(link => link.isFavorite),\r\n    [selectedLinks]\r\n  );\r\n\r\n  /**\r\n   * Handles select all toggle\r\n   */\r\n  const handleSelectAll = useCallback(() => {\r\n    if (allSelected) {\r\n      onClearSelection();\r\n    } else {\r\n      // Select all visible items by emitting event to parent\r\n      const event = new CustomEvent('selectAllVisible');\r\n      window.dispatchEvent(event);\r\n    }\r\n  }, [allSelected, onClearSelection]);\r\n\r\n  /**\r\n   * Handles bulk favorite toggle\r\n   */\r\n  const handleBulkFavorite = useCallback(async () => {\r\n    try {\r\n      const hasMixedStates = selectedLinks.some(link => link.isFavorite) &&\r\n        selectedLinks.some(link => !link.isFavorite);\r\n\r\n      // If mixed states, favorite all; otherwise toggle based on first item's state\r\n      const shouldFavorite = hasMixedStates ? true : !selectedLinks[0]?.isFavorite;\r\n\r\n      await bulkToggleFavoriteLinks(selectedIds, shouldFavorite);\r\n\r\n      toast({\r\n        title: `${shouldFavorite ? \"Favorited\" : \"Unfavorited\"} (${selectedIds.length})`,\r\n        variant: \"info\",\r\n        icon: <Star className={`size-4 ${shouldFavorite ? 'fill-yellow-400 text-yellow-400' : ''}`} />,\r\n      });\r\n\r\n      onClearSelection();\r\n    } catch (error) {\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Please try again\",\r\n        variant: \"destructive\",\r\n        icon: <Star className=\"size-4\" />,\r\n      });\r\n    }\r\n  }, [selectedLinks, selectedIds, bulkToggleFavoriteLinks, toast, onClearSelection]);\r\n\r\n  /**\r\n   * Handles undo delete operation\r\n   */\r\n  const handleUndoDelete = useCallback(async () => {\r\n    try {\r\n      await bulkRestoreLinks(selectedIds);\r\n\r\n      toast({\r\n        title: `Restored (${selectedIds.length})`,\r\n        variant: \"info\",\r\n        icon: <Undo2 className=\"size-4\" />,\r\n      });\r\n    } catch (error) {\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Please try again\",\r\n        variant: \"destructive\",\r\n        icon: <Undo2 className=\"size-4\" />,\r\n      });\r\n    }\r\n  }, [selectedIds, bulkRestoreLinks, toast]);\r\n\r\n  /**\r\n   * Handles bulk delete with undo functionality\r\n   */\r\n  const handleBulkDelete = useCallback(async () => {\r\n    try {\r\n      await bulkDeleteLinks(selectedIds);\r\n\r\n      toast({\r\n        title: `Moved to Trash (${selectedIds.length})`,\r\n        variant: \"info\",\r\n        icon: <Trash2 className=\"size-4\" />,\r\n        action: (\r\n          <ToastAction altText=\"Undo\" onClick={handleUndoDelete}>\r\n            Undo\r\n          </ToastAction>\r\n        ),\r\n      });\r\n\r\n      onClearSelection();\r\n    } catch (error) {\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Please try again\",\r\n        variant: \"destructive\",\r\n        icon: <Trash2 className=\"size-4\" />,\r\n      });\r\n    }\r\n  }, [selectedIds, bulkDeleteLinks, toast, onClearSelection, handleUndoDelete]);\r\n\r\n  /**\r\n   * Handles bulk move completion\r\n   */\r\n  const handleMoveComplete = useCallback((movedCount: number) => {\r\n    if (movedCount > 0) {\r\n      toast({\r\n        title: `Moved (${movedCount})`,\r\n        variant: \"success\",\r\n        icon: <Folder className=\"size-4\" />,\r\n      });\r\n      onClearSelection();\r\n    }\r\n  }, [toast, onClearSelection]);\r\n\r\n  // Don't render if nothing selected\r\n  if (noneSelected) return null;\r\n\r\n  return (\r\n    <>\r\n      {/* Floating Action Bar - Enhanced Design with Theme-Aware Colors */}\r\n      <div\r\n        className={cn(\r\n          \"fixed top-16 sm:top-18 left-1/2 transform -translate-x-1/2 z-40\",\r\n          \"rounded-xl shadow-xl px-4 py-3 flex items-center gap-3\",\r\n          \"min-w-[300px] sm:min-w-[360px] max-w-[95vw] border\",\r\n          \"bg-background/95 backdrop-blur-sm border-border/50\",\r\n          \"animate-in slide-in-from-top-2 fade-in duration-300\"\r\n        )}\r\n      >\r\n        {/* Action Buttons - First */}\r\n        {/* Mobile: Vertical layout with text below icons */}\r\n        <div className=\"md:hidden flex items-center gap-3\">\r\n          {/* Move Button */}\r\n          <div className=\"flex flex-col items-center gap-1\">\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"sm\"\r\n              onClick={() => setShowMoveModal(true)}\r\n              className={cn(\r\n                \"h-10 w-10 rounded-lg p-0\",\r\n                \"transition-transform duration-200 active:scale-95 hover:bg-muted/50\"\r\n              )}\r\n              aria-label=\"Move selected items\"\r\n            >\r\n              <Folder className=\"size-4\" />\r\n            </Button>\r\n            <span className=\"text-[10px] font-medium leading-tight text-muted-foreground\">\r\n              Move\r\n            </span>\r\n          </div>\r\n\r\n          {/* Favorite Button */}\r\n          <div className=\"flex flex-col items-center gap-1\">\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"sm\"\r\n              onClick={handleBulkFavorite}\r\n              className={cn(\r\n                \"h-10 w-10 rounded-lg p-0\",\r\n                \"transition-transform duration-200 active:scale-95 hover:bg-muted/50\"\r\n              )}\r\n              aria-label=\"Toggle favorite for selected items\"\r\n            >\r\n              <Star className={`size-4 ${hasFavorites ? 'fill-yellow-400 text-yellow-400' : ''}`} />\r\n            </Button>\r\n            <span className=\"text-[10px] font-medium leading-tight text-muted-foreground\">\r\n              Favorite\r\n            </span>\r\n          </div>\r\n\r\n          {/* Delete Button */}\r\n          <div className=\"flex flex-col items-center gap-1\">\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"sm\"\r\n              onClick={handleBulkDelete}\r\n              className={cn(\r\n                \"h-10 w-10 rounded-lg p-0\",\r\n                \"transition-transform duration-200 active:scale-95 hover:bg-red-500/10 hover:text-red-600 dark:hover:text-red-400\"\r\n              )}\r\n              aria-label=\"Delete selected items\"\r\n            >\r\n              <Trash2 className=\"size-4 text-red-500\" />\r\n            </Button>\r\n            <span className=\"text-[10px] font-medium leading-tight text-muted-foreground\">\r\n              Delete\r\n            </span>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Desktop: Horizontal layout with text beside icons */}\r\n        <div className=\"hidden md:flex items-center gap-1.5\">\r\n          {/* Move Button */}\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={() => setShowMoveModal(true)}\r\n            className={cn(\r\n              \"gap-1.5 px-3 h-9 rounded-lg text-sm font-medium\",\r\n              \"transition-transform duration-200 active:scale-[0.98] hover:bg-muted/50\"\r\n            )}\r\n            aria-label=\"Move selected items\"\r\n          >\r\n            <Folder className=\"size-4\" />\r\n            <span>Move</span>\r\n          </Button>\r\n\r\n          {/* Favorite Button */}\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={handleBulkFavorite}\r\n            className={cn(\r\n              \"gap-1.5 px-3 h-9 rounded-lg text-sm font-medium\",\r\n              \"transition-transform duration-200 active:scale-[0.98] hover:bg-muted/50\"\r\n            )}\r\n            aria-label=\"Toggle favorite for selected items\"\r\n          >\r\n            <Star className={`size-4 ${hasFavorites ? 'fill-yellow-400 text-yellow-400' : ''}`} />\r\n            <span>Favorite</span>\r\n          </Button>\r\n\r\n          {/* Delete Button */}\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"sm\"\r\n            onClick={handleBulkDelete}\r\n            className={cn(\r\n              \"gap-1.5 px-3 h-9 rounded-lg text-sm font-medium\",\r\n              \"transition-transform duration-200 active:scale-[0.98] hover:bg-red-500/10 hover:text-red-600 dark:hover:text-red-400 text-red-500\"\r\n            )}\r\n            aria-label=\"Delete selected items\"\r\n          >\r\n            <Trash2 className=\"size-4\" />\r\n            <span>Delete</span>\r\n          </Button>\r\n        </div>\r\n\r\n        {/* Divider - Mobile only */}\r\n        <div className=\"md:hidden h-7 w-px bg-border/50 flex-shrink-0\" />\r\n\r\n        {/* Selection Count + Select All - Mobile grouped together */}\r\n        <div className=\"md:hidden flex items-center gap-1 flex-shrink-0\">\r\n          {/* Selection Count + Select All in same row */}\r\n          <div className=\"flex flex-col items-center gap-1\">\r\n            <div className=\"flex items-center gap-1\">\r\n              {/* Selection Count */}\r\n              <div className=\"text-xs font-medium tabular-nums opacity-80 text-muted-foreground\">\r\n                <span>{selectedIds.length}</span>\r\n              </div>\r\n\r\n              {/* Select All Button */}\r\n              <Button\r\n                variant=\"ghost\"\r\n                size=\"icon\"\r\n                onClick={handleSelectAll}\r\n                className=\"h-8 w-8 rounded-lg p-0 transition-transform duration-200 active:scale-95 hover:bg-muted/50\"\r\n                aria-label=\"Select all visible items\"\r\n              >\r\n                {allSelected ? (\r\n                  <CheckSquare className=\"size-3.5\" />\r\n                ) : (\r\n                  <Square className=\"size-3.5\" />\r\n                )}\r\n              </Button>\r\n            </div>\r\n\r\n            {/* Text Label below both */}\r\n            <span className=\"text-[10px] font-medium leading-tight text-muted-foreground\">\r\n              Select All\r\n            </span>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Desktop Divider */}\r\n        <div className=\"hidden md:block h-7 w-px bg-border/50\" />\r\n\r\n        {/* Desktop Selection Count */}\r\n        <div className=\"hidden md:block\">\r\n          <div className=\"flex items-center gap-2 text-xs font-medium flex-shrink-0 tabular-nums opacity-80 text-muted-foreground\">\r\n            <span>{selectedIds.length} selected</span>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Desktop Select All Checkbox */}\r\n        <div className=\"hidden md:flex items-center gap-2.5 flex-shrink-0\">\r\n          <Checkbox\r\n            checked={allSelected}\r\n            ref={(el: any) => {\r\n              if (el) el.indeterminate = someSelected;\r\n            }}\r\n            onCheckedChange={handleSelectAll}\r\n            aria-label=\"Select all visible items\"\r\n            className=\"h-4 w-4 rounded border-2 data-[state=checked]:text-primary-foreground\"\r\n          />\r\n          <span className=\"text-sm font-medium text-muted-foreground\">\r\n            Select all\r\n          </span>\r\n        </div>\r\n\r\n        {/* Close Button - Last - Right aligned on mobile */}\r\n        <Button\r\n          variant=\"ghost\"\r\n          size=\"icon\"\r\n          onClick={onClearSelection}\r\n          className=\"h-10 w-10 md:h-9 md:w-9 rounded-lg flex-shrink-0 ml-auto md:ml-0 transition-transform duration-200 active:scale-95 opacity-70 hover:opacity-100 hover:bg-muted/50\"\r\n          aria-label=\"Clear selection\"\r\n        >\r\n          <X className=\"size-4\" />\r\n        </Button>\r\n      </div>\r\n\r\n      {/* Bulk Move Modal */}\r\n      {showMoveModal && (\r\n        <React.Suspense fallback={<div className=\"sr-only\">Loading move modal...</div>}>\r\n          <LazyBulkMoveModal\r\n            isOpen={showMoveModal}\r\n            onClose={() => setShowMoveModal(false)}\r\n            selectedIds={selectedIds}\r\n            onComplete={handleMoveComplete}\r\n          />\r\n        </React.Suspense>\r\n      )}\r\n    </>\r\n  );\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\common\\empty-state.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":12,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/common/empty-state.tsx\r\n * @description Empty state component for various scenarios\r\n * @created 2025-10-18\r\n */\r\n\r\nimport { LucideIcon } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\n\r\ninterface EmptyStateProps {\r\n  icon?: LucideIcon;\r\n  title: string;\r\n  description: string;\r\n  action?: {\r\n    label: string;\r\n    onClick: () => void;\r\n  };\r\n}\r\n\r\n/**\r\n * Empty state component for displaying when no content is available.\r\n * Shows an icon, title, description, and optional action button.\r\n * @param {EmptyStateProps} props - Component props\r\n * @returns {JSX.Element} Empty state component\r\n */\r\nexport function EmptyState({\r\n  icon: Icon,\r\n  title,\r\n  description,\r\n  action,\r\n}: EmptyStateProps) {\r\n  return (\r\n    <div className=\"flex min-h-[400px] sm:min-h-[500px] flex-col items-center justify-center rounded-xl border border-dashed border-muted-foreground/20 p-8 sm:p-12 text-center animate-in fade-in-50 duration-300 bg-muted/30\">\r\n      {Icon && (\r\n        <div className=\"mx-auto flex h-20 w-20 sm:h-24 sm:w-24 items-center justify-center rounded-full bg-muted/50 backdrop-blur-sm\">\r\n          <Icon className=\"h-10 w-10 sm:h-12 sm:w-12 text-muted-foreground/60\" />\r\n        </div>\r\n      )}\r\n      <h3 className=\"mt-6 sm:mt-8 text-xl sm:text-2xl font-semibold text-foreground\">{title}</h3>\r\n      <p className=\"mb-6 sm:mb-8 mt-3 sm:mt-4 text-sm sm:text-base text-muted-foreground max-w-md leading-relaxed\">\r\n        {description}\r\n      </p>\r\n      {action && (\r\n        <Button onClick={action.onClick} size=\"lg\" className=\"px-6 py-2.5 text-base font-medium\">\r\n          {action.label}\r\n        </Button>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\common\\error-boundary.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":15,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/common/error-boundary.tsx\r\n * @description Error boundary component to catch unhandled errors in auth flow\r\n * @created 2025-01-21\r\n */\r\n\r\n'use client';\r\n\r\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\r\nimport { AlertTriangle, RefreshCw } from 'lucide-react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface ErrorBoundaryProps {\r\n    children: ReactNode;\r\n    fallbackTitle?: string;\r\n    fallbackMessage?: string;\r\n}\r\n\r\ninterface ErrorBoundaryState {\r\n    hasError: boolean;\r\n    error: Error | null;\r\n    errorInfo: ErrorInfo | null;\r\n}\r\n\r\n/**\r\n * Error boundary component to catch and display errors gracefully\r\n * Implements React error boundary pattern for better error handling\r\n */\r\nexport class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\r\n    constructor(props: ErrorBoundaryProps) {\r\n        super(props);\r\n        this.state = {\r\n            hasError: false,\r\n            error: null,\r\n            errorInfo: null,\r\n        };\r\n    }\r\n\r\n    static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {\r\n        return { hasError: true, error };\r\n    }\r\n\r\n    componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\r\n        // Log error details for debugging\r\n        logger.error('Error boundary caught an error:', {\r\n            error: error.message,\r\n            stack: error.stack,\r\n            componentStack: errorInfo.componentStack,\r\n        });\r\n\r\n        this.setState({\r\n            error,\r\n            errorInfo,\r\n        });\r\n    }\r\n\r\n    handleReset = (): void => {\r\n        this.setState({\r\n            hasError: false,\r\n            error: null,\r\n            errorInfo: null,\r\n        });\r\n\r\n        // Reload the page to recover from the error\r\n        if (typeof window !== 'undefined') {\r\n            window.location.reload();\r\n        }\r\n    };\r\n\r\n    render(): ReactNode {\r\n        if (this.state.hasError) {\r\n            const { fallbackTitle, fallbackMessage } = this.props;\r\n            const { error } = this.state;\r\n\r\n            return (\r\n                <div className=\"flex items-center justify-center min-h-screen bg-background p-4\">\r\n                    <Card className=\"w-full max-w-md border-destructive/50\">\r\n                        <CardHeader className=\"text-center\">\r\n                            <div className=\"flex justify-center mb-4\">\r\n                                <div className=\"p-4 bg-destructive/10 rounded-full\">\r\n                                    <AlertTriangle className=\"size-8 text-destructive\" />\r\n                                </div>\r\n                            </div>\r\n                            <CardTitle className=\"text-2xl\">\r\n                                {fallbackTitle || 'Something went wrong'}\r\n                            </CardTitle>\r\n                            <CardDescription className=\"text-base mt-2\">\r\n                                {fallbackMessage || 'An unexpected error occurred. Please try refreshing the page.'}\r\n                            </CardDescription>\r\n                        </CardHeader>\r\n                        <CardContent className=\"space-y-4\">\r\n                            {error && process.env.NODE_ENV === 'development' && (\r\n                                <div className=\"p-4 bg-muted rounded-lg\">\r\n                                    <p className=\"text-sm font-mono text-muted-foreground break-all\">\r\n                                        {error.message}\r\n                                    </p>\r\n                                </div>\r\n                            )}\r\n                            <Button\r\n                                onClick={this.handleReset}\r\n                                className=\"w-full\"\r\n                                size=\"lg\"\r\n                            >\r\n                                <RefreshCw className=\"mr-2 size-4\" />\r\n                                Refresh Page\r\n                            </Button>\r\n                        </CardContent>\r\n                    </Card>\r\n                </div>\r\n            );\r\n        }\r\n\r\n        return this.props.children;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\common\\highlight-text.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":3,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\r\n\r\ninterface HighlightTextProps {\r\n    text: string;\r\n    highlight?: string;\r\n    className?: string;\r\n}\r\n\r\n/**\r\n * Component to highlight search terms within text\r\n * Renders text with matched parts wrapped in a highlight span\r\n */\r\nexport function HighlightText({ text, highlight, className }: HighlightTextProps) {\r\n    const parts = useMemo(() => {\r\n        if (!highlight || !highlight.trim()) {\r\n            return [{ text, isHighlight: false }];\r\n        }\r\n\r\n        const regex = new RegExp(`(${highlight.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})`, 'gi');\r\n        const splitParts = text.split(regex);\r\n\r\n        return splitParts.filter(part => part).map(part => ({\r\n            text: part,\r\n            isHighlight: regex.test(part)\r\n        }));\r\n    }, [text, highlight]);\r\n\r\n    if (!highlight || !highlight.trim()) {\r\n        return <span className={className}>{text}</span>;\r\n    }\r\n\r\n    return (\r\n        <span className={className}>\r\n            {parts.map((part, i) => (\r\n                part.isHighlight ? (\r\n                    <span key={i} className=\"bg-yellow-200 dark:bg-yellow-400/25 text-foreground dark:text-yellow-50 dark:font-medium rounded-[2px] px-0.5 -mx-0.5\">\r\n                        {part.text}\r\n                    </span>\r\n                ) : (\r\n                    <span key={i}>{part.text}</span>\r\n                )\r\n            ))}\r\n        </span>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\common\\loading-state.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":11,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/common/loading-state.tsx\r\n * @description Reusable loading spinner component with consistent styling\r\n * @created 2025-01-21\r\n */\r\n\r\nimport React from 'react';\r\nimport { Loader2 } from 'lucide-react';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface LoadingStateProps {\r\n    /**\r\n     * Size variant of the loading spinner\r\n     */\r\n    size?: 'sm' | 'md' | 'lg';\r\n\r\n    /**\r\n     * Optional message to display below the spinner\r\n     */\r\n    message?: string;\r\n\r\n    /**\r\n     * Additional CSS classes\r\n     */\r\n    className?: string;\r\n\r\n    /**\r\n     * Whether to center the loading state\r\n     */\r\n    centered?: boolean;\r\n}\r\n\r\nconst sizeClasses = {\r\n    sm: 'size-4',\r\n    md: 'size-6',\r\n    lg: 'size-8',\r\n};\r\n\r\n/**\r\n * Reusable loading spinner component\r\n * @param {LoadingStateProps} props - Component props\r\n * @returns {JSX.Element} Loading spinner\r\n */\r\nexport function LoadingState({\r\n    size = 'md',\r\n    message,\r\n    className,\r\n    centered = false\r\n}: LoadingStateProps): React.JSX.Element {\r\n    return (\r\n        <div\r\n            className={cn(\r\n                'flex flex-col items-center gap-3',\r\n                centered && 'justify-center min-h-[200px]',\r\n                className\r\n            )}\r\n            role=\"status\"\r\n            aria-live=\"polite\"\r\n            aria-label={message || 'Loading'}\r\n        >\r\n            <Loader2\r\n                className={cn(\r\n                    'animate-spin-gpu text-primary',\r\n                    sizeClasses[size]\r\n                )}\r\n            />\r\n            {message && (\r\n                <p className=\"text-sm text-muted-foreground font-medium\">\r\n                    {message}\r\n                </p>\r\n            )}\r\n            <span className=\"sr-only\">Loading...</span>\r\n        </div>\r\n    );\r\n}\r\n\r\n/**\r\n * Full page loading state\r\n */\r\nexport function PageLoadingState({ message }: { message?: string }): React.JSX.Element {\r\n    return (\r\n        <div className=\"flex items-center justify-center min-h-screen bg-background\">\r\n            <LoadingState size=\"lg\" message={message || 'Loading...'} />\r\n        </div>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\common\\mobile-fab.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":24,"column":5,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/common/mobile-fab.tsx\r\n * @description Floating Action Button for mobile devices\r\n * @author LinksVault Team\r\n * @created 2025-10-18\r\n * @modified 2025-10-19\r\n */\r\n\r\n\"use client\";\r\n\r\nimport { Plus } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useUIStore } from \"@/store\";\r\n\r\n/**\r\n * Mobile Floating Action Button\r\n * Displays a fixed button in the bottom-right corner on mobile devices\r\n * Opens the Add Link modal when clicked\r\n */\r\nexport function MobileFAB() {\r\n  const { setAddLinkModalOpen } = useUIStore();\r\n\r\n  return (\r\n    <Button\r\n      size=\"lg\"\r\n      className=\"fixed bottom-6 right-6 z-50 h-14 w-14 rounded-full shadow-2xl bg-primary text-primary-foreground hover:bg-primary/90 transition-all duration-200 hover:scale-110 hover:shadow-2xl active:scale-95 md:hidden\"\r\n      onClick={() => setAddLinkModalOpen(true)}\r\n      aria-label=\"Add new link\"\r\n    >\r\n      <Plus className=\"h-6 w-6\" />\r\n      <span className=\"sr-only\">Add Link</span>\r\n    </Button>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\common\\offline-indicator.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":45,"column":5,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/common/offline-indicator.tsx\r\n * @description Global indicator shown when the user is offline\r\n * @created 2025-11-12\r\n */\r\n\r\nimport { useEffect, useState } from \"react\";\r\nimport { WifiOff } from \"lucide-react\";\r\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\r\nimport { useOnlineStatus } from \"@/hooks/use-online-status\";\r\n\r\n/**\r\n * Displays a sticky alert banner when the user goes offline.\r\n * Automatically dismisses when connection is restored.\r\n * @example\r\n * <OfflineIndicator />\r\n * // Shows \"You're offline. Changes will sync when you're back online.\"\r\n * @returns {JSX.Element | null} Alert banner or null if online\r\n */\r\nexport function OfflineIndicator() {\r\n  const isOnline = useOnlineStatus();\r\n  const [show, setShow] = useState(false);\r\n  const [wasOffline, setWasOffline] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!isOnline) {\r\n      // User just went offline\r\n      setShow(true);\r\n      setWasOffline(true);\r\n    } else if (wasOffline) {\r\n      // User came back online - show recovery message briefly\r\n      const timer = setTimeout(() => {\r\n        setShow(false);\r\n        setWasOffline(false);\r\n      }, 3000);\r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [isOnline, wasOffline]);\r\n\r\n  if (!show) return null;\r\n\r\n  return (\r\n    <div className=\"fixed top-0 left-0 right-0 z-50 animate-in slide-in-from-top duration-300\">\r\n      <Alert\r\n        variant={isOnline ? \"default\" : \"destructive\"}\r\n        className={`rounded-none border-x-0 border-t-0 ${\r\n          isOnline ? \"bg-green-50 border-green-200 dark:bg-green-950 dark:border-green-800\" : \"\"\r\n        }`}\r\n      >\r\n        <WifiOff className=\"h-4 w-4\" />\r\n        <AlertDescription>\r\n          {isOnline\r\n            ? \"You're back online! All changes have been synced.\"\r\n            : \"You're offline. Changes will sync when you're back online.\"}\r\n        </AlertDescription>\r\n      </Alert>\r\n    </div>\r\n  );\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\common\\theme-toggle.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":28,"column":12,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/common/theme-toggle.tsx\r\n * @description Theme toggle button for dark/light mode\r\n * @created 2025-10-18\r\n */\r\n\r\nimport * as React from \"react\";\r\nimport { Moon, Sun } from \"lucide-react\";\r\nimport { useTheme } from \"next-themes\";\r\nimport { Button } from \"@/components/ui/button\";\r\n\r\n/**\r\n * Theme toggle button component for switching between light and dark modes.\r\n * Includes animated sun/moon icons with smooth transitions.\r\n * @returns {JSX.Element} Theme toggle button\r\n */\r\nexport function ThemeToggle() {\r\n  const { theme, setTheme } = useTheme();\r\n  const [mounted, setMounted] = React.useState(false);\r\n\r\n  React.useEffect(() => {\r\n    setMounted(true);\r\n  }, []);\r\n\r\n  if (!mounted) {\r\n    return <Button variant=\"ghost\" size=\"icon\" className=\"h-9 w-9\" />;\r\n  }\r\n\r\n  return (\r\n    <Button\r\n      variant=\"ghost\"\r\n      size=\"icon\"\r\n      onClick={() => setTheme(theme === \"light\" ? \"dark\" : \"light\")}\r\n      className=\"h-9 w-9 relative overflow-hidden\"\r\n    >\r\n      <Sun className=\"h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all duration-500 ease-in-out dark:-rotate-90 dark:scale-0\" />\r\n      <Moon className=\"absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all duration-500 ease-in-out dark:rotate-0 dark:scale-100\" />\r\n      <span className=\"sr-only\">Toggle theme</span>\r\n    </Button>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\debug\\performance-dashboard.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":31,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/debug/performance-dashboard.tsx\r\n * @description Performance debugging dashboard for monitoring authentication and database performance\r\n * @created 2025-11-15\r\n */\r\n\r\n'use client';\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport { authDebug } from '@/lib/services/auth-debug.service';\r\nimport { databaseDebug } from '@/lib/services/database-debug.service';\r\nimport { debugLogger } from '@/lib/services/debug-logger.service';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { ScrollArea } from '@/components/ui/scroll-area';\r\nimport { \r\n  RefreshCw, \r\n  Download, \r\n  Eye, \r\n  EyeOff, \r\n  AlertTriangle,\r\n  CheckCircle,\r\n  Clock,\r\n  Database,\r\n  User,\r\n  BarChart3,\r\n  Zap\r\n} from 'lucide-react';\r\n\r\ninterface DebugStats {\r\n  auth: {\r\n    totalSessions: number;\r\n    successRate: number;\r\n    averageRecoveryTime: number;\r\n    mostSuccessfulStrategy: string;\r\n    strategyPerformance: Record<string, any>;\r\n    browserPerformance: Record<string, any>;\r\n  };\r\n  database: {\r\n    totalSessions: number;\r\n    averageQueryTime: number;\r\n    averageSessionTime: number;\r\n    cacheHitRate: number;\r\n    errorRate: number;\r\n    timeoutRate: number;\r\n    operationPerformance: Record<string, any>;\r\n    queryTypePerformance: Record<string, any>;\r\n  };\r\n}\r\n\r\nexport function PerformanceDashboard() {\r\n  const [isVisible, setIsVisible] = useState(false);\r\n  const [stats, setStats] = useState<DebugStats | null>(null);\r\n  const [isDebugMode, setIsDebugMode] = useState(false);\r\n  \r\n  // Log environment and debug status for diagnosis\r\n  useEffect(() => {\r\n    const env = process.env.NODE_ENV;\r\n    const debugMode = process.env.DEBUG_MODE;\r\n    const debugInfo = debugLogger.debugInfo();\r\n    \r\n    console.log('≡ƒöì PerformanceDashboard mounted:', {\r\n      environment: env,\r\n      debugMode: debugMode,\r\n      debugServiceEnabled: debugInfo.enabled,\r\n      sessionId: debugInfo.sessionId,\r\n      timestamp: new Date().toISOString()\r\n    });\r\n    \r\n    // Force disable in production if not explicitly enabled\r\n    if (env === 'production' && !debugMode) {\r\n      console.warn('≡ƒÜ¿ Production environment detected - debug dashboard should not be visible');\r\n      setIsVisible(false);\r\n      setIsDebugMode(false);\r\n      debugLogger.disable();\r\n    }\r\n  }, []);\r\n\r\n  const loadStats = () => {\r\n    const authStats = authDebug.getSummary();\r\n    const dbStats = databaseDebug.getSummary();\r\n    \r\n    setStats({\r\n      auth: authStats,\r\n      database: dbStats\r\n    });\r\n  };\r\n\r\n  const exportData = () => {\r\n    const data = {\r\n      timestamp: new Date().toISOString(),\r\n      debugInfo: debugLogger.debugInfo(),\r\n      authData: authDebug.exportData(),\r\n      databaseData: databaseDebug.exportData(),\r\n      summary: stats\r\n    };\r\n    \r\n    const blob = new Blob([JSON.stringify(data, null, 2)], { \r\n      type: 'application/json' \r\n    });\r\n    const url = URL.createObjectURL(blob);\r\n    const a = document.createElement('a');\r\n    a.href = url;\r\n    a.download = `linkvault-debug-${new Date().toISOString()}.json`;\r\n    a.click();\r\n    URL.revokeObjectURL(url);\r\n  };\r\n\r\n  const clearData = () => {\r\n    authDebug.clearData();\r\n    databaseDebug.clearData();\r\n    loadStats();\r\n  };\r\n\r\n  const toggleDebugMode = () => {\r\n    const env = process.env.NODE_ENV;\r\n    const debugMode = process.env.DEBUG_MODE;\r\n    \r\n    // Prevent manual enabling in production unless explicitly allowed\r\n    if (env === 'production' && debugMode !== 'true') {\r\n      console.warn('ΓÜá∩╕Å Cannot enable debug mode in production environment');\r\n      return;\r\n    }\r\n    \r\n    const newMode = !isDebugMode;\r\n    if (newMode) {\r\n      authDebug.enable();\r\n      databaseDebug.enable();\r\n    } else {\r\n      authDebug.disable();\r\n      databaseDebug.disable();\r\n    }\r\n    setIsDebugMode(newMode);\r\n  };\r\n\r\n  useEffect(() => {\r\n    // Check if debug mode is enabled\r\n    const debugInfo = debugLogger.debugInfo();\r\n    setIsDebugMode(debugInfo.enabled);\r\n    loadStats();\r\n  }, []);\r\n\r\n  // Prevent dashboard from rendering in production unless explicitly enabled\r\n  const env = process.env.NODE_ENV;\r\n  const debugMode = process.env.DEBUG_MODE;\r\n  \r\n  if (env === 'production' && debugMode !== 'true') {\r\n    console.log('≡ƒÜ½ Debug dashboard disabled in production environment');\r\n    return null;\r\n  }\r\n\r\n  if (!isVisible) {\r\n    return (\r\n      <div className=\"fixed bottom-4 right-4 z-50\">\r\n        <Button\r\n          variant=\"outline\"\r\n          size=\"sm\"\r\n          onClick={() => setIsVisible(true)}\r\n          className=\"bg-black text-white border-gray-700 hover:bg-gray-800 hover:border-gray-600\"\r\n        >\r\n          <BarChart3 className=\"h-4 w-4 mr-2\" />\r\n          Debug Dashboard\r\n        </Button>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"fixed bottom-4 right-4 z-50 w-96 bg-white border border-gray-200 rounded-lg shadow-lg\">\r\n      <Card className=\"border-0 shadow-none\">\r\n        <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\r\n          <div className=\"flex items-center space-x-2\">\r\n            <CardTitle className=\"text-lg font-semibold flex items-center\">\r\n              <Zap className=\"h-5 w-5 text-orange-500 mr-2\" />\r\n              Performance Dashboard\r\n            </CardTitle>\r\n            <Badge variant={isDebugMode ? \"default\" : \"secondary\"}>\r\n              {isDebugMode ? \"Active\" : \"Inactive\"}\r\n            </Badge>\r\n          </div>\r\n          <div className=\"flex space-x-1\">\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"sm\"\r\n              onClick={toggleDebugMode}\r\n              title={isDebugMode ? \"Disable debug mode\" : \"Enable debug mode\"}\r\n            >\r\n              {isDebugMode ? (\r\n                <Eye className=\"h-4 w-4 text-green-500\" />\r\n              ) : (\r\n                <EyeOff className=\"h-4 w-4 text-gray-500\" />\r\n              )}\r\n            </Button>\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"sm\"\r\n              onClick={loadStats}\r\n              title=\"Refresh stats\"\r\n            >\r\n              <RefreshCw className=\"h-4 w-4\" />\r\n            </Button>\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"sm\"\r\n              onClick={exportData}\r\n              title=\"Export debug data\"\r\n            >\r\n              <Download className=\"h-4 w-4\" />\r\n            </Button>\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"sm\"\r\n              onClick={() => setIsVisible(false)}\r\n              title=\"Close dashboard\"\r\n            >\r\n              <EyeOff className=\"h-4 w-4\" />\r\n            </Button>\r\n          </div>\r\n        </CardHeader>\r\n\r\n        <CardContent className=\"space-y-4 max-h-96 overflow-y-auto\">\r\n          {stats && (\r\n            <>\r\n              {/* Authentication Performance */}\r\n              <div className=\"space-y-2\">\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <User className=\"h-4 w-4 text-blue-500\" />\r\n                  <h3 className=\"font-medium\">Authentication Performance</h3>\r\n                </div>\r\n                \r\n                <div className=\"grid grid-cols-2 gap-2 text-xs\">\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Total Sessions:</span>\r\n                    <span className=\"font-medium\">{stats.auth.totalSessions}</span>\r\n                  </div>\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Success Rate:</span>\r\n                    <span className={`font-medium ${stats.auth.successRate >= 80 ? 'text-green-600' : 'text-red-600'}`}>\r\n                      {stats.auth.successRate.toFixed(1)}%\r\n                    </span>\r\n                  </div>\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Avg Recovery Time:</span>\r\n                    <span className=\"font-medium\">{stats.auth.averageRecoveryTime.toFixed(0)}ms</span>\r\n                  </div>\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Best Strategy:</span>\r\n                    <span className=\"font-medium\">{stats.auth.mostSuccessfulStrategy || 'N/A'}</span>\r\n                  </div>\r\n                </div>\r\n\r\n                {Object.keys(stats.auth.strategyPerformance).length > 0 && (\r\n                  <div className=\"mt-2\">\r\n                    <h4 className=\"text-xs font-medium mb-1\">Strategy Performance:</h4>\r\n                    {Object.entries(stats.auth.strategyPerformance).map(([strategy, data]) => (\r\n                      <div key={strategy} className=\"flex justify-between text-xs mb-1\">\r\n                        <span className=\"text-gray-600\">{strategy}:</span>\r\n                        <span className={`font-medium ${data.successes / data.attempts >= 0.8 ? 'text-green-600' : 'text-red-600'}`}>\r\n                          {(data.successes / data.attempts * 100).toFixed(1)}% ({data.attempts} attempts)\r\n                        </span>\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                )}\r\n              </div>\r\n\r\n              {/* Database Performance */}\r\n              <div className=\"space-y-2 border-t pt-3\">\r\n                <div className=\"flex items-center space-x-2\">\r\n                  <Database className=\"h-4 w-4 text-green-500\" />\r\n                  <h3 className=\"font-medium\">Database Performance</h3>\r\n                </div>\r\n                \r\n                <div className=\"grid grid-cols-2 gap-2 text-xs\">\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Total Sessions:</span>\r\n                    <span className=\"font-medium\">{stats.database.totalSessions}</span>\r\n                  </div>\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Avg Query Time:</span>\r\n                    <span className={`font-medium ${stats.database.averageQueryTime <= 2000 ? 'text-green-600' : 'text-red-600'}`}>\r\n                      {stats.database.averageQueryTime.toFixed(0)}ms\r\n                    </span>\r\n                  </div>\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Cache Hit Rate:</span>\r\n                    <span className={`font-medium ${stats.database.cacheHitRate >= 70 ? 'text-green-600' : 'text-red-600'}`}>\r\n                      {stats.database.cacheHitRate.toFixed(1)}%\r\n                    </span>\r\n                  </div>\r\n                  <div className=\"flex justify-between\">\r\n                    <span>Error Rate:</span>\r\n                    <span className={`font-medium ${stats.database.errorRate <= 5 ? 'text-green-600' : 'text-red-600'}`}>\r\n                      {stats.database.errorRate.toFixed(1)}%\r\n                    </span>\r\n                  </div>\r\n                </div>\r\n\r\n                {Object.keys(stats.database.operationPerformance).length > 0 && (\r\n                  <div className=\"mt-2\">\r\n                    <h4 className=\"text-xs font-medium mb-1\">Operation Performance:</h4>\r\n                    {Object.entries(stats.database.operationPerformance).slice(0, 5).map(([operation, data]) => (\r\n                      <div key={operation} className=\"flex justify-between text-xs mb-1\">\r\n                        <span className=\"text-gray-600\">{operation}:</span>\r\n                        <span className=\"font-medium\">\r\n                          {data.averageTime.toFixed(0)}ms ({data.successRate.toFixed(1)}%)\r\n                        </span>\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                )}\r\n              </div>\r\n\r\n              {/* Performance Indicators */}\r\n              <div className=\"border-t pt-3\">\r\n                <h4 className=\"text-xs font-medium mb-2\">Performance Indicators:</h4>\r\n                <div className=\"space-y-1\">\r\n                  {stats.auth.successRate < 80 && (\r\n                    <div className=\"flex items-center space-x-1 text-xs text-red-600\">\r\n                      <AlertTriangle className=\"h-3 w-3\" />\r\n                      <span>Low authentication success rate</span>\r\n                    </div>\r\n                  )}\r\n                  {stats.database.averageQueryTime > 2000 && (\r\n                    <div className=\"flex items-center space-x-1 text-xs text-red-600\">\r\n                      <Clock className=\"h-3 w-3\" />\r\n                      <span>Slow database queries</span>\r\n                    </div>\r\n                  )}\r\n                  {stats.database.cacheHitRate < 70 && (\r\n                    <div className=\"flex items-center space-x-1 text-xs text-orange-600\">\r\n                      <Database className=\"h-3 w-3\" />\r\n                      <span>Low cache hit rate</span>\r\n                    </div>\r\n                  )}\r\n                  {stats.database.errorRate > 5 && (\r\n                    <div className=\"flex items-center space-x-1 text-xs text-red-600\">\r\n                      <AlertTriangle className=\"h-3 w-3\" />\r\n                      <span>High database error rate</span>\r\n                    </div>\r\n                  )}\r\n                  {stats.auth.successRate >= 80 && stats.database.averageQueryTime <= 2000 && \r\n                   stats.database.cacheHitRate >= 70 && stats.database.errorRate <= 5 && (\r\n                    <div className=\"flex items-center space-x-1 text-xs text-green-600\">\r\n                      <CheckCircle className=\"h-3 w-3\" />\r\n                      <span>All performance metrics are healthy</span>\r\n                    </div>\r\n                  )}\r\n                </div>\r\n              </div>\r\n\r\n              {/* Actions */}\r\n              <div className=\"flex space-x-2\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={clearData}\r\n                  className=\"text-xs\"\r\n                >\r\n                  Clear Data\r\n                </Button>\r\n                <Button\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  onClick={exportData}\r\n                  className=\"text-xs\"\r\n                >\r\n                  Export Data\r\n                </Button>\r\n              </div>\r\n            </>\r\n          )}\r\n\r\n          {!stats && (\r\n            <div className=\"text-center py-4 text-sm text-gray-500\">\r\n              Loading performance data...\r\n            </div>\r\n          )}\r\n        </CardContent>\r\n      </Card>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\error-boundary.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":15,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/error-boundary.tsx\r\n * @description Global error boundary for catching and handling React errors\r\n * @created 2025-11-11\r\n */\r\n\r\n'use client';\r\n\r\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { AlertCircle, RefreshCw, Home } from 'lucide-react';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface ErrorBoundaryProps {\r\n  children: ReactNode;\r\n  fallback?: ReactNode;\r\n  level?: 'critical' | 'warning' | 'info';\r\n  showDetails?: boolean;\r\n}\r\n\r\ninterface ErrorBoundaryState {\r\n  hasError: boolean;\r\n  error: Error | null;\r\n  errorInfo: ErrorInfo | null;\r\n}\r\n\r\n/**\r\n * Global Error Boundary Component\r\n * Catches JavaScript errors anywhere in the component tree and displays a fallback UI\r\n */\r\nexport class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\r\n  static defaultProps = {\r\n    level: 'critical' as const,\r\n    showDetails: false,\r\n  };\r\n\r\n  constructor(props: ErrorBoundaryProps) {\r\n    super(props);\r\n    this.state = {\r\n      hasError: false,\r\n      error: null,\r\n      errorInfo: null,\r\n    };\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {\r\n    // Update state so the next render will show the fallback UI\r\n    return {\r\n      hasError: true,\r\n      error,\r\n    };\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\r\n    // Log the error to an error reporting service\r\n    logger.error('ErrorBoundary caught an error:', {\r\n      error: error.message,\r\n      stack: error.stack,\r\n      componentStack: errorInfo.componentStack,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n\r\n    // Log to console for development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.error('ErrorBoundary caught an error:', error, errorInfo);\r\n    }\r\n\r\n    // Send to error tracking service in production\r\n    if (process.env.NODE_ENV === 'production') {\r\n      // Example: Sentry.captureException(error);\r\n    }\r\n\r\n    this.setState({\r\n      errorInfo,\r\n    });\r\n  }\r\n\r\n  handleReset = () => {\r\n    // Reset the error state\r\n    this.setState({\r\n      hasError: false,\r\n      error: null,\r\n      errorInfo: null,\r\n    });\r\n\r\n    // Log the reset\r\n    logger.info('ErrorBoundary reset triggered');\r\n  };\r\n\r\n  handleRefresh = () => {\r\n    // Refresh the page\r\n    window.location.reload();\r\n  };\r\n\r\n  handleGoHome = () => {\r\n    // Navigate to home page\r\n    window.location.href = '/app';\r\n  };\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      // Custom fallback UI\r\n      if (this.props.fallback) {\r\n        return this.props.fallback;\r\n      }\r\n\r\n      // Default error UI\r\n      const { level, showDetails } = this.props;\r\n      const isDevelopment = process.env.NODE_ENV === 'development';\r\n      const shouldShowDetails = showDetails || (isDevelopment && level === 'critical');\r\n\r\n      return (\r\n        <div className=\"min-h-screen flex items-center justify-center bg-background p-4\">\r\n          <Card className=\"w-full max-w-2xl\">\r\n            <CardHeader className=\"text-center\">\r\n              <div className=\"mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-destructive/10\">\r\n                <AlertCircle className=\"h-8 w-8 text-destructive\" />\r\n              </div>\r\n              <CardTitle className=\"text-2xl font-bold text-destructive\">\r\n                Something went wrong\r\n              </CardTitle>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-6\">\r\n              <div className=\"text-center\">\r\n                <p className=\"text-muted-foreground mb-4\">\r\n                  We apologize for the inconvenience. An unexpected error has occurred.\r\n                </p>\r\n                \r\n                {shouldShowDetails && this.state.error && (\r\n                  <div className=\"mt-6 rounded-lg border border-destructive/20 bg-destructive/5 p-4 text-left\">\r\n                    <h3 className=\"mb-2 font-semibold text-destructive\">Error Details</h3>\r\n                    <p className=\"mb-2 font-mono text-sm\">\r\n                      <strong>Error:</strong> {this.state.error.message}\r\n                    </p>\r\n                    <details className=\"mt-2\">\r\n                      <summary className=\"cursor-pointer text-sm text-muted-foreground\">\r\n                        View stack trace\r\n                      </summary>\r\n                      <pre className=\"mt-2 overflow-x-auto rounded bg-muted p-3 font-mono text-xs\">\r\n                        {this.state.error.stack}\r\n                      </pre>\r\n                    </details>\r\n                    {this.state.errorInfo && (\r\n                      <details className=\"mt-2\">\r\n                        <summary className=\"cursor-pointer text-sm text-muted-foreground\">\r\n                          View component stack\r\n                        </summary>\r\n                        <pre className=\"mt-2 overflow-x-auto rounded bg-muted p-3 font-mono text-xs\">\r\n                          {this.state.errorInfo.componentStack}\r\n                        </pre>\r\n                      </details>\r\n                    )}\r\n                  </div>\r\n                )}\r\n              </div>\r\n\r\n              <div className=\"flex flex-col gap-3 sm:flex-row sm:justify-center\">\r\n                <Button\r\n                  onClick={this.handleReset}\r\n                  variant=\"outline\"\r\n                  className=\"flex-1 sm:flex-none\"\r\n                >\r\n                  <RefreshCw className=\"mr-2 h-4 w-4\" />\r\n                  Try Again\r\n                </Button>\r\n                \r\n                <Button\r\n                  onClick={this.handleRefresh}\r\n                  variant=\"outline\"\r\n                  className=\"flex-1 sm:flex-none\"\r\n                >\r\n                  <RefreshCw className=\"mr-2 h-4 w-4\" />\r\n                  Refresh Page\r\n                </Button>\r\n                \r\n                <Button\r\n                  onClick={this.handleGoHome}\r\n                  className=\"flex-1 sm:flex-none\"\r\n                >\r\n                  <Home className=\"mr-2 h-4 w-4\" />\r\n                  Go to Home\r\n                </Button>\r\n              </div>\r\n\r\n              <div className=\"mt-6 border-t pt-4 text-center\">\r\n                <p className=\"text-sm text-muted-foreground\">\r\n                  If this problem persists, please contact support with the error details above.\r\n                </p>\r\n              </div>\r\n            </CardContent>\r\n          </Card>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n/**\r\n * Higher-order component to wrap components with error boundary\r\n * @param {React.ComponentType} Component - Component to wrap\r\n * @param {ReactNode} fallback - Optional fallback UI\r\n * @returns {React.ComponentType} Wrapped component\r\n */\r\nexport function withErrorBoundary<P extends object>(\r\n  Component: React.ComponentType<P>,\r\n  fallback?: ReactNode\r\n) {\r\n  const WrappedComponent = (props: P) => (\r\n    <ErrorBoundary fallback={fallback}>\r\n      <Component {...props} />\r\n    </ErrorBoundary>\r\n  );\r\n\r\n  // Preserve component name for debugging\r\n  const componentName = Component.displayName || Component.name || 'Component';\r\n  WrappedComponent.displayName = `withErrorBoundary(${componentName})`;\r\n\r\n  return WrappedComponent;\r\n}\r\n\r\n/**\r\n * Global error handler for uncaught errors\r\n */\r\nexport function setupGlobalErrorHandlers(): void {\r\n  // Handle uncaught errors\r\n  window.addEventListener('error', (event) => {\r\n    logger.error('Uncaught error:', {\r\n      message: event.message,\r\n      filename: event.filename,\r\n      lineno: event.lineno,\r\n      colno: event.colno,\r\n      error: event.error,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n\r\n    // Prevent default browser error handling\r\n    event.preventDefault();\r\n  });\r\n\r\n  // Handle unhandled promise rejections\r\n  window.addEventListener('unhandledrejection', (event) => {\r\n    logger.error('Unhandled promise rejection:', {\r\n      reason: event.reason,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n\r\n    // Prevent default browser handling\r\n    event.preventDefault();\r\n  });\r\n\r\n  logger.info('Global error handlers setup complete');\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\folders\\folder-actions-menu.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":9,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState } from 'react';\r\nimport { MoreVertical, Edit, Share2, Trash2 } from 'lucide-react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator } from '@/components/ui/dropdown-menu';\r\nimport { ShareFolderModal } from '@/components/modals/share-folder-modal';\r\n\r\ninterface FolderActionsMenuProps {\r\n  folder: {\r\n    id: string;\r\n    name: string;\r\n    linkCount: number;\r\n    shareable?: boolean;\r\n    shareId?: string | null;\r\n  };\r\n  onEdit: (folderId: string) => void;\r\n  onDelete: (folderId: string) => void;\r\n}\r\n\r\nexport function FolderActionsMenu({ folder, onEdit, onDelete }: FolderActionsMenuProps) {\r\n  const [showShareModal, setShowShareModal] = useState(false);\r\n\r\n  return (\r\n    <>\r\n      <DropdownMenu>\r\n        <DropdownMenuTrigger asChild>\r\n          <Button variant=\"ghost\" size=\"sm\" className=\"h-6 w-6 p-0 hover:bg-accent hover:text-accent-foreground transition-colors duration-200 opacity-0 group-hover/folder:opacity-100 focus:opacity-100\">\r\n            <MoreVertical className=\"h-3.5 w-3.5\" />\r\n            <span className=\"sr-only\">Folder actions</span>\r\n          </Button>\r\n        </DropdownMenuTrigger>\r\n        <DropdownMenuContent align=\"end\" className=\"w-56\">\r\n          <DropdownMenuItem onSelect={() => onEdit(folder.id)}>\r\n            <Edit className=\"h-4 w-4 mr-2\" />\r\n            Edit Folder\r\n          </DropdownMenuItem>\r\n\r\n          <DropdownMenuItem\r\n            onSelect={() => setShowShareModal(true)}\r\n            className=\"text-orange-600 focus:bg-orange-50 focus:text-orange-600\"\r\n          >\r\n            <Share2 className=\"h-4 w-4 mr-2\" />\r\n            {folder.shareable ? 'Manage Sharing' : 'Share Folder'}\r\n          </DropdownMenuItem>\r\n\r\n          <DropdownMenuSeparator />\r\n\r\n          <DropdownMenuItem\r\n            className=\"text-red-600 focus:bg-red-50 focus:text-red-600\"\r\n            onSelect={() => onDelete(folder.id)}\r\n          >\r\n            <Trash2 className=\"h-4 w-4 mr-2\" />\r\n            Delete Folder\r\n          </DropdownMenuItem>\r\n        </DropdownMenuContent>\r\n      </DropdownMenu>\r\n\r\n      <ShareFolderModal\r\n        folder={{\r\n          id: folder.id,\r\n          name: folder.name,\r\n          linkCount: folder.linkCount\r\n        }}\r\n        isOpen={showShareModal}\r\n        onClose={() => setShowShareModal(false)}\r\n      />\r\n    </>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\folders\\folder-tree-item.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":17,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/folders/folder-tree-item.tsx\r\n * @description Recursive folder tree item component for hierarchical display\r\n * @created 2025-10-19\r\n */\r\n\r\n\"use client\";\r\n\r\nimport React, { useState } from \"react\";\r\nimport { ChevronRight, ChevronDown } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Folder } from \"@/types\";\r\nimport { FOLDER_ICONS } from \"@/constants/folder-icons\";\r\nimport { getChildFolders, getSubFolderCount } from \"@/utils/folder-utils\";\r\nimport { FolderActionsMenu } from \"@/components/folders/folder-actions-menu\";\r\n\r\ninterface FolderTreeItemProps {\r\n  /**\r\n   * Folder to display\r\n   */\r\n  folder: Folder;\r\n\r\n  /**\r\n   * All folders for finding children\r\n   */\r\n  allFolders: Folder[];\r\n\r\n  /**\r\n   * Currently selected folder ID\r\n   */\r\n  selectedId: string | null;\r\n\r\n  /**\r\n   * Callback when folder is selected\r\n   */\r\n  onSelect: (folderId: string) => void;\r\n\r\n  /**\r\n   * Current nesting depth (0 = root)\r\n   */\r\n  depth?: number;\r\n\r\n  /**\r\n   * Maximum allowed depth for display\r\n   */\r\n  maxDepth?: number;\r\n\r\n  /**\r\n   * Set of expanded folder IDs\r\n   */\r\n  expandedIds: Set<string>;\r\n\r\n  /**\r\n   * Toggle expand/collapse state\r\n   */\r\n  onToggleExpand: (folderId: string) => void;\r\n\r\n  /**\r\n   * Callback when folder edit is requested\r\n   */\r\n  onEdit?: (folderId: string) => void;\r\n\r\n  /**\r\n   * Callback when folder delete is requested\r\n   */\r\n  onDelete?: (folderId: string) => void;\r\n}\r\n\r\n/**\r\n * Recursive folder tree item component\r\n * Displays a folder with expand/collapse and handles nested children\r\n * \r\n * Features:\r\n * - Recursive nesting with depth tracking\r\n * - Expand/collapse interaction\r\n * - Visual indentation based on depth\r\n * - Font size scaling for deep nesting\r\n * - Sub-folder count display\r\n * \r\n * @example\r\n * <FolderTreeItem\r\n *   folder={folder}\r\n *   allFolders={folders}\r\n *   selectedId={selectedId}\r\n *   onSelect={handleSelect}\r\n *   expandedIds={expandedIds}\r\n *   onToggleExpand={handleToggle}\r\n * />\r\n */\r\nexport function FolderTreeItem({\r\n  folder,\r\n  allFolders,\r\n  selectedId,\r\n  onSelect,\r\n  depth = 0,\r\n  maxDepth = 5,\r\n  expandedIds,\r\n  onToggleExpand,\r\n  onEdit,\r\n  onDelete,\r\n}: FolderTreeItemProps) {\r\n  // Get immediate children of this folder\r\n  const children = getChildFolders(folder.id, allFolders);\r\n  const hasChildren = children.length > 0;\r\n  const isExpanded = expandedIds.has(folder.id);\r\n  const isSelected = selectedId === folder.id;\r\n\r\n  // Calculate indentation (20px per level, max 100px)\r\n  const indentPx = Math.min(depth * 20, 100);\r\n\r\n  // Font size scaling (smaller for deeper levels)\r\n  const fontSize = depth >= 2 ? 'text-xs' : 'text-xs';\r\n\r\n  // Get folder icon\r\n  const folderIconConfig = FOLDER_ICONS.find((icon) => icon.name === folder.icon);\r\n  const FolderIcon = folderIconConfig?.icon;\r\n\r\n  // Get sub-folder count for display\r\n  const subFolderCount = getSubFolderCount(folder.id, allFolders);\r\n\r\n  /**\r\n   * Handles expand/collapse toggle\r\n   */\r\n  const handleToggle = (e: React.MouseEvent) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    onToggleExpand(folder.id);\r\n  };\r\n\r\n  /**\r\n   * Handles folder selection\r\n   */\r\n  const handleSelect = (e: React.MouseEvent) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    onSelect(folder.id);\r\n  };\r\n\r\n  return (\r\n    <div className=\"folder-tree-item\">\r\n      {/* Folder Row */}\r\n      <div\r\n        className={`group/folder flex items-center gap-0.5 py-1 px-1.5 hover:bg-accent/30 rounded transition-colors ${isSelected ? 'bg-accent/50' : ''\r\n          }`}\r\n        style={{ paddingLeft: `${indentPx + 6}px` }}\r\n      >\r\n        {/* Expand/Collapse Button */}\r\n        {hasChildren ? (\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            className=\"h-4 w-4 flex-shrink-0 p-0 hover:bg-transparent\"\r\n            onClick={handleToggle}\r\n            aria-label={isExpanded ? \"Collapse folder\" : \"Expand folder\"}\r\n            aria-expanded={isExpanded}\r\n          >\r\n            {isExpanded ? (\r\n              <ChevronDown className=\"h-3 w-3\" />\r\n            ) : (\r\n              <ChevronRight className=\"h-3 w-3\" />\r\n            )}\r\n          </Button>\r\n        ) : (\r\n          // Spacer for alignment when no children\r\n          <div className=\"h-4 w-4 flex-shrink-0\" />\r\n        )}\r\n\r\n        {/* Folder Button */}\r\n        <button\r\n          onClick={handleSelect}\r\n          className={`flex items-center gap-1.5 flex-1 min-w-0 py-0.5 px-1.5 rounded transition-colors ${fontSize}`}\r\n          aria-label={`Select ${folder.name} folder`}\r\n          aria-pressed={isSelected}\r\n        >\r\n          {/* Folder Icon */}\r\n          {FolderIcon && (\r\n            <FolderIcon\r\n              className=\"h-3.5 w-3.5 flex-shrink-0\"\r\n              style={{ color: folder.color }}\r\n              aria-hidden=\"true\"\r\n            />\r\n          )}\r\n\r\n          {/* Folder Name */}\r\n          <span className=\"truncate text-xs font-medium\">{folder.name}</span>\r\n\r\n          {/* Sub-folder count badge (if has children) */}\r\n          {hasChildren && subFolderCount > 0 && (\r\n            <span className=\"text-[10px] text-muted-foreground flex-shrink-0\">\r\n              ({subFolderCount})\r\n            </span>\r\n          )}\r\n        </button>\r\n\r\n        {/* Actions Menu */}\r\n        {onEdit && onDelete && (\r\n          <FolderActionsMenu\r\n            folder={{\r\n              id: folder.id,\r\n              name: folder.name,\r\n              linkCount: subFolderCount, // This could be enhanced to count actual links\r\n              shareable: !!folder.shareable,\r\n              shareId: folder.shareId || undefined,\r\n            }}\r\n            onEdit={onEdit}\r\n            onDelete={onDelete}\r\n          />\r\n        )}\r\n      </div>\r\n\r\n      {/* Recursive Children (if expanded) */}\r\n      {hasChildren && isExpanded && depth < maxDepth && (\r\n        <div className=\"folder-tree-children\" role=\"group\">\r\n          {children.map((child) => (\r\n            <FolderTreeItem\r\n              key={child.id}\r\n              folder={child}\r\n              allFolders={allFolders}\r\n              selectedId={selectedId}\r\n              onSelect={onSelect}\r\n              depth={depth + 1}\r\n              maxDepth={maxDepth}\r\n              expandedIds={expandedIds}\r\n              onToggleExpand={onToggleExpand}\r\n            />\r\n          ))}\r\n        </div>\r\n      )}\r\n\r\n      {/* Max Depth Warning (if has children but at max depth) */}\r\n      {hasChildren && isExpanded && depth >= maxDepth && (\r\n        <div\r\n          className=\"text-xs text-muted-foreground italic ml-8 py-1\"\r\n          style={{ paddingLeft: `${indentPx + 8}px` }}\r\n        >\r\n          Maximum nesting depth reached\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\folders\\folder-tree-select.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":16,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/folders/folder-tree-select.tsx\r\n * @description Hierarchical folder selector with tree structure\r\n * @created 2025-10-19\r\n */\r\n\r\n\"use client\";\r\n\r\nimport React, { useState, useMemo, useEffect, useRef } from \"react\";\r\nimport { FolderPlus, ChevronDown, ChevronUp } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { FolderTreeItem } from \"./folder-tree-item\";\r\nimport { getRootFolders } from \"@/utils/folder-utils\";\r\n\r\ninterface FolderTreeSelectProps {\r\n  /**\r\n   * Currently selected folder ID\r\n   */\r\n  value: string | null;\r\n\r\n  /**\r\n   * Callback when selection changes\r\n   */\r\n  onChange: (folderId: string | null) => void;\r\n\r\n  /**\r\n   * Optional placeholder text\r\n   */\r\n  placeholder?: string;\r\n\r\n  /**\r\n   * Allow clearing selection\r\n   */\r\n  allowClear?: boolean;\r\n}\r\n\r\n/**\r\n * Hierarchical folder tree selector component\r\n * \r\n * Features:\r\n * - Tree structure with expand/collapse\r\n * - Search/filter functionality\r\n * - Sub-folder count display\r\n * - Visual depth indication\r\n * - Keyboard navigation support\r\n * - Clear selection option\r\n * \r\n * @example\r\n * <FolderTreeSelect\r\n *   value={selectedFolderId}\r\n *   onChange={setSelectedFolderId}\r\n *   allowClear\r\n * />\r\n */\r\nexport function FolderTreeSelectComponent({\r\n  value,\r\n  onChange,\r\n  placeholder = \"Select a folder\",\r\n  allowClear = true,\r\n}: FolderTreeSelectProps) {\r\n  const folders = useStore((state) => state.folders);\r\n  const [isOpen, setIsOpen] = useState(false);\r\n  const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set());\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Close dropdown when clicking outside\r\n  useEffect(() => {\r\n    const handleClickOutside = (event: MouseEvent) => {\r\n      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {\r\n        setIsOpen(false);\r\n      }\r\n    };\r\n\r\n    if (isOpen) {\r\n      document.addEventListener('mousedown', handleClickOutside);\r\n    }\r\n\r\n    return () => {\r\n      document.removeEventListener('mousedown', handleClickOutside);\r\n    };\r\n  }, [isOpen]);\r\n\r\n  /**\r\n   * Toggles expand/collapse state for a folder\r\n   */\r\n  const handleToggleExpand = (folderId: string) => {\r\n    setExpandedIds((prev) => {\r\n      const next = new Set(prev);\r\n      if (next.has(folderId)) {\r\n        next.delete(folderId);\r\n      } else {\r\n        next.add(folderId);\r\n      }\r\n      return next;\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Handles folder selection\r\n   */\r\n  const handleSelect = (folderId: string) => {\r\n    onChange(folderId);\r\n    setIsOpen(false); // Close dropdown after selection\r\n  };\r\n\r\n  // Get root folders\r\n  const rootFolders = useMemo(() => {\r\n    return getRootFolders(folders);\r\n  }, [folders]);\r\n\r\n  // Get selected folder for display\r\n  const selectedFolder = useMemo(() => {\r\n    if (!value) return null;\r\n    return folders.find((f) => f.id === value);\r\n  }, [value, folders]);\r\n\r\n  return (\r\n    <div ref={containerRef} className=\"folder-tree-select relative\">\r\n      {/* Dropdown Trigger with positioning context */}\r\n      <div className=\"relative\">\r\n        <button\r\n          type=\"button\"\r\n          onClick={() => setIsOpen(!isOpen)}\r\n          className={`flex h-8 w-full items-center justify-between rounded-md border border-input bg-background px-2.5 py-1.5 text-sm placeholder:text-muted-foreground focus:outline-none focus-visible:ring-0 disabled:cursor-not-allowed disabled:opacity-50 transition-colors ${isOpen ? 'rounded-b-none border-b-0' : ''}`}\r\n        >\r\n          <span className=\"inline-flex items-center px-1.5 py-0.5 rounded text-xs font-medium bg-muted text-muted-foreground border mr-2\">Folder</span>\r\n          <span className={selectedFolder ? \"text-foreground text-sm flex-1 text-left\" : \"text-muted-foreground text-xs flex-1 text-left\"}>\r\n            {selectedFolder ? selectedFolder.name : \"Select folder (optional)\"}\r\n          </span>\r\n          {isOpen ? (\r\n            <ChevronUp className=\"h-3.5 w-3.5 opacity-50 flex-shrink-0 ml-2\" />\r\n          ) : (\r\n            <ChevronDown className=\"h-3.5 w-3.5 opacity-50 flex-shrink-0 ml-2\" />\r\n          )}\r\n        </button>\r\n\r\n        {/* Dropdown Content - Opens seamlessly above button */}\r\n        {isOpen && (\r\n          <div className=\"absolute bottom-full left-0 right-0 z-50 animate-in slide-in-from-bottom-2 fade-in duration-200\">\r\n            <div className=\"rounded-t-md border border-b-0 bg-popover shadow-md\">\r\n              <div className=\"max-h-[180px] overflow-y-auto overflow-x-hidden py-1 custom-scrollbar animate-in fade-in duration-150 delay-75\">\r\n                {rootFolders.length === 0 ? (\r\n                  <div className=\"flex flex-col items-center justify-center h-24 text-center px-2\">\r\n                    <FolderPlus className=\"size-5 text-muted-foreground mb-1.5\" />\r\n                    <p className=\"text-xs text-muted-foreground\">\r\n                      No folders yet\r\n                    </p>\r\n                  </div>\r\n                ) : (\r\n                  <>\r\n                    {/* None option */}\r\n                    {allowClear && (\r\n                      <button\r\n                        type=\"button\"\r\n                        onClick={() => {\r\n                          onChange(null);\r\n                          setIsOpen(false);\r\n                        }}\r\n                        className=\"w-full text-left px-2 py-1 text-xs rounded hover:bg-accent transition-colors\"\r\n                      >\r\n                        <span className=\"text-muted-foreground italic\">None</span>\r\n                      </button>\r\n                    )}\r\n\r\n                    {/* Folder tree */}\r\n                    <div className=\"space-y-0.5 mt-0.5\" role=\"tree\" aria-label=\"Folder tree\">\r\n                      {rootFolders.map((folder) => (\r\n                        <FolderTreeItem\r\n                          key={folder.id}\r\n                          folder={folder}\r\n                          allFolders={folders}\r\n                          selectedId={value}\r\n                          onSelect={handleSelect}\r\n                          expandedIds={expandedIds}\r\n                          onToggleExpand={handleToggleExpand}\r\n                        />\r\n                      ))}\r\n                    </div>\r\n                  </>\r\n                )}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport const FolderTreeSelect = React.memo(FolderTreeSelectComponent);\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\landing\\landing-page.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":19,"column":30,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/landing/landing-page.tsx\r\n * @description System 2.0 landing page component with architectural/brutalist design\r\n * @created 2025-11-20\r\n */\r\n\r\n'use client';\r\n\r\nimport React from 'react';\r\nimport { useRouter } from 'next/navigation';\r\nimport Image from 'next/image';\r\nimport Link from 'next/link';\r\nimport { ArrowRight, DownloadCloud, Search, FolderInput, Share2, Asterisk, Twitter, Github, Linkedin, Disc } from 'lucide-react';\r\n\r\n/**\r\n * Landing page component for unauthenticated users\r\n * @returns {JSX.Element} Landing page component\r\n */\r\nexport function LandingPage(): React.JSX.Element {\r\n  const router = useRouter();\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-white text-black font-sans selection:bg-[#FF4D00] selection:text-white overflow-x-hidden\">\r\n      {/* Navigation */}\r\n      <nav className=\"fixed w-full z-50 border-b border-gray-200 bg-white/90 backdrop-blur-md\">\r\n        <div className=\"max-w-[1600px] mx-auto px-6 h-20 flex items-center justify-between\">\r\n          {/* Logo Area */}\r\n          <div className=\"flex items-center gap-4\">\r\n            <div className=\"w-4 h-4 bg-[#FF4D00]\"></div>\r\n            <span className=\"font-display font-bold text-2xl tracking-tight uppercase\">LinksVault<span className=\"text-[#FF4D00]\">.</span></span>\r\n          </div>\r\n\r\n          {/* Center Links (Hidden on Mobile) */}\r\n\r\n\r\n          {/* Right Actions */}\r\n          <div className=\"flex items-center gap-6\">\r\n            <Link href=\"/login\" className=\"font-display font-medium hover:text-[#FF4D00] transition\">Login</Link>\r\n            <Link href=\"/login?tab=signup\" className=\"bg-black text-white px-6 py-2.5 font-mono text-xs font-bold uppercase tracking-wider hover:bg-[#FF4D00] transition-colors duration-300\">\r\n              Start Archiving\r\n            </Link>\r\n          </div>\r\n        </div>\r\n      </nav>\r\n\r\n      {/* Hero Section */}\r\n      <header className=\"pt-20 relative min-h-screen flex flex-col\">\r\n        {/* Background Grid */}\r\n        <div className=\"absolute inset-0 z-0 pointer-events-none opacity-50\" style={{\r\n          backgroundImage: `\r\n            linear-gradient(to right, rgba(0, 0, 0, 0.05) 1px, transparent 1px),\r\n            linear-gradient(to bottom, rgba(0, 0, 0, 0.05) 1px, transparent 1px)\r\n          `,\r\n          backgroundSize: '40px 40px'\r\n        }}></div>\r\n\r\n        <div className=\"flex-1 max-w-[1600px] mx-auto w-full px-6 grid grid-cols-1 lg:grid-cols-12 gap-0 h-full z-10 pt-12 lg:pt-20\">\r\n\r\n          {/* Left Column: Typography */}\r\n          <div className=\"col-span-1 lg:col-span-7 flex flex-col justify-between pb-20\">\r\n            <div>\r\n              <div className=\"inline-flex items-center gap-2 border border-black px-3 py-1 rounded-full mb-8 bg-white\">\r\n                <span className=\"w-2 h-2 rounded-full bg-[#FF4D00] animate-pulse\"></span>\r\n                <span className=\"font-mono text-xs uppercase font-bold\">System Operational</span>\r\n              </div>\r\n\r\n              <h1 className=\"font-display text-6xl md:text-8xl lg:text-[6.5rem] font-bold leading-[0.9] tracking-tighter mb-8 uppercase\">\r\n                Archive <br />\r\n                <span className=\"text-transparent\" style={{ WebkitTextStroke: '2px black' }}>The Void</span> <br />\r\n                Into Matter\r\n              </h1>\r\n\r\n              <p className=\"font-sans text-lg md:text-xl text-gray-600 max-w-lg leading-relaxed border-l-2 border-[#FF4D00] pl-6\">\r\n                Constructing your digital memory through parametric organization.\r\n                LinksVault captures URLs, extracts metadata, and builds your personal knowledge graph.\r\n              </p>\r\n            </div>\r\n\r\n            <div className=\"mt-12 flex items-center gap-8\">\r\n              <button\r\n                onClick={() => router.push('/login')}\r\n                className=\"group relative px-8 py-4 bg-[#FF4D00] text-white overflow-hidden\"\r\n              >\r\n                <div className=\"absolute inset-0 w-full h-full bg-black transform translate-y-full transition-transform duration-300 group-hover:translate-y-0\"></div>\r\n                <span className=\"relative font-mono font-bold uppercase text-sm tracking-widest flex items-center gap-2\">\r\n                  Initialize Vault <ArrowRight className=\"w-4 h-4\" />\r\n                </span>\r\n              </button>\r\n              <div className=\"hidden md:block\">\r\n                <span className=\"font-mono text-xs text-gray-400 block mb-1\">// AUTO-FETCH ENABLED</span>\r\n                <span className=\"font-mono text-xs text-gray-400 block\">// SECURE ENCRYPTION</span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Right Column: Illustration */}\r\n          <div className=\"col-span-1 lg:col-span-5 relative mt-12 lg:mt-0 flex flex-col justify-end lg:justify-center\">\r\n            {/* Decorative Circle */}\r\n            <div className=\"absolute top-0 right-0 w-64 h-64 bg-gray-100 rounded-full -z-10 mix-blend-multiply\"></div>\r\n\r\n            {/* The Card Container */}\r\n            <div className=\"relative border border-black bg-white p-2 shadow-[10px_10px_0px_0px_rgba(0,0,0,1)] hover:shadow-[15px_15px_0px_0px_#FF4D00] transition-shadow duration-500\">\r\n              <div className=\"border border-gray-100 bg-gray-50 aspect-square relative overflow-hidden flex items-center justify-center group\">\r\n\r\n                {/* Technical Overlay UI */}\r\n                <div className=\"absolute top-4 left-4 z-20 font-mono text-[10px] flex flex-col gap-1\">\r\n                  <span className=\"bg-black text-white px-1\">FIG 01. INTERFACE</span>\r\n                  <span className=\"bg-[#FF4D00] text-white px-1 opacity-0 group-hover:opacity-100 transition-opacity\">SCANNING...</span>\r\n                </div>\r\n\r\n                {/* User Illustration Image */}\r\n                <div className=\"relative w-4/5 h-4/5 transition-transform duration-700 group-hover:scale-105\">\r\n                  <Image\r\n                    src=\"/hero-illustration.png\"\r\n                    alt=\"Digital Archive Illustration\"\r\n                    fill\r\n                    className=\"object-contain mix-blend-multiply grayscale contrast-125\"\r\n                    priority\r\n                  />\r\n                </div>\r\n              </div>\r\n\r\n              {/* Bottom Label */}\r\n              <div className=\"mt-2 pt-2 border-t border-black flex justify-between items-center font-mono text-xs\">\r\n                <span>INPUT_SOURCE: URL</span>\r\n                <span>STATUS: ACTIVE</span>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Scrolling Marquee Border */}\r\n        <div className=\"border-y border-black bg-black text-white py-3 mt-12 lg:mt-0 overflow-hidden\">\r\n          <div className=\"whitespace-nowrap animate-marquee\">\r\n            <div className=\"inline-block font-mono text-sm uppercase tracking-[0.2em] font-bold\">\r\n              &nbsp; /// Capture Everything /// Organize The Web /// Knowledge Is Power /// Search Logic /// Social Sharing /// Secure Vault /// &nbsp;\r\n              &nbsp; /// Capture Everything /// Organize The Web /// Knowledge Is Power /// Search Logic /// Social Sharing /// Secure Vault /// &nbsp;\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </header>\r\n\r\n      {/* Bento Grid Features Section */}\r\n      <section id=\"functionality\" className=\"py-24 lg:py-32 px-6 max-w-[1600px] mx-auto\">\r\n        <div className=\"flex flex-col md:flex-row justify-between items-end mb-20 border-b border-black pb-6\">\r\n          <h2 className=\"font-display text-5xl md:text-7xl font-bold uppercase tracking-tighter\">\r\n            System<br />Architecture\r\n          </h2>\r\n          <p className=\"font-mono text-sm text-right max-w-xs mt-6 md:mt-0 text-gray-500\">\r\n            // MODULES LOADED<br />\r\n            Optimized structures at every node.\r\n          </p>\r\n        </div>\r\n\r\n        {/* Grid Layout */}\r\n        <div className=\"grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 grid-rows-2 gap-6 h-auto md:h-[800px]\">\r\n\r\n          {/* Feature 1: Auto Fetch */}\r\n          <div className=\"col-span-1 md:col-span-2 row-span-2 border border-black p-8 lg:p-12 bg-gray-50 hover:bg-white transition-colors duration-300 flex flex-col justify-between relative group overflow-hidden\">\r\n            <div className=\"absolute top-0 right-0 p-6\">\r\n              <DownloadCloud className=\"w-10 h-10 opacity-20 group-hover:opacity-100 group-hover:text-[#FF4D00] transition-all\" />\r\n            </div>\r\n            <div className=\"relative z-10 mt-auto flex flex-col h-full\">\r\n              {/* Metadata Image */}\r\n              <div className=\"relative w-full aspect-video mb-6 rounded-lg overflow-hidden border border-gray-200 shadow-sm group-hover:shadow-md transition-all transform md:translate-x-4 md:translate-y-12 translate-y-0 translate-x-0 mt-6 md:mt-0\">\r\n                <Image\r\n                  src=\"/metadata.jpg\"\r\n                  alt=\"Auto-Fetch Metadata Preview\"\r\n                  fill\r\n                  className=\"object-contain bg-white\"\r\n                />\r\n              </div>\r\n\r\n              <div className=\"mt-auto\">\r\n                <h3 className=\"font-display text-4xl font-bold mb-4 uppercase\">Auto-Fetch <br />Metadata</h3>\r\n                <p className=\"font-sans text-gray-600 leading-relaxed max-w-md\">\r\n                  Stop manually typing. Paste a URL and the system automatically extracts the title, description, and cover image.\r\n                </p>\r\n              </div>\r\n            </div>\r\n            {/* Decorative Graphic */}\r\n            <div className=\"absolute top-[10%] left-[10%] w-full h-full border-l border-t border-gray-200 opacity-50 pointer-events-none\"></div>\r\n          </div>\r\n\r\n          {/* Feature 2: Search */}\r\n          <div className=\"col-span-1 bg-black text-white p-8 flex flex-col relative group overflow-hidden\">\r\n            <div className=\"font-mono text-xs text-gray-500 mb-4\">02 // RETRIEVAL</div>\r\n            <h3 className=\"font-display text-2xl font-bold mb-4\">Semantic Search</h3>\r\n            <p className=\"font-sans text-gray-400 text-sm mb-8\">Find content by title, tag, or description context.</p>\r\n\r\n            {/* Search UI Graphic */}\r\n            <div className=\"mt-auto border border-gray-800 rounded bg-gray-900 p-3\">\r\n              <div className=\"flex items-center gap-2 border-b border-gray-700 pb-2 mb-2\">\r\n                <Search className=\"w-4 h-4 text-gray-500\" />\r\n                <span className=\"text-xs text-gray-500 animate-pulse\">query: \"design resources\"</span>\r\n              </div>\r\n              <div className=\"space-y-2\">\r\n                <div className=\"h-2 w-3/4 bg-gray-800 rounded\"></div>\r\n                <div className=\"h-2 w-1/2 bg-gray-800 rounded\"></div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Feature 3: Folders */}\r\n          <div className=\"col-span-1 border border-gray-200 hover:border-black transition-colors p-8 flex flex-col group\">\r\n            <div>\r\n              <div className=\"flex items-center gap-3 mb-4\">\r\n                <h3 className=\"font-display text-2xl font-bold\">Private Vault</h3>\r\n                <Share2 className=\"w-6 h-6 text-[#FF4D00]\" />\r\n              </div>\r\n\r\n              {/* Private Vault Image */}\r\n              <div className=\"relative w-full aspect-[4/3] mb-2 rounded overflow-hidden border border-gray-100\">\r\n                <Image\r\n                  src=\"/Private.jpg\"\r\n                  alt=\"Private Vault Illustration\"\r\n                  fill\r\n                  className=\"object-cover\"\r\n                />\r\n              </div>\r\n            </div>\r\n            <p className=\"text-sm text-gray-600 -mt-1\">\r\n              Your personal corner of the internet. Encrypted, secure, and yours alone.\r\n            </p>\r\n          </div>\r\n\r\n          {/* Feature 4: Sharing */}\r\n          <div className=\"col-span-1 md:col-span-2 border border-black p-8 bg-[#FF4D00] text-white flex flex-col md:flex-row items-center justify-between relative overflow-hidden\">\r\n            <div className=\"relative z-10\">\r\n              <h3 className=\"font-display text-3xl font-bold mb-2 uppercase\">Nested Folders</h3>\r\n              <p className=\"font-sans text-white/90 max-w-sm\">Organize your links in a hierarchical tree structure. Create a taxonomy that fits your mental model.</p>\r\n\r\n              {/* Tree Visualization */}\r\n              <div className=\"mt-6 font-mono text-xs text-white/80 space-y-1\">\r\n                <div className=\"flex items-center gap-2\"><FolderInput className=\"w-3 h-3\" /> /design-resources</div>\r\n                <div className=\"flex items-center gap-2 pl-4\">Γö£ΓöÇ /typography</div>\r\n                <div className=\"flex items-center gap-2 pl-4\">ΓööΓöÇ /inspiration</div>\r\n              </div>\r\n            </div>\r\n            <div className=\"relative z-10 mt-6 md:mt-0\">\r\n              <button\r\n                onClick={() => router.push('/login')}\r\n                className=\"bg-white text-[#FF4D00] px-6 py-3 font-mono text-xs font-bold uppercase hover:bg-black hover:text-white transition-colors\"\r\n              >\r\n                Start Organizing\r\n              </button>\r\n            </div>\r\n            {/* Background Pattern */}\r\n            <div className=\"absolute inset-0 opacity-10\" style={{ backgroundImage: 'radial-gradient(circle, white 2px, transparent 2px)', backgroundSize: '20px 20px' }}></div>\r\n          </div>\r\n\r\n        </div>\r\n      </section>\r\n\r\n      {/* Minimal Statistic/Divider */}\r\n      <section className=\"border-y border-gray-200\">\r\n        <div className=\"max-w-[1600px] mx-auto grid grid-cols-2 md:grid-cols-4 divide-x divide-gray-200\">\r\n          <div className=\"p-8 text-center hover:bg-gray-50 transition\">\r\n            <div className=\"font-display text-4xl font-bold\">0.0s</div>\r\n            <div className=\"font-mono text-xs text-gray-500 uppercase mt-2\">Sync Latency</div>\r\n          </div>\r\n          <div className=\"p-8 text-center hover:bg-gray-50 transition\">\r\n            <div className=\"font-display text-4xl font-bold\">Folder Sharing</div>\r\n            <div className=\"font-mono text-xs text-gray-500 uppercase mt-2\">256-bit Encryption</div>\r\n          </div>\r\n          <div className=\"p-8 text-center hover:bg-gray-50 transition\">\r\n            <div className=\"font-display text-4xl font-bold\">Γê₧</div>\r\n            <div className=\"font-mono text-xs text-gray-500 uppercase mt-2\">Login and access links anywhere</div>\r\n          </div>\r\n          <div className=\"p-8 text-center hover:bg-gray-50 transition\">\r\n            <div className=\"font-display text-4xl font-bold\">Cloud</div>\r\n            <div className=\"font-mono text-xs text-gray-500 uppercase mt-2\">Sync</div>\r\n          </div>\r\n        </div>\r\n      </section>\r\n\r\n      {/* Big CTA Block (Orange) */}\r\n      <section id=\"cta\" className=\"py-32 px-6\">\r\n        <div className=\"max-w-5xl mx-auto bg-black text-white relative overflow-hidden\">\r\n          {/* Orange Accent Block */}\r\n          <div className=\"absolute top-0 right-0 w-full md:w-1/3 h-full bg-[#FF4D00] z-0 block md:hidden lg:block\"></div>\r\n\r\n          <div className=\"relative z-10 grid grid-cols-1 lg:grid-cols-3 min-h-[400px]\">\r\n\r\n            {/* Text Side */}\r\n            <div className=\"col-span-2 p-12 md:p-20 flex flex-col justify-center bg-black\">\r\n              <h2 className=\"font-display text-5xl md:text-6xl font-bold uppercase leading-tight mb-6\">\r\n                Systematic.<br />\r\n                Parametric.<br />\r\n                <span className=\"text-gray-500\">Adaptive.</span>\r\n              </h2>\r\n              <div className=\"flex flex-col md:flex-row gap-4 mt-8\">\r\n                <Link href=\"/login?tab=signup\" className=\"bg-white text-black px-8 py-4 font-mono text-sm font-bold uppercase tracking-widest hover:bg-[#FF4D00] hover:text-white transition-colors text-center\">\r\n                  Sign Up / Access\r\n                </Link>\r\n              </div>\r\n            </div>\r\n\r\n            {/* Graphic Side (The Orange Box) */}\r\n            <div className=\"col-span-1 bg-[#FF4D00] p-12 flex flex-col justify-between text-black\">\r\n              <div className=\"w-12 h-12 border-2 border-black rounded-full flex items-center justify-center animate-spin-slow\">\r\n                <Asterisk className=\"w-6 h-6\" />\r\n              </div>\r\n\r\n              <div>\r\n                <h4 className=\"font-bold text-xl mb-2\">Optimized structures, at every node.</h4>\r\n                <p className=\"font-mono text-xs leading-relaxed opacity-80\">\r\n                  // Where every constraint is met with calculation and every blueprint is a revolution.\r\n                </p>\r\n\r\n                <div className=\"mt-8 flex items-center gap-2\">\r\n                  <span className=\"w-2 h-2 bg-black rounded-full\"></span>\r\n                  <span className=\"font-mono text-[10px] uppercase font-bold\">Status: Operational</span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </section>\r\n\r\n      {/* Footer */}\r\n      {/* Footer */}\r\n      <footer className=\"bg-white py-20 px-6 border-t border-black flex flex-col items-center justify-center text-center\">\r\n        <div className=\"flex items-center gap-4 mb-6\">\r\n          <div className=\"w-4 h-4 bg-[#FF4D00]\"></div>\r\n          <span className=\"font-display font-bold text-2xl tracking-tight uppercase\">LinksVault<span className=\"text-[#FF4D00]\">.</span></span>\r\n        </div>\r\n        <p className=\"font-sans text-gray-500 text-sm\">\r\n          Made for people with too many interests.\r\n        </p>\r\n      </footer>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\layout\\folder-delete-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":26,"column":5,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/layout/folder-delete-modal.tsx\r\n * @description Shared folder delete confirmation modal\r\n * @created 2025-10-28\r\n */\r\n\r\nimport { ConfirmModal } from \"@/components/modals/confirm-modal\";\r\nimport { useFolderActions } from \"@/hooks/use-folder-actions\";\r\n\r\n/**\r\n * Folder delete confirmation modal component.\r\n * Displays appropriate message based on folder content.\r\n * @returns {JSX.Element} Folder delete modal component\r\n */\r\nexport function FolderDeleteModal() {\r\n  const { \r\n    confirmDeleteFolder,\r\n    deleteConfirmOpen,\r\n    setDeleteConfirmOpen,\r\n    folderToDelete,\r\n  } = useFolderActions();\r\n\r\n  return (\r\n    <ConfirmModal\r\n      isOpen={deleteConfirmOpen}\r\n      onClose={() => setDeleteConfirmOpen(false)}\r\n      onConfirm={confirmDeleteFolder}\r\n      title=\"Delete folder?\"\r\n      description={\r\n        folderToDelete\r\n          ? folderToDelete.linkCount > 0\r\n            ? `\"${folderToDelete.name}\" contains ${folderToDelete.linkCount} link${folderToDelete.linkCount > 1 ? 's' : ''}. Links will remain in \"All Links\".`\r\n            : `\"${folderToDelete.name}\" is empty and will be deleted.`\r\n          : \"\"\r\n      }\r\n      confirmText=\"Delete\"\r\n      variant=\"destructive\"\r\n    />\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\layout\\folders-section.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":16,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/layout/folders-section.tsx\r\n * @description Shared folders section component for sidebar navigation\r\n * @created 2025-10-27\r\n */\r\n\r\nimport React from 'react';\r\nimport { Plus } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { FolderItem } from \"./shared-folder-nav\";\r\nimport { FolderSectionSkeleton } from \"@/components/ui/folder-skeleton\";\r\n\r\ninterface FoldersSectionProps {\r\n  onFolderClick?: (folderId: string) => void;\r\n}\r\n\r\n/**\r\n * Folders section component that displays folder list with add button.\r\n * Used in both desktop sidebar and mobile sidebar.\r\n * @param {FoldersSectionProps} props - Component props\r\n * @returns {JSX.Element} Folders section component\r\n */\r\nexport function FoldersSection({ onFolderClick }: FoldersSectionProps) {\r\n  const folders = useStore((state) => state.folders);\r\n  const isLoadingFolders = useStore((state) => state.isLoadingFolders);\r\n  const isHydrated = useStore((state) => state.isHydrated);\r\n  const isLoadingData = useStore((state) => state.isLoadingData);\r\n  const setCreateFolderModalOpen = useStore((state) => state.setCreateFolderModalOpen);\r\n  const setSelectedFolder = useStore((state) => state.setSelectedFolder);\r\n  const setCurrentView = useStore((state) => state.setCurrentView);\r\n\r\n\r\n  const handleFolderClick = (folderId: string) => {\r\n    if (onFolderClick) {\r\n      onFolderClick(folderId);\r\n    } else {\r\n      setCurrentView('all');\r\n      setSelectedFolder(folderId);\r\n    }\r\n  };\r\n\r\n  // Show skeleton loading when:\r\n  // 1. Data is actively loading (NEW: primary condition)\r\n  // 2. Loading folders\r\n  // 3. Not hydrated yet\r\n  // 4. Folders array is empty but we're still in initial loading phase\r\n  if (isLoadingData || isLoadingFolders || !isHydrated || (folders.length === 0 && !isHydrated)) {\r\n    return (\r\n      <FolderSectionSkeleton\r\n        showHeader={true}\r\n        folderCount={10}\r\n        animate={true}\r\n      />\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      {/* Persistent Folder Header - Always visible regardless of loading state */}\r\n      <div className=\"mb-2 flex items-center justify-between\">\r\n        <h4 className=\"text-xs font-semibold text-muted-foreground uppercase tracking-wider\">\r\n          Folders\r\n        </h4>\r\n        <Button\r\n          variant=\"ghost\"\r\n          size=\"icon\"\r\n          className=\"h-7 w-7 hover:bg-primary/10\"\r\n          onClick={() => setCreateFolderModalOpen(true)}\r\n          aria-label=\"Add folder\"\r\n        >\r\n          <Plus className=\"h-4 w-4 text-primary\" />\r\n        </Button>\r\n      </div>\r\n      \r\n      {/* Show folder content - never show empty state during loading */}\r\n      {folders.length > 0 ? (\r\n        <nav className=\"space-y-0.5\">\r\n          {folders.filter(f => f.parentId === null).map((folder) => (\r\n            <FolderItem\r\n              key={folder.id}\r\n              folder={folder}\r\n              onFolderClick={handleFolderClick}\r\n            />\r\n          ))}\r\n        </nav>\r\n      ) : isLoadingData ? (\r\n        // Show skeleton loading for folder items when data is loading\r\n        <FolderSectionSkeleton\r\n          showHeader={false} // Don't show header skeleton since we have persistent header\r\n          folderCount={10}\r\n          animate={true}\r\n        />\r\n      ) : (\r\n        // Only show empty state when loading is complete and no folders exist\r\n        <div className=\"text-sm text-muted-foreground py-4 text-center\">\r\n          No folders yet. Create your first folder to organize your links.\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\layout\\header.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":48,"column":5,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/layout/header.tsx\r\n * @description Main application header\r\n * @created 2025-10-18\r\n */\r\n\r\nimport { Plus, Settings, User, LogOut, Loader2 } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { MobileSidebar } from \"@/components/layout/mobile-sidebar\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport React, { useState } from \"react\";\r\nimport { LazySettingsModal } from \"@/components/lazy\";\r\nimport { usePerformanceMonitor } from \"@/hooks/use-performance-monitor\";\r\nimport {\r\n  DropdownMenu,\r\n  DropdownMenuContent,\r\n  DropdownMenuItem,\r\n  DropdownMenuLabel,\r\n  DropdownMenuSeparator,\r\n  DropdownMenuTrigger,\r\n} from \"@/components/ui/dropdown-menu\";\r\nimport { useAuth } from \"@/lib/contexts/auth-context\";\r\nimport { useLogout } from \"@/hooks/use-logout\";\r\nimport { ProfileModal } from \"@/components/modals/profile-modal\";\r\n\r\nexport function Header() {\r\n  const setAddLinkModalOpen = useStore((state) => state.setAddLinkModalOpen);\r\n  const [isSettingsOpen, setIsSettingsOpen] = useState(false);\r\n  const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);\r\n  const { user } = useAuth();\r\n  const { handleLogout, isLoggingOut } = useLogout();\r\n\r\n  // Get display name or fallback\r\n  const displayName = user?.profile?.display_name || user?.email?.split('@')[0] || 'User';\r\n  const userInitials = displayName.charAt(0).toUpperCase();\r\n\r\n  // Performance monitoring\r\n  const { trackMetric, trackInteraction, trackError } = usePerformanceMonitor({\r\n    componentName: 'Header',\r\n    trackRenders: false,\r\n    trackInteractions: true,\r\n    trackErrors: true\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <header className=\"sticky top-0 z-50 w-full border-b border-border/40 bg-background/95 backdrop-blur-md supports-[backdrop-filter]:bg-background/80 shadow-sm\">\r\n        <div className=\"flex h-16 sm:h-18 items-center gap-3 sm:gap-4 px-4 sm:px-6 lg:px-8\">\r\n          {/* Mobile Menu Button */}\r\n          <MobileSidebar />\r\n\r\n          {/* Logo - Hidden on mobile, shown on desktop */}\r\n          <div className=\"hidden md:flex items-center gap-2.5\">\r\n            <div className=\"flex h-9 w-9 items-center justify-center rounded-lg bg-primary text-primary-foreground shadow-sm\">\r\n              <span className=\"text-lg font-bold\">L</span>\r\n            </div>\r\n            <span className=\"text-lg font-semibold tracking-tight text-foreground\">\r\n              LinksVault\r\n            </span>\r\n          </div>\r\n\r\n          {/* Spacer - Flexible */}\r\n          <div className=\"flex-1\" />\r\n\r\n          {/* Actions */}\r\n          <div className=\"flex items-center gap-2 sm:gap-3\">\r\n            {/* Add Link - Hidden on mobile (FAB available) */}\r\n            <Button\r\n              onClick={() => setAddLinkModalOpen(true)}\r\n              className=\"hidden md:flex gap-2 h-10 px-4 text-sm font-medium shadow-sm hover:shadow-md transition-shadow\"\r\n            >\r\n              <Plus className=\"h-4 w-4\" />\r\n              <span className=\"hidden lg:inline\">Add Link</span>\r\n            </Button>\r\n\r\n            {/* Profile Dropdown */}\r\n            <DropdownMenu>\r\n              <DropdownMenuTrigger asChild>\r\n                <Button\r\n                  variant=\"ghost\"\r\n                  className=\"relative h-10 w-10 rounded-full p-0 hover:bg-transparent\"\r\n                >\r\n                  <div className=\"flex h-9 w-9 items-center justify-center rounded-full bg-primary text-primary-foreground text-sm font-semibold shadow-sm ring-2 ring-background transition-transform hover:scale-105\">\r\n                    {userInitials}\r\n                  </div>\r\n                </Button>\r\n              </DropdownMenuTrigger>\r\n              <DropdownMenuContent align=\"end\" className=\"w-56\">\r\n                <DropdownMenuLabel className=\"font-normal\">\r\n                  <div className=\"flex flex-col space-y-1\">\r\n                    <p className=\"text-sm font-medium leading-none\">{displayName}</p>\r\n                    <p className=\"text-xs leading-none text-muted-foreground\">\r\n                      {user?.email}\r\n                    </p>\r\n                  </div>\r\n                </DropdownMenuLabel>\r\n                <DropdownMenuSeparator />\r\n                <DropdownMenuItem onClick={() => setIsProfileModalOpen(true)} className=\"cursor-pointer\">\r\n                  <User className=\"mr-2 h-4 w-4\" />\r\n                  <span>My Profile</span>\r\n                </DropdownMenuItem>\r\n                <DropdownMenuItem onClick={() => setIsSettingsOpen(true)} className=\"cursor-pointer\">\r\n                  <Settings className=\"mr-2 h-4 w-4\" />\r\n                  <span>Settings</span>\r\n                </DropdownMenuItem>\r\n                <DropdownMenuSeparator />\r\n                <DropdownMenuItem\r\n                  onClick={handleLogout}\r\n                  disabled={isLoggingOut}\r\n                  className=\"cursor-pointer text-red-600 focus:text-red-600 focus:bg-red-50 dark:focus:bg-red-950/20\"\r\n                >\r\n                  {isLoggingOut ? (\r\n                    <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\r\n                  ) : (\r\n                    <LogOut className=\"mr-2 h-4 w-4\" />\r\n                  )}\r\n                  <span>{isLoggingOut ? 'Logging out...' : 'Log out'}</span>\r\n                </DropdownMenuItem>\r\n              </DropdownMenuContent>\r\n            </DropdownMenu>\r\n          </div>\r\n        </div>\r\n      </header>\r\n\r\n      {isSettingsOpen && (\r\n        <React.Suspense fallback={<div className=\"sr-only\">Loading settings...</div>}>\r\n          <LazySettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />\r\n        </React.Suspense>\r\n      )}\r\n\r\n      {/* Profile Modal */}\r\n      <ProfileModal\r\n        isOpen={isProfileModalOpen}\r\n        onClose={() => setIsProfileModalOpen(false)}\r\n      />\r\n    </>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\layout\\mobile-sidebar.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":18,"column":38,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Sheet, SheetContent, SheetHeader, SheetTitle, SheetDescription, SheetClose } from '@/components/ui/sheet';\r\nimport { ScrollArea } from '@/components/ui/scroll-area';\r\nimport { Menu, PanelLeftClose } from 'lucide-react';\r\nimport { useAuth } from '@/lib/contexts/auth-context';\r\nimport { useStore } from '@/store/useStore';\r\nimport { QuickAccessSection } from './quick-access-section';\r\nimport { FoldersSection } from './folders-section';\r\nimport { FolderDeleteModal } from './folder-delete-modal';\r\n\r\nexport function MobileSidebar() {\r\n  const [isOpen, setIsOpen] = React.useState(false);\r\n  const { user } = useAuth();\r\n  const setSelectedFolder = useStore((state) => state.setSelectedFolder);\r\n  const setCurrentView = useStore((state) => state.setCurrentView);\r\n\r\n  const handleFolderClick = (folderId: string) => {\r\n    setCurrentView('all');\r\n    setSelectedFolder(folderId);\r\n    setIsOpen(false);\r\n  };\r\n\r\n  const handleViewClick = (view: 'all' | 'favorites' | 'trash') => {\r\n    setCurrentView(view);\r\n    setSelectedFolder(null);\r\n    setIsOpen(false);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Button\r\n        variant=\"ghost\"\r\n        size=\"icon\"\r\n        className=\"md:hidden focus:outline-none focus-visible:ring-0\"\r\n        onClick={() => setIsOpen(true)}\r\n        aria-label=\"Open menu\"\r\n      >\r\n        <Menu className=\"size-5\" />\r\n      </Button>\r\n\r\n      <Sheet open={isOpen} onOpenChange={setIsOpen}>\r\n        <SheetContent side=\"left\" className=\"w-72 p-0 [&>button]:hidden\">\r\n          <SheetHeader className=\"p-4 border-b flex flex-row items-center justify-between space-y-0\">\r\n            <SheetTitle>\r\n              <div className=\"flex items-center gap-2\">\r\n                <div className=\"flex h-8 w-8 items-center justify-center rounded-lg bg-primary text-primary-foreground\">\r\n                  <span className=\"text-lg font-bold\">L</span>\r\n                </div>\r\n                <span className=\"text-lg font-semibold\">LinksVault</span>\r\n              </div>\r\n            </SheetTitle>\r\n            <SheetClose asChild>\r\n              <Button variant=\"ghost\" size=\"icon\" className=\"h-8 w-8\">\r\n                <PanelLeftClose className=\"h-5 w-5\" />\r\n                <span className=\"sr-only\">Close sidebar</span>\r\n              </Button>\r\n            </SheetClose>\r\n            <SheetDescription className=\"sr-only\">\r\n              Navigation menu for LinksVault\r\n            </SheetDescription>\r\n          </SheetHeader>\r\n\r\n          <div className=\"flex flex-col h-[calc(100vh-80px)]\">\r\n            <div className=\"p-4 pb-0\">\r\n              {/* Quick Access - Pinned */}\r\n              <QuickAccessSection onViewClick={handleViewClick} />\r\n            </div>\r\n\r\n            <ScrollArea className=\"flex-1\">\r\n              <div className=\"px-4 pb-4 space-y-1\">\r\n                {/* Folders - Scrollable */}\r\n                <FoldersSection onFolderClick={handleFolderClick} />\r\n              </div>\r\n            </ScrollArea>\r\n          </div>\r\n        </SheetContent>\r\n      </Sheet>\r\n\r\n      {/* Folder Delete Confirmation Modal */}\r\n      <FolderDeleteModal />\r\n    </>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\layout\\quick-access-section.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":12,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/layout/quick-access-section.tsx\r\n * @description Quick access navigation section component\r\n * @created 2025-10-28\r\n */\r\n\r\nimport { QuickAccessNav } from \"./shared-folder-nav\";\r\nimport { useLinkCounts } from \"@/hooks/use-link-counts\";\r\n\r\ninterface QuickAccessSectionProps {\r\n  onViewClick?: (view: 'all' | 'favorites' | 'trash') => void;\r\n}\r\n\r\n/**\r\n * Quick Access section with navigation for All Links, Favorites, and Trash.\r\n * @param {QuickAccessSectionProps} props - Component props\r\n * @returns {JSX.Element} Quick access section component\r\n */\r\nexport function QuickAccessSection({ onViewClick }: QuickAccessSectionProps) {\r\n  const { allLinksCount, favoritesCount, trashCount } = useLinkCounts();\r\n\r\n  return (\r\n    <div>\r\n      <QuickAccessNav\r\n        allLinksCount={allLinksCount}\r\n        favoritesCount={favoritesCount}\r\n        trashCount={trashCount}\r\n        onViewClick={onViewClick}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\layout\\shared-folder-nav.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":28,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/layout/shared-folder-nav.tsx\r\n * @description Shared folder navigation component for sidebar and mobile sidebar\r\n * @created 2025-10-27\r\n */\r\n\r\nimport * as React from \"react\";\r\nimport { MoreVertical, Edit, Trash, ChevronRight, ChevronDown, FolderPlus, Share2 } from \"lucide-react\";\r\nimport { FOLDER_ICONS } from \"@/constants/folder-icons\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Tooltip,\r\n  TooltipContent,\r\n  TooltipProvider,\r\n  TooltipTrigger,\r\n} from \"@/components/ui/tooltip\";\r\nimport {\r\n  DropdownMenu,\r\n  DropdownMenuContent,\r\n  DropdownMenuItem,\r\n  DropdownMenuTrigger,\r\n} from \"@/components/ui/dropdown-menu\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { useFolderActions } from \"@/hooks/use-folder-actions\";\r\n\r\ninterface FolderItemProps {\r\n  folder: any;\r\n  isSubFolder?: boolean;\r\n  onFolderClick?: (folderId: string) => void;\r\n}\r\n\r\n/**\r\n * Renders a single folder item with navigation, expansion, and actions\r\n */\r\nexport function FolderItem({ folder, isSubFolder = false, onFolderClick }: FolderItemProps) {\r\n  const selectedFolderId = useStore((state) => state.selectedFolderId);\r\n  const currentView = useStore((state) => state.currentView);\r\n  const folders = useStore((state) => state.folders);\r\n  const expandedFolders = useStore((state) => state.expandedFolders);\r\n  const toggleFolderExpanded = useStore((state) => state.toggleFolderExpanded);\r\n\r\n  const {\r\n    handleEditFolder,\r\n    handleAddSubFolder,\r\n    handleDeleteFolder,\r\n    getFolderCount,\r\n  } = useFolderActions();\r\n\r\n  // Share modal state\r\n  const isShareFolderModalOpen = useStore((state) => state.isShareFolderModalOpen);\r\n  const setShareFolderModalOpen = useStore((state) => state.setShareFolderModalOpen);\r\n  const setFolderToShare = useStore((state) => state.setFolderToShare);\r\n\r\n  const IconOption = FOLDER_ICONS.find(icon => icon.name === folder.icon);\r\n  const FolderIcon = IconOption?.icon || FOLDER_ICONS[15].icon;\r\n  const iconColor = IconOption?.color || folder.color;\r\n  const subFolders = folders.filter(f => f.parentId === folder.id);\r\n  const hasSubFolders = subFolders.length > 0 && !isSubFolder;\r\n  const isExpanded = expandedFolders.has(folder.id);\r\n\r\n  const handleClick = () => {\r\n    if (onFolderClick) {\r\n      onFolderClick(folder.id);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className={`group relative ${isSubFolder ? 'h-8' : 'h-8'}`}>\r\n        {/* Chevron Button */}\r\n        {hasSubFolders && (\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            className={`absolute left-0 top-0 ${isSubFolder ? 'h-8' : 'h-8'} w-6 shrink-0 z-20`}\r\n            onClick={(e) => {\r\n              e.stopPropagation();\r\n              toggleFolderExpanded(folder.id);\r\n            }}\r\n          >\r\n            {isExpanded ? (\r\n              <ChevronDown className=\"h-3.5 w-3.5 text-muted-foreground\" />\r\n            ) : (\r\n              <ChevronRight className=\"h-3.5 w-3.5 text-muted-foreground\" />\r\n            )}\r\n          </Button>\r\n        )}\r\n\r\n        {/* Main Folder Button */}\r\n        <TooltipProvider delayDuration={500}>\r\n          <Tooltip>\r\n            <TooltipTrigger asChild>\r\n              <Button\r\n                variant={selectedFolderId === folder.id && currentView === 'all' ? \"secondary\" : \"ghost\"}\r\n                className={`absolute ${hasSubFolders ? 'left-6' : 'left-0'} top-0 ${isSubFolder ? 'h-8' : 'h-8'} justify-start active:scale-[0.98] transition-transform`}\r\n                style={{ width: hasSubFolders ? 'calc(100% - 24px - 60px)' : 'calc(100% - 60px)' }}\r\n                onClick={handleClick}\r\n              >\r\n                <div className=\"flex items-center gap-1.5 min-w-0 w-full\">\r\n                  <FolderIcon\r\n                    className={`${isSubFolder ? 'h-3 w-3' : 'h-3.5 w-3.5'} shrink-0`}\r\n                    style={{ color: iconColor }}\r\n                  />\r\n                  <span className={`truncate ${isSubFolder ? 'text-xs' : 'text-xs'}`}>{folder.name}</span>\r\n                </div>\r\n              </Button>\r\n            </TooltipTrigger>\r\n            {folder.name.length > (isSubFolder ? 18 : 20) && (\r\n              <TooltipContent side=\"right\" className=\"max-w-xs\">\r\n                <p>{folder.name}</p>\r\n              </TooltipContent>\r\n            )}\r\n          </Tooltip>\r\n        </TooltipProvider>\r\n\r\n        {/* Count Badge - Fixed Position */}\r\n        <div className={`absolute right-8 top-0 ${isSubFolder ? 'h-8' : 'h-8'} flex items-center pointer-events-none z-30`}>\r\n          <span className=\"text-[11px] text-muted-foreground font-medium\">{getFolderCount(folder.id)}</span>\r\n        </div>\r\n\r\n        {/* Three-Dots Menu - Fixed Position */}\r\n        <div className={`absolute right-0 top-0 ${isSubFolder ? 'h-8' : 'h-8'} flex items-center opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-opacity z-40`}>\r\n          <DropdownMenu>\r\n            <DropdownMenuTrigger asChild>\r\n              <Button\r\n                variant=\"ghost\"\r\n                size=\"icon\"\r\n                className={isSubFolder ? 'h-7 w-7' : 'h-7 w-7'}\r\n                onClick={(e) => e.stopPropagation()}\r\n              >\r\n                <MoreVertical className=\"size-4\" />\r\n                <span className=\"sr-only\">Folder options</span>\r\n              </Button>\r\n            </DropdownMenuTrigger>\r\n            <DropdownMenuContent align=\"end\">\r\n              {!isSubFolder && (\r\n                <DropdownMenuItem onSelect={() => handleAddSubFolder(folder.id)}>\r\n                  <FolderPlus className=\"mr-2 size-4\" />\r\n                  Add Sub-folder\r\n                </DropdownMenuItem>\r\n              )}\r\n              <DropdownMenuItem onSelect={() => handleEditFolder(folder.id)}>\r\n                <Edit className=\"mr-2 size-4\" />\r\n                Edit\r\n              </DropdownMenuItem>\r\n              <DropdownMenuItem\r\n                className=\"text-orange-600\"\r\n                onSelect={() => {\r\n                  // Set the folder to share and open the modal\r\n                  setFolderToShare({\r\n                    id: folder.id,\r\n                    name: folder.name,\r\n                    linkCount: getFolderCount(folder.id)\r\n                  });\r\n                  setShareFolderModalOpen(true);\r\n                }}\r\n              >\r\n                <Share2 className=\"mr-2 size-4\" />\r\n                Share\r\n              </DropdownMenuItem>\r\n              <DropdownMenuItem\r\n                className=\"text-destructive\"\r\n                onSelect={() => handleDeleteFolder(folder.id, folder.name)}\r\n              >\r\n                <Trash className=\"mr-2 size-4\" />\r\n                Delete\r\n              </DropdownMenuItem>\r\n            </DropdownMenuContent>\r\n          </DropdownMenu>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Sub-folders */}\r\n      {hasSubFolders && isExpanded && (\r\n        <div className=\"ml-6 mt-0.5 space-y-0.5 border-l-2 border-border pl-2\">\r\n          {subFolders.map((subFolder) => (\r\n            <FolderItem\r\n              key={subFolder.id}\r\n              folder={subFolder}\r\n              isSubFolder={true}\r\n              onFolderClick={onFolderClick}\r\n            />\r\n          ))}\r\n        </div>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\ninterface QuickAccessNavProps {\r\n  allLinksCount: number;\r\n  favoritesCount: number;\r\n  trashCount: number;\r\n  onViewClick?: (view: 'all' | 'favorites' | 'trash') => void;\r\n}\r\n\r\n/**\r\n * Renders quick access navigation buttons (All Links, Favorites, Trash)\r\n */\r\nexport function QuickAccessNav({ allLinksCount, favoritesCount, trashCount, onViewClick }: QuickAccessNavProps) {\r\n  const { Star, Trash2, Folder } = require(\"lucide-react\");\r\n  const currentView = useStore((state) => state.currentView);\r\n  const selectedFolderId = useStore((state) => state.selectedFolderId);\r\n  const setCurrentView = useStore((state) => state.setCurrentView);\r\n  const setSelectedFolder = useStore((state) => state.setSelectedFolder);\r\n\r\n  const handleViewClick = (view: 'all' | 'favorites' | 'trash') => {\r\n    if (onViewClick) {\r\n      onViewClick(view);\r\n    } else {\r\n      setCurrentView(view);\r\n      setSelectedFolder(null);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <nav className=\"space-y-1\">\r\n      <Button\r\n        variant={currentView === 'all' && selectedFolderId === null ? \"secondary\" : \"ghost\"}\r\n        className=\"w-full justify-between gap-2 h-8 px-2 active:scale-[0.98] transition-transform\"\r\n        onClick={() => handleViewClick('all')}\r\n      >\r\n        <div className=\"flex items-center gap-2\">\r\n          <Folder className=\"size-4\" />\r\n          <span className=\"text-xs md:text-sm\">All Links</span>\r\n        </div>\r\n        <span className=\"text-[10px] text-muted-foreground\">{allLinksCount}</span>\r\n      </Button>\r\n      <Button\r\n        variant={currentView === 'favorites' ? \"secondary\" : \"ghost\"}\r\n        className=\"w-full justify-between gap-2 h-8 px-2 active:scale-[0.98] transition-transform\"\r\n        onClick={() => handleViewClick('favorites')}\r\n      >\r\n        <div className=\"flex items-center gap-2\">\r\n          <Star className=\"size-4\" />\r\n          <span className=\"text-xs md:text-sm\">Favorites</span>\r\n        </div>\r\n        <span className=\"text-[10px] text-muted-foreground\">{favoritesCount}</span>\r\n      </Button>\r\n      <Button\r\n        variant={currentView === 'trash' ? \"secondary\" : \"ghost\"}\r\n        className=\"w-full justify-between gap-2 h-8 px-2 active:scale-[0.98] transition-transform\"\r\n        onClick={() => handleViewClick('trash')}\r\n      >\r\n        <div className=\"flex items-center gap-2\">\r\n          <Trash2 className=\"size-4\" />\r\n          <span className=\"text-xs md:text-sm\">Trash</span>\r\n        </div>\r\n        <span className=\"text-[10px] text-muted-foreground\">{trashCount}</span>\r\n      </Button>\r\n    </nav>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\layout\\sidebar.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":12,"column":5,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from \"react\";\r\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\r\nimport { QuickAccessSection } from \"./quick-access-section\";\r\nimport { FoldersSection } from \"./folders-section\";\r\nimport { FolderDeleteModal } from \"./folder-delete-modal\";\r\nimport { useAuth } from \"@/lib/contexts/auth-context\";\r\n\r\nexport function Sidebar() {\r\n  const { user } = useAuth();\r\n\r\n  return (\r\n    <>\r\n      <aside className=\"hidden md:flex w-64 lg:w-72 max-w-72 flex-col border-r border-border/40 bg-background/50 backdrop-blur-sm\">\r\n        <div className=\"p-4 lg:p-5 pb-0\">\r\n          {/* Quick Access Section - Pinned to top */}\r\n          <QuickAccessSection />\r\n        </div>\r\n\r\n        <ScrollArea className=\"flex-1\">\r\n          <div className=\"px-4 lg:px-5 pb-2 space-y-2\">\r\n            {/* Folders Section - Scrollable */}\r\n            <FoldersSection />\r\n          </div>\r\n        </ScrollArea>\r\n      </aside>\r\n\r\n      {/* Folder Delete Confirmation Modal */}\r\n      <FolderDeleteModal />\r\n    </>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\lazy\\index.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":85,"column":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/lazy/index.ts\r\n * @description Lazy-loaded components for better performance and reduced bundle size\r\n * @created 2025-01-27\r\n * @optimized 2025-11-09 - Bundle optimization\r\n */\r\n\r\nimport React, { lazy, ReactNode } from 'react';\r\n\r\n// Lazy load heavy modal components to reduce initial bundle size\r\nexport const LazyAddLinkModal = lazy(() => \r\n  import('@/components/modals/add-link-modal').then(module => ({ \r\n    default: module.AddLinkModal \r\n  }))\r\n);\r\n\r\nexport const LazySettingsModal = lazy(() => \r\n  import('@/components/modals/settings-modal').then(module => ({ \r\n    default: module.SettingsModal \r\n  }))\r\n);\r\n\r\nexport const LazyBulkMoveModal = lazy(() => \r\n  import('@/components/modals/bulk-move-modal').then(module => ({ \r\n    default: module.BulkMoveModal \r\n  }))\r\n);\r\n\r\nexport const LazyBulkDeleteModal = lazy(() => \r\n  import('@/components/modals/bulk-delete-modal').then(module => ({ \r\n    default: module.BulkDeleteModal \r\n  }))\r\n);\r\n\r\nexport const LazyCreateFolderModal = lazy(() => \r\n  import('@/components/modals/create-folder-modal').then(module => ({ \r\n    default: module.CreateFolderModal \r\n  }))\r\n);\r\n\r\nexport const LazyEmptyTrashModal = lazy(() => \r\n  import('@/components/modals/empty-trash-modal').then(module => ({ \r\n    default: module.EmptyTrashModal \r\n  }))\r\n);\r\n\r\nexport const LazyRestoreAllModal = lazy(() => \r\n  import('@/components/modals/restore-all-modal').then(module => ({ \r\n    default: module.RestoreAllModal \r\n  }))\r\n);\r\n\r\nexport const LazyConfirmModal = lazy(() => \r\n  import('@/components/modals/confirm-modal').then(module => ({ \r\n    default: module.ConfirmModal \r\n  }))\r\n);\r\n\r\nexport const LazyProfileModal = lazy(() => \r\n  import('@/components/modals/profile-modal').then(module => ({ \r\n    default: module.ProfileModal \r\n  }))\r\n);\r\n\r\n// Lazy load heavy UI components\r\nexport const LazyFolderDeleteModal = lazy(() => \r\n  import('@/components/layout/folder-delete-modal').then(module => ({ \r\n    default: module.FolderDeleteModal \r\n  }))\r\n);\r\n\r\n// Lazy load complex folder tree component\r\nexport const LazyFolderTreeSelect = lazy(() => \r\n  import('@/components/folders/folder-tree-select').then(module => ({ \r\n    default: module.FolderTreeSelect \r\n  }))\r\n);\r\n\r\n// imports removed - already defined above\r\n\r\n// Wrapper component for lazy loading with loading states\r\nexport function LazyComponent({\r\n  children,\r\n  fallback = null\r\n}: {\r\n  children: ReactNode;\r\n  fallback?: ReactNode;\r\n}) {\r\n  return React.createElement(React.Fragment, null, children || fallback);\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\lazy\\lazy-modal-wrapper.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":11,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/lazy/lazy-modal-wrapper.tsx\r\n * @description Wrapper component for lazy-loaded modals with Suspense\r\n * @created 2025-01-27\r\n */\r\n\r\nimport React, { Suspense } from 'react';\r\nimport { Dialog, DialogContent } from '@/components/ui/dialog';\r\nimport { Loader2 } from 'lucide-react';\r\n\r\ninterface LazyModalWrapperProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\n/**\r\n * Loading fallback component for lazy-loaded modals\r\n * @returns {JSX.Element} Loading spinner in modal format\r\n */\r\nfunction ModalLoadingFallback() {\r\n  return (\r\n    <DialogContent className=\"sm:max-w-[425px]\">\r\n      <div className=\"flex items-center justify-center py-8\">\r\n        <Loader2 className=\"size-8 animate-spin-gpu text-muted-foreground\" />\r\n        <span className=\"ml-2 text-sm text-muted-foreground\">Loading...</span>\r\n      </div>\r\n    </DialogContent>\r\n  );\r\n}\r\n\r\n/**\r\n * Wrapper component for lazy-loaded modals with Suspense boundary\r\n * @param isOpen - Whether the modal is open\r\n * @param onClose - Function to close the modal\r\n * @param children - Lazy-loaded modal component\r\n * @param className - Additional CSS classes\r\n * @returns {JSX.Element} Modal wrapper with loading state\r\n */\r\nexport function LazyModalWrapper({\r\n  isOpen,\r\n  onClose,\r\n  children,\r\n  className\r\n}: LazyModalWrapperProps) {\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <Suspense fallback={<ModalLoadingFallback />}>\r\n        {children}\r\n      </Suspense>\r\n    </Dialog>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\links\\folder-badge.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":20,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/links/folder-badge.tsx\r\n * @description Folder badge component for link cards - shows folder icon with tooltip\r\n * @created 2025-10-18\r\n */\r\n\r\n\"use client\";\r\n\r\nimport { Folder as FolderIcon } from \"lucide-react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Tooltip,\r\n  TooltipContent,\r\n  TooltipProvider,\r\n  TooltipTrigger,\r\n} from \"@/components/ui/tooltip\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { FOLDER_ICONS } from \"@/constants/folder-icons\";\r\n\r\ninterface FolderBadgeProps {\r\n  /**\r\n   * ID of the folder to display\r\n   */\r\n  folderId: string | null;\r\n  \r\n  /**\r\n   * Optional click handler - navigates to folder by default\r\n   */\r\n  onClick?: (folderId: string) => void;\r\n  \r\n  /**\r\n   * Optional class name for custom styling\r\n   */\r\n  className?: string;\r\n}\r\n\r\n/**\r\n * Displays a folder icon badge with tooltip showing folder name\r\n * Clicking navigates to the folder view\r\n * \r\n * @example\r\n * <FolderBadge folderId={link.folderId} />\r\n */\r\nexport function FolderBadge({ folderId, onClick, className = \"\" }: FolderBadgeProps) {\r\n  const folders = useStore((state) => state.folders);\r\n  const setSelectedFolder = useStore((state) => state.setSelectedFolder);\r\n  const setCurrentView = useStore((state) => state.setCurrentView);\r\n\r\n  // Don't render if no folder ID\r\n  if (!folderId) {\r\n    return null;\r\n  }\r\n\r\n  // Find the folder\r\n  const folder = folders.find((f) => f.id === folderId);\r\n\r\n  // Don't render if folder not found (defensive check)\r\n  if (!folder) {\r\n    return null;\r\n  }\r\n\r\n  // Get the folder icon component\r\n  const folderIconConfig = FOLDER_ICONS.find((icon) => icon.name === folder.icon);\r\n  const IconComponent = folderIconConfig?.icon || FolderIcon;\r\n\r\n  /**\r\n  * Handles a folder badge click, preventing default behavior and delegating action.\r\n  * @example\r\n  * handleFolderBadgeClick(event)\r\n  * // Navigates to the clicked folder or calls custom onClick\r\n  * @param {React.MouseEvent} event - The click event associated with the folder badge.\r\n  * @returns {void} No return value; performs navigation or custom callback.\r\n  **/\r\n  const handleClick = (e: React.MouseEvent) => {\r\n    e.preventDefault();\r\n    e.stopPropagation(); // Don't trigger card click\r\n    \r\n    if (onClick) {\r\n      onClick(folderId);\r\n    } else {\r\n      // Default behavior: navigate to folder\r\n      setCurrentView('all');\r\n      setSelectedFolder(folderId);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <TooltipProvider delayDuration={300}>\r\n      <Tooltip>\r\n        <TooltipTrigger asChild>\r\n          <Button\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            className={`h-6 w-6 ${className}`}\r\n            onClick={handleClick}\r\n            aria-label={`Go to ${folder.name} folder`}\r\n          >\r\n            <IconComponent\r\n              className=\"h-4 w-4\"\r\n              style={{ color: folder.color }}\r\n              aria-hidden=\"true\"\r\n            />\r\n          </Button>\r\n        </TooltipTrigger>\r\n        <TooltipContent side=\"top\" className=\"text-xs\">\r\n          <p>{folder.name}</p>\r\n        </TooltipContent>\r\n      </Tooltip>\r\n    </TooltipProvider>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\links\\link-card.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":40,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/links/link-card.tsx\r\n * @description Link card component for grid view with subtle animations\r\n * @author LinksVault Team\r\n * @created 2025-10-18\r\n * @modified 2025-10-19\r\n */\r\n\r\n\"use client\";\r\n\r\nimport React, { useState } from \"react\";\r\nimport Image from \"next/image\";\r\nimport { Star, MoreVertical, Edit, Trash, Link as LinkIcon, RotateCcw, Copy, CheckSquare } from \"lucide-react\";\r\nimport { Card, CardContent } from \"@/components/ui/card\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { ConfirmModal } from \"@/components/modals/confirm-modal\";\r\nimport {\r\n  DropdownMenu,\r\n  DropdownMenuContent,\r\n  DropdownMenuItem,\r\n  DropdownMenuSeparator,\r\n  DropdownMenuTrigger,\r\n} from \"@/components/ui/dropdown-menu\";\r\nimport { useLinksStore, useUIStore } from \"@/store\";\r\nimport { Link } from \"@/types\";\r\nimport { getPlatformConfig } from \"@/utils/platform\";\r\nimport { FolderBadge } from \"./folder-badge\";\r\nimport { formatRelativeTime } from \"@/utils/date\";\r\nimport { HighlightText } from \"@/components/common/highlight-text\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { usePerformanceMonitor } from \"@/hooks/use-performance-monitor\";\r\nimport { logger } from \"@/lib/utils/logger\";\r\nimport * as LucideIcons from \"lucide-react\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { cn as themeCn } from \"@/lib/theme\";\r\nimport { isAllowedImageDomain, getImageQuality, getFetchPriority, getBlurDataURL, getPlaceholder } from \"@/utils/image.utils\";\r\n\r\n\r\n\r\ninterface LinkCardProps {\r\n  link: Link;\r\n  isInTrash?: boolean;\r\n  isSelected?: boolean;\r\n  onToggleSelect?: (linkId: string) => void;\r\n  isSelectionModeActive?: boolean;\r\n  priority?: boolean; // For LCP optimization - prioritize above-the-fold images\r\n  showActions?: boolean; // Whether to show interactive actions (edit, delete, favorite)\r\n}\r\n\r\n/**\r\n * Link card component for grid view\r\n * Displays link with thumbnail, title, description, and metadata\r\n * Includes actions: edit, favorite, delete, restore\r\n * \r\n * @param link - Link object to display\r\n * @param isInTrash - Whether the link is in trash view\r\n * @param showActions - Whether to show actions (default: true)\r\n */\r\nfunction LinkCardComponent({\r\n  link,\r\n  isInTrash = false,\r\n  isSelected = false,\r\n  onToggleSelect,\r\n  isSelectionModeActive = false,\r\n  priority = false,\r\n  showActions = true\r\n}: LinkCardProps) {\r\n  const { updateLink, deleteLink, restoreLink, permanentlyDeleteLink } = useLinksStore();\r\n  const { setEditingLink, setAddLinkModalOpen, searchFilters } = useUIStore();\r\n  const [imageError, setImageError] = useState(false);\r\n  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);\r\n  const { toast } = useToast();\r\n\r\n  // Performance monitoring - disable render tracking to reduce overhead\r\n  const { trackInteraction, trackError, trackMetric } = usePerformanceMonitor({\r\n    componentName: 'LinkCard',\r\n    trackRenders: false, // Disabled to reduce overhead - only track interactions and errors\r\n    trackInteractions: true,\r\n    trackErrors: true\r\n  });\r\n\r\n  // Get platform icon with fallback\r\n  const platformConfig = getPlatformConfig(link.platform);\r\n  const PlatformIcon = (LucideIcons as any)[platformConfig.icon] || LinkIcon;\r\n\r\n  /**\r\n   * Opens edit modal with current link data\r\n   */\r\n  const handleEdit = (e: React.MouseEvent) => {\r\n    if (!showActions) return;\r\n    e.stopPropagation();\r\n\r\n    trackInteraction('click', 'edit_button', {\r\n      linkId: link.id,\r\n      linkTitle: link.title,\r\n      platform: link.platform\r\n    });\r\n\r\n    setEditingLink(link.id);\r\n    setAddLinkModalOpen(true);\r\n  };\r\n\r\n  /**\r\n   * Toggles favorite status of the link\r\n   */\r\n  const handleToggleFavorite = async (e: React.MouseEvent) => {\r\n    if (!showActions) return;\r\n    e.stopPropagation();\r\n\r\n    const wasFavorite = link.isFavorite;\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      await updateLink(link.id, { isFavorite: !link.isFavorite });\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('favorite_toggle_time', duration, {\r\n        action: wasFavorite ? 'unfavorite' : 'favorite',\r\n        linkId: link.id\r\n      });\r\n\r\n      trackInteraction('click', 'favorite_button', {\r\n        linkId: link.id,\r\n        action: wasFavorite ? 'unfavorite' : 'favorite',\r\n        duration\r\n      });\r\n\r\n      toast({\r\n        description: wasFavorite ? \"Unfavorited\" : \"Favorited\",\r\n        variant: \"success\",\r\n        icon: <Star className={`size-4 ${!wasFavorite ? 'fill-yellow-400 text-yellow-400' : ''}`} />,\r\n      });\r\n    } catch (error) {\r\n      logger.error('Error toggling favorite:', error);\r\n      trackError(error as Error, {\r\n        action: 'toggle_favorite',\r\n        linkId: link.id,\r\n        wasFavorite\r\n      });\r\n\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Please try again\",\r\n        variant: \"destructive\",\r\n        icon: <LucideIcons.AlertCircle className=\"size-4\" />,\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Soft deletes link (moves to trash)\r\n   */\r\n  const handleDelete = (e: React.MouseEvent) => {\r\n    if (!showActions) return;\r\n    e.stopPropagation();\r\n\r\n    const startTime = performance.now();\r\n    const linkId = link.id;\r\n\r\n    try {\r\n      deleteLink(linkId);\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('delete_link_time', duration, {\r\n        linkId,\r\n        platform: link.platform\r\n      });\r\n\r\n      trackInteraction('click', 'delete_button', {\r\n        linkId,\r\n        linkTitle: link.title,\r\n        duration\r\n      });\r\n\r\n      toast({\r\n        description: \"Deleted\",\r\n        variant: \"destructive\",\r\n        icon: <Trash className=\"size-4\" />,\r\n        action: (\r\n          <Button\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={() => handleUndoDelete(linkId)}\r\n            className=\"h-7 px-3 text-xs font-medium bg-white text-black border-white/20 hover:bg-white/90 dark:bg-white dark:text-black dark:border-white/20 dark:hover:bg-white/90 shrink-0\"\r\n          >\r\n            Undo\r\n          </Button>\r\n        ),\r\n      });\r\n    } catch (error) {\r\n      trackError(error as Error, {\r\n        action: 'delete_link',\r\n        linkId,\r\n        linkTitle: link.title\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Restores link from trash\r\n   */\r\n  const handleRestore = (e: React.MouseEvent) => {\r\n    if (!showActions) return;\r\n    e.stopPropagation();\r\n    restoreLink(link.id);\r\n    toast({\r\n      title: \"Restored\",\r\n      variant: \"success\",\r\n      icon: <RotateCcw className=\"size-4\" />,\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Copies link URL to clipboard\r\n   */\r\n  const handleCopyLink = (e: React.MouseEvent) => {\r\n    e.stopPropagation();\r\n\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      navigator.clipboard.writeText(link.url);\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('copy_link_time', duration, {\r\n        linkId: link.id,\r\n        platform: link.platform\r\n      });\r\n\r\n      trackInteraction('click', 'copy_link', {\r\n        linkId: link.id,\r\n        linkTitle: link.title,\r\n        duration\r\n      });\r\n\r\n      toast({\r\n        title: \"Copied\",\r\n        variant: \"info\",\r\n        icon: <Copy className=\"size-4\" />,\r\n      });\r\n    } catch (error) {\r\n      trackError(error as Error, {\r\n        action: 'copy_link',\r\n        linkId: link.id,\r\n        url: link.url\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handles selection toggle\r\n   */\r\n  const handleSelect = (e: React.MouseEvent) => {\r\n    if (!showActions) return;\r\n    e.stopPropagation();\r\n\r\n    trackInteraction('click', 'select_toggle', {\r\n      linkId: link.id,\r\n      isSelected: !isSelected\r\n    });\r\n\r\n    onToggleSelect?.(link.id);\r\n  };\r\n\r\n  /**\r\n   * Handles undo delete operation\r\n   */\r\n  const handleUndoDelete = (linkId: string) => {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      restoreLink(linkId);\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('undo_delete_time', duration, {\r\n        linkId\r\n      });\r\n\r\n      trackInteraction('click', 'undo_delete', {\r\n        linkId,\r\n        duration\r\n      });\r\n\r\n      toast({\r\n        title: \"Restored\",\r\n        variant: \"success\",\r\n        icon: <RotateCcw className=\"size-4\" />,\r\n      });\r\n    } catch (error) {\r\n      trackError(error as Error, {\r\n        action: 'undo_delete',\r\n        linkId\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Opens link in new tab when card is clicked\r\n   * Prevents opening if clicking on interactive elements\r\n   * In selection mode, toggles selection instead\r\n   */\r\n  const handleCardClick = (e: React.MouseEvent) => {\r\n    // Don't open if clicking on buttons or dropdown\r\n    if ((e.target as HTMLElement).closest('button')) {\r\n      return;\r\n    }\r\n\r\n    // If in selection mode, toggle selection instead of opening link\r\n    if (isSelectionModeActive && onToggleSelect && showActions) {\r\n      trackInteraction('click', 'card_select', {\r\n        linkId: link.id,\r\n        isSelected: !isSelected\r\n      });\r\n      onToggleSelect(link.id);\r\n      return;\r\n    }\r\n\r\n    // Otherwise, open the link\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      window.open(link.url, '_blank', 'noopener,noreferrer');\r\n\r\n      const duration = performance.now() - startTime;\r\n      trackMetric('link_open_time', duration, {\r\n        linkId: link.id,\r\n        platform: link.platform,\r\n        url: link.url\r\n      });\r\n\r\n      trackInteraction('click', 'open_link', {\r\n        linkId: link.id,\r\n        linkTitle: link.title,\r\n        platform: link.platform,\r\n        url: link.url,\r\n        duration\r\n      });\r\n    } catch (error) {\r\n      trackError(error as Error, {\r\n        action: 'open_link',\r\n        linkId: link.id,\r\n        url: link.url\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Permanently deletes link with confirmation\r\n   */\r\n  const handlePermanentDelete = (e: React.MouseEvent) => {\r\n    if (!showActions) return;\r\n    e.stopPropagation();\r\n    setShowDeleteConfirm(true);\r\n  };\r\n\r\n  /**\r\n   * Confirms permanent deletion\r\n   */\r\n  const confirmPermanentDelete = () => {\r\n    permanentlyDeleteLink(link.id);\r\n    toast({\r\n      title: \"Deleted permanently\",\r\n      variant: \"destructive\",\r\n      icon: <Trash className=\"size-4\" />,\r\n    });\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Card\r\n        className={`group relative overflow-hidden transition-all duration-300 ease-in-out hover:shadow-lg hover:shadow-primary/5 cursor-pointer border-2 rounded-xl will-change-transform ${isSelected\r\n          ? 'ring-2 ring-primary ring-offset-2 ring-offset-background border-primary/50'\r\n          : 'border-border/50 hover:border-border'\r\n          }`}\r\n        onClick={handleCardClick}\r\n      >\r\n        {/* Three-Dot Menu - Top Right Corner */}\r\n        {showActions && (\r\n          <div className=\"absolute top-2 right-2 z-10\">\r\n            <DropdownMenu>\r\n              <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>\r\n                <Button\r\n                  variant=\"ghost\"\r\n                  size=\"icon\"\r\n                  className=\"h-8 w-8 rounded-full bg-background/90 backdrop-blur-sm hover:bg-background opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-opacity\"\r\n                  aria-label=\"Link options\"\r\n                >\r\n                  <MoreVertical className=\"size-4\" />\r\n                  <span className=\"sr-only\">Open menu</span>\r\n                </Button>\r\n              </DropdownMenuTrigger>\r\n              <DropdownMenuContent align=\"end\">\r\n                {isInTrash ? (\r\n                  <>\r\n                    <DropdownMenuItem onClick={handleRestore}>\r\n                      <RotateCcw className=\"mr-2 size-4\" />\r\n                      Restore\r\n                    </DropdownMenuItem>\r\n                    <DropdownMenuSeparator />\r\n                    <DropdownMenuItem\r\n                      onClick={handlePermanentDelete}\r\n                      className=\"text-destructive focus:text-destructive\"\r\n                    >\r\n                      <Trash className=\"mr-2 size-4\" />\r\n                      Delete Permanently\r\n                    </DropdownMenuItem>\r\n                  </>\r\n                ) : (\r\n                  <>\r\n                    <DropdownMenuItem onClick={handleSelect}>\r\n                      <CheckSquare className=\"mr-2 size-4\" />\r\n                      Select\r\n                    </DropdownMenuItem>\r\n                    <DropdownMenuItem onClick={handleEdit}>\r\n                      <Edit className=\"mr-2 size-4\" />\r\n                      Edit\r\n                    </DropdownMenuItem>\r\n                    <DropdownMenuItem onClick={handleCopyLink} className=\"md:hidden\">\r\n                      <Copy className=\"mr-2 size-4\" />\r\n                      Copy\r\n                    </DropdownMenuItem>\r\n                    <DropdownMenuItem onClick={handleToggleFavorite} className=\"md:hidden\">\r\n                      <Star className={`mr-2 size-4 ${link.isFavorite ? 'fill-yellow-400 text-yellow-400' : ''}`} />\r\n                      {link.isFavorite ? 'Unfavorite' : 'Favorite'}\r\n                    </DropdownMenuItem>\r\n                    <DropdownMenuSeparator />\r\n                    <DropdownMenuItem\r\n                      onClick={handleDelete}\r\n                      className=\"text-destructive focus:text-destructive\"\r\n                    >\r\n                      <Trash className=\"mr-2 size-4\" />\r\n                      Trash\r\n                    </DropdownMenuItem>\r\n                  </>\r\n                )}\r\n              </DropdownMenuContent>\r\n            </DropdownMenu>\r\n          </div>\r\n        )}\r\n\r\n        {/* Thumbnail */}\r\n        <div className=\"relative h-28 sm:h-32 w-full overflow-hidden bg-muted/50 rounded-t-xl\">\r\n          {link.thumbnail && !imageError ? (\r\n            <Image\r\n              src={link.thumbnail}\r\n              alt={link.title}\r\n              fill\r\n              sizes=\"(max-width: 640px) 50vw, (max-width: 1024px) 33vw, 25vw\"\r\n              className=\"object-cover transition-transform duration-400 ease-in-out group-hover:scale-[1.03] will-change-transform\"\r\n              onError={() => setImageError(true)}\r\n              loading={priority ? \"eager\" : \"lazy\"}\r\n              priority={priority}\r\n              // OPTIMIZED: Use utility functions for consistent image optimization\r\n              placeholder={getPlaceholder(priority)}\r\n              blurDataURL={getBlurDataURL(priority)}\r\n              // Use unoptimized for external images that might not be in the allowed list\r\n              unoptimized={!isAllowedImageDomain(link.thumbnail)}\r\n              // OPTIMIZED: Variable quality for faster loading (75 for priority, 60 for others)\r\n              quality={getImageQuality(priority)}\r\n              // OPTIMIZED: fetchPriority for browser-level optimization\r\n              //@ts-ignore - fetchPriority is a valid HTML attribute\r\n              fetchPriority={getFetchPriority(priority)}\r\n            />\r\n          ) : (\r\n            <div className=\"flex h-full items-center justify-center bg-gradient-to-br from-muted to-muted/50\">\r\n              <PlatformIcon className=\"h-10 w-10 sm:h-12 sm:w-12 text-muted-foreground/60\" />\r\n            </div>\r\n          )}\r\n\r\n          {/* Favorite star - Top-left corner (visible when favorited or on hover) */}\r\n          {!isInTrash && showActions && (\r\n            <div className={`absolute top-2.5 left-2.5 z-10 transition-all duration-200 ${link.isFavorite ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'\r\n              }`}>\r\n              <Button\r\n                variant=\"ghost\"\r\n                size=\"icon\"\r\n                className=\"h-8 w-8 bg-background/90 backdrop-blur-md hover:bg-background shadow-sm border border-border/50 transition-all duration-200 hover:scale-[1.05] active:scale-95 rounded-lg\"\r\n                onClick={handleToggleFavorite}\r\n                aria-label={link.isFavorite ? \"Remove from favorites\" : \"Add to favorites\"}\r\n              >\r\n                <Star\r\n                  className={`size-4 transition-all duration-200 ${link.isFavorite ? 'fill-yellow-400 text-yellow-400' : 'text-muted-foreground hover:text-yellow-400'\r\n                    }`}\r\n                />\r\n              </Button>\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* Content */}\r\n        <CardContent className=\"p-3 sm:p-4\">\r\n          {/* Title */}\r\n          <div className=\"mb-2\">\r\n            <h3 className=\"line-clamp-1 text-xs sm:text-sm font-semibold leading-tight text-foreground pr-6\">\r\n              <HighlightText text={link.title || 'Untitled Link'} highlight={searchFilters.query} />\r\n            </h3>\r\n          </div>\r\n\r\n          {/* Description */}\r\n          {link.description && (\r\n            <p className=\"mb-2.5 line-clamp-2 text-[10px] sm:text-xs text-muted-foreground leading-relaxed\">\r\n              <HighlightText text={link.description} highlight={searchFilters.query} />\r\n            </p>\r\n          )}\r\n\r\n          {/* Footer with metadata */}\r\n          <div className=\"flex items-center justify-between gap-2 text-[10px] sm:text-xs text-muted-foreground pt-1.5 border-t border-border/50\">\r\n            <div className=\"flex items-center gap-1.5 min-w-0\">\r\n              <PlatformIcon\r\n                className=\"h-3.5 w-3.5 sm:h-4 sm:w-4 flex-shrink-0\"\r\n                style={{ color: platformConfig.color }}\r\n              />\r\n              <span className=\"truncate capitalize font-medium\">\r\n                <HighlightText text={link.platform} highlight={searchFilters.query} />\r\n              </span>\r\n              {link.folderId && !isInTrash && (\r\n                <FolderBadge folderId={link.folderId} className=\"ml-1\" />\r\n              )}\r\n            </div>\r\n            <div className=\"flex items-center gap-2\">\r\n              <span className=\"text-[10px] sm:text-xs flex-shrink-0 tabular-nums\">\r\n                {formatRelativeTime(link.createdAt)}\r\n              </span>\r\n              {/* Copy icon - Desktop only */}\r\n              {!isInTrash && showActions && (\r\n                <Button\r\n                  variant=\"ghost\"\r\n                  size=\"icon\"\r\n                  className=\"h-6 w-6 hidden md:flex opacity-0 group-hover:opacity-100 transition-all duration-200 hover:scale-110 active:scale-90 rounded-lg\"\r\n                  onClick={handleCopyLink}\r\n                  aria-label=\"Copy link\"\r\n                >\r\n                  <Copy className=\"size-3.5\" />\r\n                </Button>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </CardContent>\r\n      </Card>\r\n\r\n      {/* Permanent Delete Confirmation Modal */}\r\n      <ConfirmModal\r\n        isOpen={showDeleteConfirm}\r\n        onClose={() => setShowDeleteConfirm(false)}\r\n        onConfirm={confirmPermanentDelete}\r\n        title=\"Delete permanently?\"\r\n        description={`\"${link.title}\" will be permanently deleted. This action cannot be undone.`}\r\n        confirmText=\"Delete\"\r\n        variant=\"destructive\"\r\n      />\r\n    </>\r\n  );\r\n}\r\n\r\n// Memoize LinkCard to prevent unnecessary re-renders\r\nexport const LinkCard = React.memo(LinkCardComponent, (prevProps, nextProps) => {\r\n  // Custom comparison function for better performance\r\n  return (\r\n    prevProps.link.id === nextProps.link.id &&\r\n    prevProps.link.isFavorite === nextProps.link.isFavorite &&\r\n    prevProps.link.deletedAt === nextProps.link.deletedAt &&\r\n    prevProps.link.folderId === nextProps.link.folderId &&\r\n    prevProps.isSelected === nextProps.isSelected &&\r\n    prevProps.isInTrash === nextProps.isInTrash &&\r\n    prevProps.isSelectionModeActive === nextProps.isSelectionModeActive &&\r\n    prevProps.priority === nextProps.priority &&\r\n    prevProps.onToggleSelect === nextProps.onToggleSelect &&\r\n    prevProps.showActions === nextProps.showActions\r\n  );\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\links\\link-grid.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":23,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/links/link-grid.tsx\r\n * @description Grid view for displaying links with lazy loading\r\n * @created 2025-10-18\r\n * @updated 2025-10-18 - Added lazy loading and improved skeleton\r\n */\r\n\r\nimport React, { useState, useEffect, useRef, useMemo, useCallback } from \"react\";\r\nimport { Link } from \"@/types\";\r\nimport { LinkCard } from \"./link-card\";\r\nimport { Skeleton } from \"@/components/ui/skeleton\";\r\nimport { EmptyState } from \"@/components/common/empty-state\";\r\nimport { useUIStore, useSettingsStore } from \"@/store\";\r\nimport { Sparkles } from \"lucide-react\";\r\nimport { INITIAL_LOAD_DELAY } from \"@/constants\";\r\nimport { IMAGE_CONSTANTS } from \"@/constants/image.constants\";\r\nimport { logger } from \"@/lib/utils/logger\";\r\n\r\n\r\n\r\ninterface LinkGridProps {\r\n  links: Link[];\r\n  isLoading?: boolean;\r\n  isInTrash?: boolean;\r\n  selectedIds?: string[];\r\n  onToggleSelect?: (linkId: string) => void;\r\n  isSelectionModeActive?: boolean;\r\n}\r\n\r\n// Skeleton component that matches LinkCard layout\r\n/**\r\n* Renders a skeleton placeholder for a link card while its actual content is loading.\r\n* @example\r\n* LinkCardSkeleton()\r\n* // <div className=\"rounded-lg border bg-card overflow-hidden\">ΓÇª</div>\r\n* @returns {JSX.Element} Skeleton placeholder component for a link card.\r\n**/\r\nfunction LinkCardSkeleton() {\r\n  return (\r\n    <div className=\"rounded-lg bg-card overflow-hidden\">\r\n      {/* Thumbnail skeleton */}\r\n      <Skeleton className=\"h-28 sm:h-32 w-full rounded-none\" />\r\n      {/* Content skeleton */}\r\n      <div className=\"p-3 sm:p-4 space-y-2\">\r\n        <Skeleton className=\"h-3 w-3/4\" />\r\n        <Skeleton className=\"h-2.5 w-full\" />\r\n        <Skeleton className=\"h-2.5 w-2/3\" />\r\n      </div>\r\n      {/* Footer skeleton */}\r\n      <div className=\"px-3 sm:px-4 pb-3 sm:pb-4 flex items-center justify-between\">\r\n        <Skeleton className=\"h-2.5 w-16\" />\r\n        <Skeleton className=\"h-2.5 w-12\" />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n* Renders a responsive, lazy-loaded grid or list of link cards with selection and trash-view support.\r\n* @example\r\n* LinkGrid({ links: fetchedLinks, isLoading: false, selectedIds: ['abc'], onToggleSelect: handleToggle })\r\n* // Renders the initial batch of links and loads more items as you scroll\r\n* @param {Link[]} links - Array of link objects to display.\r\n* @param {boolean} [isLoading=false] - Displays skeleton placeholders while data is loading.\r\n* @param {boolean} [isInTrash=false] - Indicates the component is shown inside the trash section.\r\n* @param {string[]} [selectedIds=[]] - List of currently selected link IDs.\r\n* @param {(id: string) => void} onToggleSelect - Callback invoked when a link's selection state is toggled.\r\n* @param {boolean} [isSelectionModeActive=false] - Enables selection mode UI when set to true.\r\n* @returns {JSX.Element} React element containing the rendered link grid or list.\r\n**/\r\nfunction LinkGridComponent({ links, isLoading = false, isInTrash = false, selectedIds = [], onToggleSelect, isSelectionModeActive = false }: LinkGridProps) {\r\n  const { setAddLinkModalOpen } = useUIStore();\r\n  const { settings } = useSettingsStore();\r\n  const [displayedLinks, setDisplayedLinks] = useState<Link[]>([]);\r\n  const [isLoadingMore, setIsLoadingMore] = useState(false);\r\n  const observerRef = useRef<IntersectionObserver | null>(null);\r\n  const loadMoreRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Debug: Log link IDs to help identify duplicates\r\n  useEffect(() => {\r\n    if (process.env.NODE_ENV === 'development' && links.length > 0) {\r\n      const linkIds = links.map(link => link.id);\r\n      const duplicates = linkIds.filter((id, index) => linkIds.indexOf(id) !== index);\r\n\r\n      if (duplicates.length > 0) {\r\n        logger.warn('Duplicate link IDs detected:', {\r\n          totalLinks: links.length,\r\n          uniqueLinks: new Set(linkIds).size,\r\n          duplicates: [...new Set(duplicates)],\r\n        });\r\n      }\r\n    }\r\n  }, [links]);\r\n\r\n\r\n\r\n  // Update displayed links when links change, preserving the current scroll position/count\r\n  useEffect(() => {\r\n    // Deduplicate links by ID to prevent React key conflicts\r\n    const uniqueLinks = Array.from(new Map(links.map(link => [link.id, link])).values());\r\n\r\n    // Log duplicate detection for debugging\r\n    if (uniqueLinks.length !== links.length && process.env.NODE_ENV === 'development') {\r\n      logger.warn(`Detected ${links.length - uniqueLinks.length} duplicate links. Original: ${links.length}, deduplicated: ${uniqueLinks.length}`);\r\n    }\r\n\r\n    setDisplayedLinks(prev => {\r\n      // If we have previous links, try to maintain the same number of items\r\n      // This prevents the \"flicker\" or reset to top when a link is updated (e.g. favorited)\r\n      const currentCount = Math.max(prev.length, IMAGE_CONSTANTS.INITIAL_LOAD_COUNT);\r\n      return uniqueLinks.slice(0, currentCount);\r\n    });\r\n  }, [links]);\r\n\r\n  // Lazy loading with intersection observer\r\n  useEffect(() => {\r\n    // Don't set up observer if all links are displayed\r\n    if (displayedLinks.length >= links.length) {\r\n      if (observerRef.current) {\r\n        observerRef.current.disconnect();\r\n        observerRef.current = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Create observer if it doesn't exist\r\n    if (!observerRef.current) {\r\n      observerRef.current = new IntersectionObserver(\r\n        (entries) => {\r\n          if (entries[0].isIntersecting) {\r\n            setIsLoadingMore(true);\r\n            // Fast loading for better UX\r\n            setTimeout(() => {\r\n              setDisplayedLinks(prev => {\r\n                // Deduplicate links to prevent React key conflicts\r\n                const uniqueLinks = Array.from(new Map(links.map(link => [link.id, link])).values());\r\n                const nextIndex = prev.length;\r\n                const nextBatch = uniqueLinks.slice(nextIndex, nextIndex + IMAGE_CONSTANTS.LOAD_MORE_COUNT);\r\n\r\n                // Check for duplicates in the new batch\r\n                const newLinkIds = new Set(prev.map(link => link.id));\r\n                const filteredBatch = nextBatch.filter(link => !newLinkIds.has(link.id));\r\n\r\n                return [...prev, ...filteredBatch];\r\n              });\r\n              setIsLoadingMore(false);\r\n            }, INITIAL_LOAD_DELAY);\r\n          }\r\n        },\r\n        {\r\n          rootMargin: '300px',\r\n          threshold: 0.1\r\n        }\r\n      );\r\n    }\r\n\r\n    // Observe the load more ref\r\n    const currentRef = loadMoreRef.current;\r\n    if (currentRef && observerRef.current) {\r\n      observerRef.current.observe(currentRef);\r\n    }\r\n\r\n    return () => {\r\n      // Cleanup: unobserve but keep the observer instance\r\n      if (observerRef.current && currentRef) {\r\n        observerRef.current.unobserve(currentRef);\r\n      }\r\n    };\r\n  }, [displayedLinks.length, links.length, links]);\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"grid grid-cols-2 gap-4 sm:gap-6 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4\">\r\n        {Array.from({ length: IMAGE_CONSTANTS.INITIAL_LOAD_COUNT }).map((_, i) => (\r\n          <LinkCardSkeleton key={i} />\r\n        ))}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (links.length === 0) {\r\n    return (\r\n      <EmptyState\r\n        icon={Sparkles}\r\n        title=\"No links yet\"\r\n        description=\"Start building your collection by adding your first link. Paste any URL and we'll automatically fetch the title and thumbnail!\"\r\n        action={{\r\n          label: \"Add Your First Link\",\r\n          onClick: () => setAddLinkModalOpen(true),\r\n        }}\r\n      />\r\n    );\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <div className=\"grid grid-cols-2 gap-4 sm:gap-6 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4\">\r\n        {displayedLinks.map((link, index) => {\r\n          // OPTIMIZED: Only prioritize first 2 images (first row on mobile) for LCP\r\n          // Reduced from 3 to 2 to prevent waterfall loading of too many eager images\r\n          // This dramatically improves initial page load speed for thumbnail-heavy pages\r\n          const isPriority = index < 2;\r\n\r\n          return (\r\n            <LinkCard\r\n              key={link.id}\r\n              link={link}\r\n              isInTrash={isInTrash}\r\n              isSelected={selectedIds.includes(link.id)}\r\n              onToggleSelect={onToggleSelect}\r\n              isSelectionModeActive={isSelectionModeActive}\r\n              priority={isPriority}\r\n            />\r\n          );\r\n        })}\r\n\r\n        {/* Loading more skeletons */}\r\n        {isLoadingMore && Array.from({ length: 6 }).map((_, i) => (\r\n          <LinkCardSkeleton key={`loading-${i}`} />\r\n        ))}\r\n      </div>\r\n\r\n      {/* Intersection observer target */}\r\n      {displayedLinks.length < links.length && !isLoadingMore && (\r\n        <div ref={loadMoreRef} className=\"h-10 mt-6\" />\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\n// Memoize LinkGrid to prevent unnecessary re-renders\r\nexport const LinkGrid = React.memo(LinkGridComponent);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\add-link-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token LinkFormData","line":44,"column":6,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/modals/add-link-modal.tsx\r\n * @description Modal for adding new links with metadata fetching\r\n * @created 2025-10-18\r\n */\r\n\r\nimport React, { useState, useEffect, useCallback } from \"react\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport { zodResolver } from \"@hookform/resolvers/zod\";\r\nimport * as z from \"zod\";\r\nimport { Loader2, Link2, Heading, FileText, RefreshCw, AlertCircle } from \"lucide-react\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogFooter,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { Label } from \"@/components/ui/label\";\r\nimport { Textarea } from \"@/components/ui/textarea\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { detectPlatform, isValidUrl } from \"@/utils/platform\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { logger } from \"@/lib/utils/logger\";\r\nimport { FolderTreeSelect } from \"@/components/folders/folder-tree-select\";\r\nimport { VALIDATION_LIMITS } from \"@/constants\";\r\nimport { detectMobileBrowser } from \"@/lib/utils/platform\";\r\n\r\n// Delay before fetching metadata to avoid excessive API calls while user is typing\r\nconst METADATA_DEBOUNCE_DELAY = 800; // ms\r\n\r\nconst linkSchema = z.object({\r\n  url: z.string().url(\"Please enter a valid URL\"),\r\n  title: z.string().min(1, \"Title is required\").max(100),\r\n  description: z.string().max(VALIDATION_LIMITS.DESCRIPTION_MAX_LENGTH).optional(),\r\n  folderId: z.string().nullable().optional(),\r\n});\r\n\r\ntype LinkFormData = z.infer<typeof linkSchema>;\r\n\r\n/**\r\n* Modal component that allows users to add a new link or edit an existing one.\r\n* @example\r\n* AddLinkModal()\r\n* // Renders a dialog with a form for entering a URL, fetching its metadata, and saving it.\r\n* @param {void} None - This component does not accept any props.\r\n* @returns {JSX.Element} A dialog element containing the link form UI.\r\n**/\r\nexport function AddLinkModal() {\r\n  const isOpen = useStore((state) => state.isAddLinkModalOpen);\r\n  const setIsOpen = useStore((state) => state.setAddLinkModalOpen);\r\n  const editingLinkId = useStore((state) => state.editingLinkId);\r\n  const setEditingLink = useStore((state) => state.setEditingLink);\r\n  const links = useStore((state) => state.links);\r\n  const addLink = useStore((state) => state.addLink);\r\n  const updateLink = useStore((state) => state.updateLink);\r\n  const selectedFolderId = useStore((state) => state.selectedFolderId);\r\n  const currentView = useStore((state) => state.currentView);\r\n  const { toast } = useToast();\r\n\r\n  const editingLink = editingLinkId ? links.find(l => l.id === editingLinkId) : null;\r\n  const isEditMode = !!editingLink;\r\n\r\n  const [thumbnail, setThumbnail] = useState(\"\");\r\n  const [isFetchingMetadata, setIsFetchingMetadata] = useState(false);\r\n  const [urlError, setUrlError] = useState(\"\");\r\n  const [initialUrl, setInitialUrl] = useState(\"\"); // Track initial URL to detect actual changes\r\n  const [metadataError, setMetadataError] = useState<string | null>(null); // Store error for retry\r\n  const [retryCount, setRetryCount] = useState(0);\r\n  const MAX_RETRIES = 3;\r\n\r\n  // Detect mobile browser for adaptive behavior\r\n  const browserInfo = detectMobileBrowser();\r\n\r\n  const {\r\n    register,\r\n    handleSubmit,\r\n    formState: { errors, isSubmitting },\r\n    setValue,\r\n    watch,\r\n    reset,\r\n  } = useForm<LinkFormData>({\r\n    resolver: zodResolver(linkSchema),\r\n    defaultValues: {\r\n      url: \"\",\r\n      title: \"\",\r\n      description: \"\",\r\n      folderId: null,\r\n    },\r\n  });\r\n\r\n  const urlValue = watch(\"url\");\r\n\r\n  // Pre-fill form when editing, clear when adding new\r\n  // Smart pre-selection: Auto-select current folder when on folder view\r\n  useEffect(() => {\r\n    if (isOpen) {\r\n      if (editingLink) {\r\n        // Editing mode: Use link's folder\r\n        setInitialUrl(editingLink.url); // Store initial URL\r\n        reset({\r\n          url: editingLink.url,\r\n          title: editingLink.title,\r\n          description: editingLink.description,\r\n          folderId: editingLink.folderId,\r\n        });\r\n        setThumbnail(editingLink.thumbnail);\r\n        setUrlError(\"\");\r\n      } else {\r\n        // Add mode: Smart pre-selection based on current view\r\n        setInitialUrl(\"\"); // Clear initial URL for new links\r\n        const defaultFolderId =\r\n          currentView === 'all' && selectedFolderId\r\n            ? selectedFolderId\r\n            : null;\r\n\r\n        reset({\r\n          url: \"\",\r\n          title: \"\",\r\n          description: \"\",\r\n          folderId: defaultFolderId,\r\n        });\r\n        setThumbnail(\"\");\r\n        setUrlError(\"\");\r\n      }\r\n    }\r\n  }, [isOpen, editingLink, reset, currentView, selectedFolderId]);\r\n\r\n  /**\r\n   * Fetch metadata with enhanced retry mechanism and better error handling\r\n   */\r\n  const fetchMetadata = useCallback(async (url: string, isRetry = false) => {\r\n    if (!isValidUrl(url)) return;\r\n\r\n    setIsFetchingMetadata(true);\r\n    setMetadataError(null);\r\n    setUrlError(\"\");\r\n\r\n    try {\r\n      // Enhanced timeout logic for better first-time success\r\n      const baseTimeout = isRetry ? 15000 : 12000; // Longer timeout for first attempt\r\n      const timeoutDuration = browserInfo.isMobile ? baseTimeout + 3000 : baseTimeout;\r\n\r\n      const response = await fetch(\"/api/fetch-metadata\", {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          // Add cache control headers to prevent interference with fresh requests\r\n          \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\r\n          \"Pragma\": \"no-cache\",\r\n          \"Expires\": \"0\"\r\n        },\r\n        body: JSON.stringify({ url }),\r\n        signal: AbortSignal.timeout(timeoutDuration),\r\n      });\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        setValue(\"title\", data.title || \"\");\r\n        setValue(\"description\", data.description || \"\");\r\n        setThumbnail(data.image || \"\");\r\n        setUrlError(\"\");\r\n        setMetadataError(null);\r\n        setRetryCount(0); // Reset retry count on success\r\n      } else {\r\n        // Enhanced error handling with more specific messages\r\n        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));\r\n        const isRestriction = errorData.restriction === true;\r\n        let errorMessage = errorData.error || 'Unable to load link details.';\r\n\r\n        if (response.status === 403 || isRestriction) {\r\n          errorMessage = 'This website has restrictions preventing metadata fetching. You can still add the link manually by entering the title and description yourself.';\r\n        } else if (response.status === 404) {\r\n          errorMessage = 'URL not found. Please check the URL and try again.';\r\n        } else if (response.status === 408) {\r\n          errorMessage = 'Request timed out. The website took too long to respond. Click retry to try again.';\r\n        } else if (response.status === 429) {\r\n          errorMessage = 'Too many requests. Please wait a moment and try again.';\r\n        } else if (response.status === 500) {\r\n          errorMessage = 'The website is experiencing issues. Please try again later or add the link manually.';\r\n        } else {\r\n          errorMessage = errorData.error || 'Unable to load link details. You can still add the link manually.';\r\n        }\r\n\r\n        setMetadataError(errorMessage);\r\n        setUrlError(errorMessage);\r\n\r\n        // Don't clear metadata fields if it's a restriction - user can still use them\r\n        // Only clear if it's a real error (not a restriction)\r\n        if (!isRestriction) {\r\n          setValue(\"title\", \"\");\r\n          setValue(\"description\", \"\");\r\n          setThumbnail(\"\");\r\n        }\r\n      }\r\n    } catch (error: unknown) {\r\n      let errorMessage = 'Failed to fetch link details.';\r\n\r\n      // Enhanced error handling with more specific messages\r\n      if (error instanceof Error) {\r\n        if (error.name === 'AbortError' || error.message.includes('timeout')) {\r\n          errorMessage = 'Request timed out. The website took too long to respond.';\r\n        } else if (error.message.includes('CORS') || error.message.includes('blocked')) {\r\n          errorMessage = 'This website has restrictions preventing metadata fetching. You can still add the link manually.';\r\n        } else if (error.message.includes('network') || error.message.includes('fetch')) {\r\n          errorMessage = 'Network error. Please check your connection and try again.';\r\n        } else if (error.message.includes('Failed to fetch')) {\r\n          errorMessage = 'Unable to connect to the website. Please check the URL and try again.';\r\n        }\r\n      }\r\n\r\n      logger.error(\"Failed to fetch metadata:\", error);\r\n      setMetadataError(errorMessage);\r\n      setUrlError(errorMessage);\r\n\r\n      // Clear metadata fields on error (but preserve if it's a retry)\r\n      if (!isRetry) {\r\n        setValue(\"title\", \"\");\r\n        setValue(\"description\", \"\");\r\n        setThumbnail(\"\");\r\n      }\r\n    } finally {\r\n      setIsFetchingMetadata(false);\r\n    }\r\n  }, [setValue, browserInfo.isMobile]);\r\n\r\n  // Safety effect to prevent stuck metadata loading state\r\n  useEffect(() => {\r\n    if (isFetchingMetadata) {\r\n      const safetyTimer = setTimeout(() => {\r\n        if (isFetchingMetadata) {\r\n          logger.warn('Force clearing stuck metadata loading state');\r\n          setIsFetchingMetadata(false);\r\n        }\r\n      }, 8000); // 8s safety timeout (reduced from 12s)\r\n      return () => clearTimeout(safetyTimer);\r\n    }\r\n  }, [isFetchingMetadata]);\r\n\r\n  /**\r\n   * Handle retry button click\r\n   */\r\n  const handleRetryMetadata = useCallback(() => {\r\n    if (!urlValue || !isValidUrl(urlValue)) return;\r\n    if (retryCount >= MAX_RETRIES) {\r\n      setUrlError(`Maximum retries (${MAX_RETRIES}) reached. Please check the URL or add the link manually.`);\r\n      return;\r\n    }\r\n    setRetryCount(prev => prev + 1);\r\n    fetchMetadata(urlValue, true);\r\n  }, [urlValue, retryCount, fetchMetadata]);\r\n\r\n  // Fetch metadata when URL changes (on actual user input changes, including edit mode)\r\n  useEffect(() => {\r\n    // Only fetch if:\r\n    // 1. URL is valid\r\n    // 2. URL has actually changed from initial value (user input, not programmatic)\r\n    if (!urlValue || !isValidUrl(urlValue)) {\r\n      setMetadataError(null);\r\n      setRetryCount(0);\r\n      return;\r\n    }\r\n    if (urlValue === initialUrl) return; // Don't fetch if URL hasn't changed from initial\r\n\r\n    // Reset retry count when URL changes\r\n    setRetryCount(0);\r\n    setMetadataError(null);\r\n\r\n    // Enhanced debounce logic for better first-time performance\r\n    const baseDebounceDelay = 400; // Reduced from 800ms for faster response\r\n    const adaptiveDelay = browserInfo.isMobile ? baseDebounceDelay * 2 : baseDebounceDelay;\r\n\r\n    // Add slight randomness to prevent multiple tabs from hitting API simultaneously\r\n    const finalDelay = adaptiveDelay + (Math.random() * 100);\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      fetchMetadata(urlValue);\r\n    }, finalDelay);\r\n\r\n    return () => clearTimeout(timeoutId);\r\n  }, [urlValue, initialUrl, fetchMetadata, browserInfo.isMobile]);\r\n\r\n  /**\r\n  * Adds a new link or updates an existing one using the provided form data, then shows a toast and closes the modal.\r\n  * @example\r\n  * saveLink({ url: \"https://example.com\", title: \"Example\", description: \"Sample site\", folderId: \"abc123\" })\r\n  * // Displays a success toast and closes the modal\r\n  * @param {LinkFormData} data - Object containing link details such as URL, title, description, and folder ID.\r\n  * @returns {void} No return value.\r\n  **/\r\n  const onSubmit = async (data: LinkFormData) => {\r\n    try {\r\n      const platform = detectPlatform(data.url);\r\n\r\n      if (isEditMode && editingLink) {\r\n        // Update existing link\r\n        await updateLink(editingLink.id, {\r\n          url: data.url,\r\n          title: data.title,\r\n          description: data.description || \"\",\r\n          thumbnail,\r\n          platform,\r\n          folderId: data.folderId || null,\r\n          isFavorite: editingLink.isFavorite,\r\n        });\r\n\r\n        toast({\r\n          title: \"Link updated\",\r\n          variant: \"success\",\r\n          icon: <Link2 className=\"size-4\" />,\r\n        });\r\n      } else {\r\n        // Add new link\r\n        await addLink({\r\n          url: data.url,\r\n          title: data.title,\r\n          description: data.description || \"\",\r\n          thumbnail,\r\n          platform,\r\n          folderId: data.folderId || null,\r\n          isFavorite: false,\r\n        });\r\n\r\n        toast({\r\n          title: \"Link added\",\r\n          variant: \"success\",\r\n          icon: <Link2 className=\"size-4\" />,\r\n        });\r\n      }\r\n\r\n      handleClose();\r\n    } catch (error) {\r\n      logger.error('Error saving link:', error);\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to save link. Please try again.';\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Please try again\",\r\n        variant: \"destructive\",\r\n      });\r\n    }\r\n  };\r\n\r\n  const handleClose = () => {\r\n    reset();\r\n    setThumbnail(\"\");\r\n    setEditingLink(null);\r\n    setIsOpen(false);\r\n    // Reset metadata error state when closing\r\n    setMetadataError(null);\r\n    setUrlError(\"\");\r\n    setRetryCount(0);\r\n  };\r\n\r\n\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={handleClose}>\r\n      <DialogContent className=\"sm:max-w-[600px] md:max-w-[650px] lg:max-w-[700px] max-h-[85vh] flex flex-col\">\r\n        <DialogHeader className=\"flex-shrink-0\">\r\n          <DialogTitle>{isEditMode ? 'Edit Link' : 'Add New Link'}</DialogTitle>\r\n          <DialogDescription>\r\n            {isEditMode\r\n              ? 'Update your link information below.'\r\n              : \"Paste a URL and we'll automatically fetch the metadata.\"\r\n            }\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        <form onSubmit={handleSubmit(onSubmit)} className=\"flex flex-col flex-1 min-h-0\">\r\n          <div className=\"space-y-4 overflow-y-auto flex-1 px-1\">\r\n            {/* URL Input */}\r\n            <div className=\"space-y-2\">\r\n              <div className=\"flex items-center justify-between\">\r\n                <Label htmlFor=\"url\" className=\"text-sm font-medium flex items-center gap-2\">\r\n                  <Link2 className=\"h-4 w-4 text-muted-foreground\" />\r\n                  URL\r\n                </Label>\r\n                <div className=\"flex items-center gap-2\">\r\n                  {/* Loading indicator for metadata fetch */}\r\n                  {isFetchingMetadata && (\r\n                    <div className=\"flex items-center gap-2 text-xs text-muted-foreground\">\r\n                      <Loader2 className=\"h-3.5 w-3.5 animate-spin-gpu\" />\r\n                      <span>Getting link details...</span>\r\n                    </div>\r\n                  )}\r\n                  {/* Retry button - show when there's an error and not currently fetching */}\r\n                  {metadataError && !isFetchingMetadata && urlValue && isValidUrl(urlValue) && retryCount < MAX_RETRIES && (\r\n                    <Button\r\n                      type=\"button\"\r\n                      variant=\"ghost\"\r\n                      size=\"sm\"\r\n                      onClick={handleRetryMetadata}\r\n                      className=\"h-7 px-2 text-xs gap-1.5 text-muted-foreground hover:text-foreground\"\r\n                      title=\"Retry fetching metadata\"\r\n                    >\r\n                      <RefreshCw className=\"h-3.5 w-3.5\" />\r\n                      <span>Retry</span>\r\n                    </Button>\r\n                  )}\r\n                </div>\r\n              </div>\r\n              <div className=\"relative\">\r\n                <Input\r\n                  id=\"url\"\r\n                  type=\"url\"\r\n                  placeholder=\"https://example.com\"\r\n                  {...register(\"url\")}\r\n                  className=\"h-10 text-base transition-all duration-200 pr-10\"\r\n                />\r\n                {/* Inline retry icon for better UX */}\r\n                {metadataError && !isFetchingMetadata && urlValue && isValidUrl(urlValue) && retryCount < MAX_RETRIES && (\r\n                  <Button\r\n                    type=\"button\"\r\n                    variant=\"ghost\"\r\n                    size=\"icon\"\r\n                    onClick={handleRetryMetadata}\r\n                    className=\"absolute right-1 top-1/2 -translate-y-1/2 h-8 w-8 text-muted-foreground hover:text-foreground\"\r\n                    title=\"Retry fetching metadata\"\r\n                  >\r\n                    <RefreshCw className=\"h-4 w-4\" />\r\n                  </Button>\r\n                )}\r\n              </div>\r\n              {errors.url && (\r\n                <p className=\"text-xs text-destructive mt-1 flex items-center gap-1.5\">\r\n                  <AlertCircle className=\"h-3.5 w-3.5\" />\r\n                  {errors.url.message}\r\n                </p>\r\n              )}\r\n              {urlError && (\r\n                <div className=\"text-xs text-destructive mt-1 flex items-start gap-1.5\">\r\n                  <AlertCircle className=\"h-3.5 w-3.5 mt-0.5 flex-shrink-0\" />\r\n                  <span className=\"flex-1\">{urlError}</span>\r\n                </div>\r\n              )}\r\n            </div>\r\n\r\n            {/* Title Input */}\r\n            <div className=\"space-y-2\">\r\n              <Label htmlFor=\"title\" className=\"text-sm font-medium flex items-center gap-2\">\r\n                <Heading className=\"h-4 w-4 text-muted-foreground\" />\r\n                Title\r\n              </Label>\r\n              <Input\r\n                id=\"title\"\r\n                placeholder=\"Link title\"\r\n                {...register(\"title\")}\r\n                className=\"h-10 text-base transition-all duration-200\"\r\n              />\r\n              {errors.title && (\r\n                <p className=\"text-xs text-destructive mt-1\">{errors.title.message}</p>\r\n              )}\r\n            </div>\r\n\r\n            {/* Description Input */}\r\n            <div className=\"space-y-2\">\r\n              <Label htmlFor=\"description\" className=\"text-sm font-medium flex items-center gap-2\">\r\n                <FileText className=\"h-4 w-4 text-muted-foreground\" />\r\n                Description\r\n              </Label>\r\n              <Textarea\r\n                id=\"description\"\r\n                placeholder=\"Optional description\"\r\n                rows={3}\r\n                {...register(\"description\")}\r\n                className=\"text-sm sm:text-base resize-none overflow-hidden transition-all duration-200\"\r\n              />\r\n              {errors.description && (\r\n                <p className=\"text-xs text-destructive mt-1\">\r\n                  {errors.description.message}\r\n                </p>\r\n              )}\r\n            </div>\r\n\r\n            {/* Folder Selection - Hierarchical Tree */}\r\n            <div>\r\n              <FolderTreeSelect\r\n                value={watch(\"folderId\") || null}\r\n                onChange={useCallback((folderId: string | null) => setValue(\"folderId\", folderId), [setValue])}\r\n                placeholder=\"Optional: Select a folder to organize this link\"\r\n                allowClear\r\n              />\r\n            </div>\r\n\r\n          </div>\r\n\r\n          <DialogFooter className=\"flex-shrink-0 mt-6 gap-3\">\r\n            <Button type=\"button\" variant=\"outline\" onClick={handleClose} className=\"h-10 px-6\">\r\n              Cancel\r\n            </Button>\r\n            <Button type=\"submit\" disabled={isSubmitting || isFetchingMetadata} className=\"h-10 px-6\">\r\n              {isSubmitting ? (\r\n                <>\r\n                  <Loader2 className=\"mr-2 size-4 animate-spin-gpu\" />\r\n                  {isEditMode ? 'Updating...' : 'Saving...'}\r\n                </>\r\n              ) : (\r\n                isEditMode ? 'Update Link' : 'Add Link'\r\n              )}\r\n            </Button>\r\n          </DialogFooter>\r\n        </form>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\bulk-delete-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":20,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/modals/bulk-delete-modal.tsx\r\n * @description Confirmation modal for bulk delete operations\r\n * @created 2025-10-25\r\n */\r\n\r\n\"use client\";\r\n\r\nimport { Trash2 } from \"lucide-react\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogFooter,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { Button } from \"@/components/ui/button\";\r\n\r\ninterface BulkDeleteModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  selectedCount: number;\r\n  onConfirm: () => void;\r\n  isDeleting?: boolean;\r\n}\r\n\r\n/**\r\n* Renders a confirmation modal allowing users to bulk-delete selected items.\r\n* @example\r\n* BulkDeleteModal({ isOpen: true, onClose: closeModal, selectedCount: 5, onConfirm: deleteItems })\r\n* <Dialog> ΓÇª </Dialog>\r\n* @param {boolean} isOpen - Flag that controls the visibility of the modal.\r\n* @param {Function} onClose - Callback executed when the modal should close.\r\n* @param {number} selectedCount - Number of items currently selected for deletion.\r\n* @param {Function} onConfirm - Callback executed to confirm and perform deletion.\r\n* @param {boolean} [isDeleting=false] - Indicates whether the deletion process is in progress.\r\n* @returns {JSX.Element} A React element that renders the bulk-delete confirmation modal.\r\n**/\r\nexport function BulkDeleteModal({\r\n  isOpen,\r\n  onClose,\r\n  selectedCount,\r\n  onConfirm,\r\n  isDeleting = false,\r\n}: BulkDeleteModalProps) {\r\n  const handleConfirm = () => {\r\n    onConfirm();\r\n    onClose();\r\n  };\r\n\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-[400px]\">\r\n        <DialogHeader>\r\n          <div className=\"flex items-center gap-3\">\r\n            <div className=\"flex h-10 w-10 items-center justify-center rounded-full bg-destructive/10\">\r\n              <Trash2 className=\"size-5 text-destructive\" />\r\n            </div>\r\n            <div>\r\n              <DialogTitle>Delete Selected Items</DialogTitle>\r\n              <DialogDescription className=\"mt-1\">\r\n                Are you sure you want to delete {selectedCount} selected {selectedCount === 1 ? 'item' : 'items'}?\r\n                This action cannot be undone.\r\n              </DialogDescription>\r\n            </div>\r\n          </div>\r\n        </DialogHeader>\r\n\r\n        <DialogFooter className=\"gap-2\">\r\n          <Button variant=\"outline\" onClick={onClose} disabled={isDeleting}>\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            variant=\"destructive\"\r\n            onClick={handleConfirm}\r\n            disabled={isDeleting}\r\n          >\r\n            {isDeleting ? \"Deleting...\" : `Delete ${selectedCount} ${selectedCount === 1 ? 'Item' : 'Items'}`}\r\n          </Button>\r\n        </DialogFooter>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\bulk-move-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":27,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/modals/bulk-move-modal.tsx\r\n * @description Modal for bulk moving selected links to folders\r\n * @created 2025-10-25\r\n */\r\n\r\n\"use client\";\r\n\r\nimport React, { useState, useMemo } from \"react\";\r\nimport { FolderPlus, Search, Check, AlertCircle } from \"lucide-react\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogFooter,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { ConfirmModal } from \"@/components/modals/confirm-modal\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { getRootFolders } from \"@/utils/folder-utils\";\r\nimport { FolderTreeItem } from \"@/components/folders/folder-tree-item\";\r\n\r\ninterface BulkMoveModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  selectedIds: string[];\r\n  onComplete: (movedCount: number) => void;\r\n}\r\n\r\ninterface FolderTreeItemProps {\r\n  folder: any;\r\n  allFolders: any[];\r\n  selectedId: string | null;\r\n  onSelect: (folderId: string) => void;\r\n  expandedIds: Set<string>;\r\n  onToggleExpand: (folderId: string) => void;\r\n  showCheckIcon?: boolean;\r\n}\r\n\r\n/**\r\n* Renders a modal that allows users to move multiple selected links into a chosen folder and handles the move logic.\r\n* @example\r\n* BulkMoveModal({ isOpen: true, onClose: () => {}, selectedIds: ['abc', 'def'], onComplete: (count) => console.log(`Moved ${count} items`) })\r\n* <BulkMoveModal /> JSX element\r\n* @param {Object} props - Props object for BulkMoveModal.\r\n* @param {boolean} props.isOpen - Flag indicating whether the modal is open.\r\n* @param {Function} props.onClose - Callback invoked when the modal is closed.\r\n* @param {string[]} props.selectedIds - Array of link IDs selected for moving.\r\n* @param {Function} props.onComplete - Callback invoked after the move completes, receiving the number of items moved.\r\n* @returns {JSX.Element} A React component that displays the bulk move modal.\r\n**/\r\nexport function BulkMoveModal({\r\n  isOpen,\r\n  onClose,\r\n  selectedIds,\r\n  onComplete,\r\n}: BulkMoveModalProps) {\r\n  const links = useStore((state) => state.links);\r\n  const folders = useStore((state) => state.folders);\r\n  const bulkMoveLinks = useStore((state) => state.bulkMoveLinks);\r\n  const { toast } = useToast();\r\n\r\n  const [selectedFolderId, setSelectedFolderId] = useState<string | null>(null);\r\n  const [searchQuery, setSearchQuery] = useState(\"\");\r\n  const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set());\r\n  const [isMoving, setIsMoving] = useState(false);\r\n  const [showMoveConfirm, setShowMoveConfirm] = useState(false);\r\n  const [pendingMoveCount, setPendingMoveCount] = useState(0);\r\n\r\n  // Get selected links\r\n  const selectedLinks = links.filter(link => selectedIds.includes(link.id));\r\n\r\n  // Filter folders based on search\r\n  const filteredFolders = useMemo(() => {\r\n    if (!searchQuery) return folders;\r\n\r\n    const query = searchQuery.toLowerCase();\r\n    return folders.filter(folder =>\r\n      folder.name.toLowerCase().includes(query)\r\n    );\r\n  }, [folders, searchQuery]);\r\n\r\n  // Get root folders for display\r\n  const rootFolders = useMemo(() => {\r\n    return getRootFolders(filteredFolders);\r\n  }, [filteredFolders]);\r\n\r\n  /**\r\n   * Handles folder selection toggle\r\n   */\r\n  const handleFolderSelect = (folderId: string | null) => {\r\n    setSelectedFolderId(selectedFolderId === folderId ? null : folderId);\r\n  };\r\n\r\n  /**\r\n   * Handles folder expansion toggle\r\n   */\r\n  const handleToggleExpand = (folderId: string) => {\r\n    setExpandedIds(prev => {\r\n      const next = new Set(prev);\r\n      if (next.has(folderId)) {\r\n        next.delete(folderId);\r\n      } else {\r\n        next.add(folderId);\r\n      }\r\n      return next;\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Handles the bulk move operation\r\n   */\r\n  const handleMove = async () => {\r\n    if (!selectedFolderId) return;\r\n\r\n    // Check if any links are already in the target folder\r\n    const alreadyInFolder = selectedLinks.filter(link => link.folderId === selectedFolderId);\r\n\r\n    if (alreadyInFolder.length > 0) {\r\n      setPendingMoveCount(alreadyInFolder.length);\r\n      setShowMoveConfirm(true);\r\n      return;\r\n    }\r\n\r\n    // Proceed with move if no duplicates\r\n    performMove();\r\n  };\r\n\r\n  /**\r\n   * Performs the actual move operation\r\n   */\r\n  const performMove = async () => {\r\n    setIsMoving(true);\r\n    let movedCount = 0;\r\n\r\n    try {\r\n      // Filter links that actually need to be moved\r\n      const linksToMove = selectedIds.filter(id => {\r\n        const link = links.find(l => l.id === id);\r\n        return link && link.folderId !== selectedFolderId;\r\n      });\r\n\r\n      if (linksToMove.length > 0) {\r\n        await bulkMoveLinks(linksToMove, selectedFolderId);\r\n        movedCount = linksToMove.length;\r\n      }\r\n\r\n      onComplete(movedCount);\r\n      handleClose();\r\n    } catch (error) {\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Please try again\",\r\n        variant: \"destructive\",\r\n        icon: <AlertCircle className=\"size-4\" />,\r\n      });\r\n    } finally {\r\n      setIsMoving(false);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handles modal close\r\n   */\r\n  const handleClose = () => {\r\n    setSelectedFolderId(null);\r\n    setSearchQuery(\"\");\r\n    setExpandedIds(new Set());\r\n    setShowMoveConfirm(false);\r\n    setPendingMoveCount(0);\r\n    onClose();\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <Dialog open={isOpen} onOpenChange={handleClose}>\r\n      <DialogContent className=\"sm:max-w-[500px] max-h-[80vh] flex flex-col\">\r\n        <DialogHeader>\r\n          <DialogTitle>Move Items</DialogTitle>\r\n          <DialogDescription>\r\n            Choose a folder to move {selectedIds.length} selected {selectedIds.length === 1 ? 'item' : 'items'} to.\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        <div className=\"flex flex-col flex-1 min-h-0\">\r\n          {/* Search */}\r\n          <div className=\"relative mb-4\">\r\n            <Search className=\"absolute left-3 top-1/2 size-4 -translate-y-1/2 text-muted-foreground\" />\r\n            <Input\r\n              placeholder=\"Search folders...\"\r\n              value={searchQuery}\r\n              onChange={(e) => setSearchQuery(e.target.value)}\r\n              className=\"pl-10\"\r\n            />\r\n          </div>\r\n\r\n          {/* Folder Tree */}\r\n          <div className=\"flex-1 overflow-y-auto border rounded-md p-2 custom-scrollbar\">\r\n            {rootFolders.length === 0 ? (\r\n              <div className=\"flex flex-col items-center justify-center h-32 text-center\">\r\n                <FolderPlus className=\"h-8 w-8 text-muted-foreground mb-2\" />\r\n                <p className=\"text-sm text-muted-foreground\">\r\n                  {searchQuery ? \"No folders found\" : \"No folders available\"}\r\n                </p>\r\n              </div>\r\n            ) : (\r\n              <div className=\"space-y-1\" role=\"tree\" aria-label=\"Folder tree\">\r\n                {/* None option */}\r\n                <button\r\n                  type=\"button\"\r\n                  onClick={() => setSelectedFolderId(null)}\r\n                  className={`w-full text-left px-2 py-2 text-sm rounded hover:bg-accent transition-colors flex items-center gap-2 ${\r\n                    selectedFolderId === null ? 'bg-accent' : ''\r\n                  }`}\r\n                >\r\n                  {selectedFolderId === null && <Check className=\"size-4\" />}\r\n                  <span className=\"text-muted-foreground italic\">None (remove from folders)</span>\r\n                </button>\r\n\r\n                {/* Folder tree */}\r\n                {rootFolders.map((folder) => (\r\n                  <FolderTreeItem\r\n                    key={folder.id}\r\n                    folder={folder}\r\n                    allFolders={filteredFolders}\r\n                    selectedId={selectedFolderId}\r\n                    onSelect={handleFolderSelect}\r\n                    expandedIds={expandedIds}\r\n                    onToggleExpand={handleToggleExpand}\r\n                  />\r\n                ))}\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        <DialogFooter>\r\n          <Button variant=\"outline\" onClick={handleClose}>\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            onClick={handleMove}\r\n            disabled={!selectedFolderId && selectedFolderId !== null || isMoving}\r\n          >\r\n            {isMoving ? \"Moving...\" : `Move ${selectedIds.length} ${selectedIds.length === 1 ? 'Item' : 'Items'}`}\r\n          </Button>\r\n        </DialogFooter>\r\n      </DialogContent>\r\n      </Dialog>\r\n\r\n      {/* Move Confirmation Modal for Already-in-Folder Items */}\r\n      <ConfirmModal\r\n        isOpen={showMoveConfirm}\r\n        onClose={() => setShowMoveConfirm(false)}\r\n        onConfirm={performMove}\r\n        title=\"Some items already in folder\"\r\n        description={`${pendingMoveCount} ${pendingMoveCount === 1 ? 'item is' : 'items are'} already in the selected folder. Continue moving all selected items?`}\r\n        confirmText=\"Continue\"\r\n        variant=\"default\"\r\n      />\r\n    </>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\confirm-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":20,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/modals/confirm-modal.tsx\r\n * @description Minimal reusable confirmation modal\r\n * @created 2025-10-26\r\n */\r\n\r\n\"use client\";\r\n\r\nimport { AlertTriangle } from \"lucide-react\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogFooter,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { Button } from \"@/components/ui/button\";\r\n\r\ninterface ConfirmModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  onConfirm: () => void;\r\n  title: string;\r\n  description: string;\r\n  confirmText?: string;\r\n  cancelText?: string;\r\n  variant?: \"default\" | \"destructive\";\r\n  isLoading?: boolean;\r\n}\r\n\r\n/**\r\n * Reusable confirmation modal component\r\n * Replaces browser's native confirm dialog with a minimal, clean UI\r\n * \r\n * @example\r\n * <ConfirmModal\r\n *   isOpen={showConfirm}\r\n *   onClose={() => setShowConfirm(false)}\r\n *   onConfirm={handleDelete}\r\n *   title=\"Delete item?\"\r\n *   description=\"This action cannot be undone.\"\r\n *   variant=\"destructive\"\r\n * />\r\n */\r\nexport function ConfirmModal({\r\n  isOpen,\r\n  onClose,\r\n  onConfirm,\r\n  title,\r\n  description,\r\n  confirmText = \"Confirm\",\r\n  cancelText = \"Cancel\",\r\n  variant = \"default\",\r\n  isLoading = false,\r\n}: ConfirmModalProps) {\r\n  /**\r\n   * Handles confirmation action\r\n   */\r\n  const handleConfirm = () => {\r\n    onConfirm();\r\n    onClose();\r\n  };\r\n\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-[400px]\">\r\n        <DialogHeader>\r\n          <div className=\"flex items-center gap-2\">\r\n            {variant === \"destructive\" && (\r\n              <AlertTriangle className=\"size-5 text-destructive\" />\r\n            )}\r\n            <DialogTitle>{title}</DialogTitle>\r\n          </div>\r\n          <DialogDescription className=\"pt-2\">\r\n            {description}\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        <DialogFooter className=\"gap-2 sm:gap-0\">\r\n          <Button\r\n            variant=\"outline\"\r\n            onClick={onClose}\r\n            disabled={isLoading}\r\n          >\r\n            {cancelText}\r\n          </Button>\r\n          <Button\r\n            variant={variant === \"destructive\" ? \"destructive\" : \"default\"}\r\n            onClick={handleConfirm}\r\n            disabled={isLoading}\r\n          >\r\n            {isLoading ? \"Please wait...\" : confirmText}\r\n          </Button>\r\n        </DialogFooter>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\create-folder-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token FolderFormData","line":37,"column":6,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/modals/create-folder-modal.tsx\r\n * @description Modal for creating and editing folders\r\n * @created 2025-10-18\r\n * @updated 2025-10-18 - Added edit mode functionality\r\n */\r\n\r\nimport * as React from \"react\";\r\nimport { useForm } from \"react-hook-form\";\r\nimport { zodResolver } from \"@hookform/resolvers/zod\";\r\nimport * as z from \"zod\";\r\nimport { Loader2, AlertCircle, Folder, FolderPlus } from \"lucide-react\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogFooter,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { Label } from \"@/components/ui/label\";\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { logger } from \"@/lib/utils/logger\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { FOLDER_ICONS } from \"@/constants/folder-icons\";\r\nimport { canAddSubFolder, getSubFolderCount, MAX_SUB_FOLDERS_PER_FOLDER } from \"@/utils/folder-utils\";\r\n\r\nconst folderSchema = z.object({\r\n  name: z.string().min(1, \"Name is required\").max(30, \"Name must be 30 characters or less\"),\r\n  iconName: z.string().min(1, \"Icon is required\"),\r\n});\r\n\r\ntype FolderFormData = z.infer<typeof folderSchema>;\r\n\r\n/**\r\n* Renders a modal dialog that allows users to create, edit, and validate folders (or sub-folders) with customizable icons.\r\n* @example\r\n* <CreateFolderModal />\r\n* Renders the modal for creating or editing a folder and returns the corresponding JSX element.\r\n* @returns {JSX.Element} The rendered create/edit folder modal component.\r\n**/\r\nexport function CreateFolderModal() {\r\n  const isOpen = useStore((state) => state.isCreateFolderModalOpen);\r\n  const setIsOpen = useStore((state) => state.setCreateFolderModalOpen);\r\n  const editingFolderId = useStore((state) => state.editingFolderId);\r\n  const setEditingFolder = useStore((state) => state.setEditingFolder);\r\n  const parentFolderId = useStore((state) => state.parentFolderId);\r\n  const setParentFolder = useStore((state) => state.setParentFolder);\r\n  const folders = useStore((state) => state.folders);\r\n  const addFolder = useStore((state) => state.addFolder);\r\n  const updateFolder = useStore((state) => state.updateFolder);\r\n  const { toast } = useToast();\r\n\r\n  const editingFolder = editingFolderId ? folders.find(f => f.id === editingFolderId) : null;\r\n  const isEditMode = !!editingFolder;\r\n  const isSubFolder = !!parentFolderId;\r\n  const parentFolder = parentFolderId ? folders.find(f => f.id === parentFolderId) : null;\r\n\r\n  // Check if parent folder has reached the sub-folder limit\r\n  const canAddMoreSubFolders = parentFolderId ? canAddSubFolder(parentFolderId, folders) : true;\r\n  const currentSubFolderCount = parentFolderId ? getSubFolderCount(parentFolderId, folders) : 0;\r\n  const hasReachedLimit = !canAddMoreSubFolders && !isEditMode;\r\n\r\n  const {\r\n    register,\r\n    handleSubmit,\r\n    formState: { errors, isSubmitting },\r\n    reset,\r\n    setValue,\r\n    watch,\r\n  } = useForm<FolderFormData>({\r\n    resolver: zodResolver(folderSchema),\r\n    defaultValues: {\r\n      name: \"\",\r\n      iconName: \"Folder\",\r\n    },\r\n  });\r\n\r\n  const selectedIconName = watch(\"iconName\") || \"Folder\";\r\n  const selectedIcon = FOLDER_ICONS.find(icon => icon.name === selectedIconName) || FOLDER_ICONS[15];\r\n\r\n  // Pre-fill form when editing, clear when adding new\r\n  React.useEffect(() => {\r\n    if (isOpen) {\r\n      if (editingFolder) {\r\n        reset({\r\n          name: editingFolder.name,\r\n          iconName: editingFolder.icon,\r\n        });\r\n      } else {\r\n        // Clear form when opening in add mode\r\n        reset({\r\n          name: \"\",\r\n          iconName: \"Folder\",\r\n        });\r\n      }\r\n    }\r\n  }, [isOpen, editingFolder, reset]);\r\n\r\n  /**\r\n  * Validates folder form input, then creates a new folder or updates an existing one while displaying toast notifications.\r\n  * @example\r\n  * handleFolderFormSubmit({ name: \"Projects\", iconName: \"briefcase\" })\r\n  * // Folder created/updated and success toast displayed\r\n  * @param {{FolderFormData}} {{data}} - Folder form data containing name, iconName and other fields.\r\n  * @returns {{void}} Returns nothing.\r\n  **/\r\n  const onSubmit = async (data: FolderFormData) => {\r\n    try {\r\n      // Validate: Cannot create sub-folder inside a sub-folder\r\n      if (!isEditMode && parentFolderId) {\r\n        const parent = folders.find(f => f.id === parentFolderId);\r\n        if (parent?.parentId !== null) {\r\n          toast({\r\n            title: \"Invalid location\",\r\n            description: \"Sub-folders can only be created under main folders\",\r\n            variant: \"destructive\",\r\n            icon: <AlertCircle className=\"size-4\" />,\r\n          });\r\n          return;\r\n        }\r\n\r\n        // Validate sub-folder limit (now 10)\r\n        if (!canAddSubFolder(parentFolderId, folders)) {\r\n          const count = getSubFolderCount(parentFolderId, folders);\r\n          toast({\r\n            title: \"Limit reached\",\r\n            description: `Maximum ${MAX_SUB_FOLDERS_PER_FOLDER} sub-folders allowed`,\r\n            variant: \"destructive\",\r\n            icon: <AlertCircle className=\"size-4\" />,\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      const iconOption = FOLDER_ICONS.find(icon => icon.name === data.iconName);\r\n      const color = iconOption?.color || \"#F59E0B\";\r\n\r\n      if (isEditMode && editingFolder) {\r\n        // Update existing folder\r\n        await updateFolder(editingFolder.id, {\r\n          name: data.name,\r\n          icon: data.iconName,\r\n          color: color,\r\n        });\r\n\r\n        toast({\r\n          title: \"Folder updated\",\r\n          variant: \"success\",\r\n          icon: <Folder className=\"size-4\" />,\r\n        });\r\n\r\n        handleClose();\r\n      } else {\r\n        // Create new folder or sub-folder\r\n        await addFolder({\r\n          name: data.name,\r\n          description: \"\",\r\n          color: color,\r\n          icon: data.iconName,\r\n          parentId: parentFolderId ?? null,\r\n          isPlatformFolder: false,\r\n        });\r\n\r\n        toast({\r\n          title: \"Folder created\",\r\n          variant: \"success\",\r\n          icon: isSubFolder ? <FolderPlus className=\"size-4\" /> : <Folder className=\"size-4\" />,\r\n        });\r\n\r\n        handleClose();\r\n      }\r\n    } catch (error) {\r\n      logger.error('Error saving folder:', error);\r\n\r\n      // OPTIMIZED: Handle duplicate folder name error\r\n      const isDuplicate = error instanceof Error && (\r\n        error.message?.includes('already exists') ||\r\n        error.message?.includes('duplicate') ||\r\n        error.message?.includes('unique')\r\n      );\r\n\r\n      toast({\r\n        title: isDuplicate ? \"Duplicate folder\" : \"Error\",\r\n        description: isDuplicate ? \"A folder with this name already exists\" : \"Please try again\",\r\n        variant: \"destructive\",\r\n        icon: <AlertCircle className=\"size-4\" />,\r\n      });\r\n      // Don't close modal on error - let user retry\r\n    }\r\n  };\r\n\r\n  const handleClose = () => {\r\n    reset();\r\n    setEditingFolder(null);\r\n    setParentFolder(null);\r\n    setIsOpen(false);\r\n  };\r\n\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={handleClose}>\r\n      <DialogContent className=\"sm:max-w-[550px] md:max-w-[600px] lg:max-w-[650px] max-h-[85vh] flex flex-col\">\r\n        <DialogHeader>\r\n          <DialogTitle>\r\n            {isEditMode ? 'Edit Folder' : isSubFolder ? `Create Sub-folder ${parentFolder ? `under \"${parentFolder.name}\"` : ''}` : 'Create Folder'}\r\n          </DialogTitle>\r\n          <DialogDescription>\r\n            {isEditMode\r\n              ? 'Update your folder name and icon.'\r\n              : 'Choose an icon and name for your folder.'}\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        <form onSubmit={handleSubmit(onSubmit)} className=\"flex flex-col gap-3 flex-1 min-h-0\">\r\n          {/* Warning: Sub-folder limit reached */}\r\n          {hasReachedLimit && (\r\n            <div className=\"flex items-start gap-2 rounded-md border border-destructive/50 bg-destructive/10 p-3\">\r\n              <AlertCircle className=\"size-4 text-destructive flex-shrink-0 mt-0.5\" />\r\n              <div className=\"flex-1 text-sm\">\r\n                <p className=\"font-medium text-destructive\">Maximum sub-folders reached</p>\r\n                <p className=\"text-xs text-destructive/80 mt-1\">\r\n                  &quot;{parentFolder?.name}&quot; already has {currentSubFolderCount} sub-folders.\r\n                  Maximum is {MAX_SUB_FOLDERS_PER_FOLDER} sub-folders per folder.\r\n                </p>\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* Name Input */}\r\n          <div className=\"space-y-2\">\r\n            <div className=\"flex items-center justify-between\">\r\n              <Label htmlFor=\"name\" className=\"text-sm font-medium\">Folder Name</Label>\r\n              <span className=\"text-xs text-muted-foreground tabular-nums\">{watch(\"name\")?.length || 0}/30</span>\r\n            </div>\r\n            <Input\r\n              id=\"name\"\r\n              placeholder=\"My Folder\"\r\n              {...register(\"name\")}\r\n              maxLength={30}\r\n              className=\"h-10 text-base transition-all duration-200 ease-in-out\"\r\n            />\r\n            {errors.name && (\r\n              <p className=\"text-xs text-destructive mt-1\">{errors.name.message}</p>\r\n            )}\r\n          </div>\r\n\r\n          {/* Icon Selector */}\r\n          <div className=\"flex-1 min-h-0 flex flex-col gap-2.5\">\r\n            <Label className=\"text-sm font-medium\">Select Icon</Label>\r\n\r\n            <div className=\"grid grid-cols-9 gap-1.5\">\r\n              {FOLDER_ICONS.map((iconOption) => {\r\n                const IconComponent = iconOption.icon;\r\n                const isSelected = selectedIconName === iconOption.name;\r\n                return (\r\n                  <button\r\n                    key={iconOption.name}\r\n                    type=\"button\"\r\n                    onClick={() => setValue(\"iconName\", iconOption.name)}\r\n                    className={`aspect-square p-1.5 rounded-md border-2 transition-all duration-250 ease-in-out hover:scale-105 active:scale-95 flex items-center justify-center will-change-transform ${isSelected\r\n                      ? \"border-primary bg-primary/10 scale-105\"\r\n                      : \"border-border hover:border-primary/50\"\r\n                      }`}\r\n                    title={iconOption.name}\r\n                  >\r\n                    <IconComponent\r\n                      className=\"size-4\"\r\n                      style={{ color: iconOption.color }}\r\n                    />\r\n                  </button>\r\n                );\r\n              })}\r\n            </div>\r\n          </div>\r\n\r\n          <DialogFooter className=\"mt-6 gap-3\">\r\n            <Button type=\"button\" variant=\"outline\" onClick={handleClose} className=\"h-10 px-6\">\r\n              Cancel\r\n            </Button>\r\n            <Button type=\"submit\" disabled={isSubmitting || hasReachedLimit} className=\"h-10 px-6\">\r\n              {isSubmitting ? (\r\n                <>\r\n                  <Loader2 className=\"mr-2 size-4 animate-spin-gpu\" />\r\n                  {isEditMode ? 'Updating...' : 'Creating...'}\r\n                </>\r\n              ) : (\r\n                isEditMode ? 'Update Folder' : 'Create Folder'\r\n              )}\r\n            </Button>\r\n          </DialogFooter>\r\n        </form>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\empty-trash-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":20,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/modals/empty-trash-modal.tsx\r\n * @description Modal for confirming empty trash action\r\n * @created 2025-10-30\r\n */\r\n\r\n\"use client\";\r\n\r\nimport { AlertCircle, Trash2 } from \"lucide-react\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogFooter,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { Button } from \"@/components/ui/button\";\r\n\r\ninterface EmptyTrashModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  onConfirm: () => void;\r\n  trashCount: number;\r\n}\r\n\r\n/**\r\n * Empty trash confirmation modal\r\n * Warns user that all trashed items will be permanently deleted\r\n * \r\n * @param {EmptyTrashModalProps} props - Component props\r\n * @returns {JSX.Element} Empty trash modal component\r\n */\r\nexport function EmptyTrashModal({\r\n  isOpen,\r\n  onClose,\r\n  onConfirm,\r\n  trashCount,\r\n}: EmptyTrashModalProps) {\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-[440px]\">\r\n        <DialogHeader>\r\n          <div className=\"flex items-center gap-3\">\r\n            <div className=\"flex h-12 w-12 items-center justify-center rounded-full bg-destructive/10\">\r\n              <AlertCircle className=\"h-6 w-6 text-destructive\" />\r\n            </div>\r\n            <div>\r\n              <DialogTitle>Empty Trash?</DialogTitle>\r\n              <DialogDescription className=\"mt-1\">\r\n                This action cannot be undone\r\n              </DialogDescription>\r\n            </div>\r\n          </div>\r\n        </DialogHeader>\r\n\r\n        <div className=\"py-4\">\r\n          <p className=\"text-sm text-muted-foreground\">\r\n            All <span className=\"font-semibold text-foreground\">{trashCount}</span> {trashCount === 1 ? 'item' : 'items'} in the trash will be permanently deleted. \r\n            You will not be able to restore {trashCount === 1 ? 'it' : 'them'}.\r\n          </p>\r\n        </div>\r\n\r\n        <DialogFooter>\r\n          <Button\r\n            variant=\"outline\"\r\n            onClick={onClose}\r\n            className=\"h-9\"\r\n          >\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            variant=\"destructive\"\r\n            onClick={() => {\r\n              onConfirm();\r\n              onClose();\r\n            }}\r\n            className=\"h-9\"\r\n          >\r\n            <Trash2 className=\"mr-2 h-4 w-4\" />\r\n            Empty Trash\r\n          </Button>\r\n        </DialogFooter>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\profile-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":29,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/modals/profile-modal.tsx\r\n * @description Compact profile modal with user info and logout functionality\r\n * @created 2025-01-01\r\n */\r\n\r\n'use client';\r\n\r\nimport React, { useState } from 'react';\r\nimport { useRouter } from 'next/navigation';\r\nimport { User, Mail, Calendar, Link2, FolderOpen, HardDrive, Download, Upload, Trash2 } from 'lucide-react';\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from '@/components/ui/dialog';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Button } from '@/components/ui/button';\r\nimport { ConfirmModal } from '@/components/modals/confirm-modal';\r\nimport { useAuth } from '@/lib/contexts/auth-context';\r\nimport { useStore } from '@/store/useStore';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport { storage } from '@/services/storage';\r\nimport { supabaseDatabaseService } from '@/lib/services/supabase-database.service';\r\n\r\ninterface ProfileModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n}\r\n\r\n/**\r\n * Compact profile modal component with user info and logout\r\n * @param {ProfileModalProps} props - Component props\r\n * @returns {JSX.Element} Profile modal component\r\n */\r\nexport function ProfileModal({ isOpen, onClose }: ProfileModalProps): React.JSX.Element {\r\n  const { user } = useAuth();\r\n  const router = useRouter();\r\n  const links = useStore((state) => state.links);\r\n  const folders = useStore((state) => state.folders);\r\n  const importData = useStore((state) => state.importData);\r\n  const exportData = useStore((state) => state.exportData);\r\n  const { toast } = useToast();\r\n\r\n  const fileInputRef = React.useRef<HTMLInputElement>(null);\r\n  const [showClearConfirm, setShowClearConfirm] = useState(false);\r\n  const [isClearing, setIsClearing] = useState(false);\r\n\r\n  // Calculate statistics\r\n  const storageSize = storage.getStorageSize();\r\n  const storageKB = storageSize / 1024;\r\n  const storageMB = storageSize / (1024 * 1024);\r\n  \r\n  const formattedStorage = storageMB >= 1 \r\n    ? `${storageMB.toFixed(2)} MB` \r\n    : `${storageKB.toFixed(2)} KB`;\r\n  \r\n  // Count only user-created folders (exclude platform folders)\r\n  const userCreatedFolders = folders.filter(f => !f.isPlatformFolder).length;\r\n  \r\n  // Format join date\r\n  const joinDate = user?.created_at \r\n    ? new Date(user.created_at).toLocaleDateString('en-US', {\r\n        year: 'numeric',\r\n        month: 'long',\r\n        day: 'numeric'\r\n      })\r\n    : 'Unknown';\r\n\r\n  // Get display name or fallback\r\n  const displayName = user?.profile?.display_name || user?.email?.split('@')[0] || 'User';\r\n  const email = user?.email || 'No email';\r\n\r\n  /**\r\n   * Handle data export\r\n   */\r\n  const handleExport = () => {\r\n    try {\r\n      const data = exportData();\r\n      const blob = new Blob([JSON.stringify(data, null, 2)], {\r\n        type: 'application/json',\r\n      });\r\n      const url = URL.createObjectURL(blob);\r\n      const a = document.createElement('a');\r\n      a.href = url;\r\n      a.download = `linkvault-backup-${new Date().toISOString().split('T')[0]}.json`;\r\n      document.body.appendChild(a);\r\n      a.click();\r\n      document.body.removeChild(a);\r\n      URL.revokeObjectURL(url);\r\n\r\n      toast({\r\n        title: \"Exported\",\r\n        variant: \"success\",\r\n      });\r\n    } catch (error) {\r\n      logger.error('Export failed:', error);\r\n        toast({\r\n          title: \"Export failed\",\r\n          description: \"Please try again\",\r\n          variant: \"destructive\",\r\n        });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handle data import\r\n   */\r\n  const handleImport = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const file = event.target.files?.[0];\r\n    if (!file) return;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = (e) => {\r\n      try {\r\n        const data = JSON.parse(e.target?.result as string);\r\n        importData(data);\r\n        toast({\r\n          title: \"Imported\",\r\n          variant: \"success\",\r\n        });\r\n      } catch (error) {\r\n        logger.error('Import failed:', error);\r\n        toast({\r\n          title: \"Import failed\",\r\n          description: \"Invalid file format\",\r\n          variant: \"destructive\",\r\n        });\r\n      }\r\n    };\r\n    reader.readAsText(file);\r\n    \r\n    // Reset file input\r\n    if (fileInputRef.current) {\r\n      fileInputRef.current.value = '';\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handle clear all data\r\n   */\r\n  const handleClearData = () => {\r\n    setShowClearConfirm(true);\r\n  };\r\n\r\n  /**\r\n   * Confirm clear all data - delete from Supabase database\r\n   */\r\n  const confirmClearData = async () => {\r\n    setIsClearing(true);\r\n    \r\n    try {\r\n      // Delete from Supabase database\r\n      await Promise.all([\r\n        supabaseDatabaseService.deleteAllLinks(),\r\n        supabaseDatabaseService.deleteAllFolders(),\r\n        supabaseDatabaseService.deleteUserSettings(),\r\n      ]);\r\n      \r\n      storage.clear();\r\n      \r\n      toast({\r\n        title: \"Data deleted\",\r\n        variant: \"info\",\r\n      });\r\n      \r\n      // Close modal and redirect to login\r\n      setShowClearConfirm(false);\r\n      onClose();\r\n      \r\n      // Redirect after a short delay to show toast\r\n      setTimeout(() => {\r\n        window.location.href = '/login';\r\n      }, 1000);\r\n    } catch (error) {\r\n      logger.error('Error clearing data:', error);\r\n      toast({\r\n        title: \"Error\",\r\n        description: \"Please try again\",\r\n        variant: \"destructive\",\r\n      });\r\n    } finally {\r\n      setIsClearing(false);\r\n    }\r\n  };\r\n\r\n\r\n\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-[400px] border border-gray-200 dark:border-gray-800\" aria-describedby=\"profile-dialog-description\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"flex items-center gap-2\">\r\n            <User className=\"size-5\" />\r\n            Profile\r\n          </DialogTitle>\r\n          <DialogDescription id=\"profile-dialog-description\" className=\"sr-only\">\r\n            Manage your profile and data\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        <div className=\"space-y-4\">\r\n          {/* User Info */}\r\n          <div className=\"space-y-3 p-4 rounded-lg bg-gray-50 dark:bg-black border border-gray-200 dark:border-gray-800\">\r\n            <div className=\"flex items-center justify-between\">\r\n              <span className=\"text-sm font-medium text-gray-900 dark:text-white\">{displayName}</span>\r\n            </div>\r\n            \r\n            <div className=\"flex items-center gap-2 text-sm text-gray-600 dark:text-gray-300\">\r\n              <Mail className=\"size-3 text-gray-600 dark:text-gray-300\" />\r\n              <span>{email}</span>\r\n            </div>\r\n            \r\n            <div className=\"flex items-center gap-2 text-sm text-gray-600 dark:text-gray-300\">\r\n              <Calendar className=\"size-3 text-gray-600 dark:text-gray-300\" />\r\n              <span>Joined {joinDate}</span>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Quick Stats */}\r\n          <div className=\"grid grid-cols-3 gap-3 p-4 rounded-lg bg-gray-50 dark:bg-black border border-gray-200 dark:border-gray-800\">\r\n            <div className=\"text-center\">\r\n              <Link2 className=\"size-4 text-blue-500 dark:text-blue-400 mx-auto mb-1\" />\r\n              <p className=\"text-lg font-bold text-gray-900 dark:text-white\">{links.length}</p>\r\n              <p className=\"text-xs text-gray-600 dark:text-gray-400\">Links</p>\r\n            </div>\r\n            \r\n            <div className=\"text-center\">\r\n              <FolderOpen className=\"size-4 text-green-500 dark:text-green-400 mx-auto mb-1\" />\r\n              <p className=\"text-lg font-bold text-gray-900 dark:text-white\">{userCreatedFolders}</p>\r\n              <p className=\"text-xs text-gray-600 dark:text-gray-400\">Folders</p>\r\n            </div>\r\n            \r\n            <div className=\"text-center\">\r\n              <HardDrive className=\"size-4 text-purple-500 dark:text-purple-400 mx-auto mb-1\" />\r\n              <p className=\"text-lg font-bold text-gray-900 dark:text-white\">{formattedStorage}</p>\r\n              <p className=\"text-xs text-gray-600 dark:text-gray-400\">Storage</p>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Actions */}\r\n          <div className=\"space-y-2\">\r\n            <div className=\"grid grid-cols-2 gap-2\">\r\n              <Button onClick={handleExport} variant=\"outline\" size=\"sm\" className=\"gap-2\">\r\n                <Download className=\"size-3\" />\r\n                Export\r\n              </Button>\r\n              <Button\r\n                onClick={() => fileInputRef.current?.click()}\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                className=\"gap-2\"\r\n              >\r\n                <Upload className=\"size-3\" />\r\n                Import\r\n              </Button>\r\n            </div>\r\n            \r\n            <Button\r\n              onClick={handleClearData}\r\n              variant=\"destructive\"\r\n              size=\"sm\"\r\n              className=\"w-full gap-2 bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 border-red-600 dark:border-red-700 text-white font-semibold\"\r\n            >\r\n              <Trash2 className=\"size-3\" />\r\n              Clear All Data\r\n            </Button>\r\n          </div>\r\n\r\n          <input\r\n            ref={fileInputRef}\r\n            type=\"file\"\r\n            accept=\"application/json\"\r\n            onChange={handleImport}\r\n            className=\"hidden\"\r\n          />\r\n        </div>\r\n      </DialogContent>\r\n\r\n      {/* Clear All Data Confirmation Modal */}\r\n      <ConfirmModal\r\n        isOpen={showClearConfirm}\r\n        onClose={() => !isClearing && setShowClearConfirm(false)}\r\n        onConfirm={confirmClearData}\r\n        title=\"Permanently delete all data?\"\r\n        description=\"ΓÜá∩╕Å WARNING: All your links, folders, and settings will be PERMANENTLY DELETED from the database. This will affect all your devices and CANNOT be undone!\"\r\n        confirmText={isClearing ? \"Clearing...\" : \"Delete Everything\"}\r\n        variant=\"destructive\"\r\n      />\r\n    </Dialog>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\restore-all-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":22,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file components/modals/restore-all-modal.tsx\r\n * @description Modal for confirming restore all action\r\n * @created 2025-10-31\r\n */\r\n\r\n\"use client\";\r\n\r\nimport { AlertCircle, RotateCcw } from \"lucide-react\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { cn as themeCn } from \"@/lib/theme\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogFooter,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { Button } from \"@/components/ui/button\";\r\n\r\ninterface RestoreAllModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  onConfirm: () => void;\r\n  trashCount: number;\r\n}\r\n\r\n/**\r\n * Restore all confirmation modal\r\n * Confirms user wants to restore all trashed items\r\n * \r\n * @param {RestoreAllModalProps} props - Component props\r\n * @returns {JSX.Element} Restore all modal component\r\n */\r\nexport function RestoreAllModal({\r\n  isOpen,\r\n  onClose,\r\n  onConfirm,\r\n  trashCount,\r\n}: RestoreAllModalProps) {\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-[440px]\">\r\n        <DialogHeader>\r\n          <div className=\"flex items-center gap-3\">\r\n            <div className=\"flex h-12 w-12 items-center justify-center rounded-full bg-green-500/10 dark:bg-green-500/20\">\r\n              <RotateCcw className=\"h-6 w-6 text-green-600 dark:text-green-500\" />\r\n            </div>\r\n            <div>\r\n              <DialogTitle>Restore All Items?</DialogTitle>\r\n              <DialogDescription className=\"mt-1\">\r\n                Restore all items from trash\r\n              </DialogDescription>\r\n            </div>\r\n          </div>\r\n        </DialogHeader>\r\n\r\n        <div className=\"py-4\">\r\n          <p className=\"text-sm text-muted-foreground\">\r\n            All <span className=\"font-semibold text-foreground\">{trashCount}</span> {trashCount === 1 ? 'item' : 'items'} in the trash will be restored. \r\n            {trashCount === 1 ? 'It' : 'They'} will be moved back to {trashCount === 1 ? 'its' : 'their'} original location.\r\n          </p>\r\n        </div>\r\n\r\n        <DialogFooter>\r\n          <Button\r\n            variant=\"outline\"\r\n            onClick={onClose}\r\n            className=\"h-9\"\r\n          >\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            onClick={() => {\r\n              onConfirm();\r\n              onClose();\r\n            }}\r\n            className={themeCn(\r\n              \"h-9 bg-green-600 hover:bg-green-700 text-white\",\r\n              \"dark:bg-green-600 dark:hover:bg-green-700\"\r\n            )}\r\n          >\r\n            <RotateCcw className=\"mr-2 h-4 w-4\" />\r\n            Restore All\r\n          </Button>\r\n        </DialogFooter>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\settings-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":21,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/modals/settings-modal.tsx\r\n * @description Minimal settings modal with theme toggle and coming soon features\r\n * @created 2025-10-18\r\n */\r\n\r\nimport React, { useState } from \"react\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\r\nimport { ThemeToggle } from \"@/components/common/theme-toggle\";\r\nimport { Palette, Sparkles } from \"lucide-react\";\r\n\r\ninterface SettingsModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n}\r\n\r\n/**\r\n* Minimal settings modal with theme toggle and coming soon features.\r\n* @param {SettingsModalProps} props - Props object containing modal visibility flag and close handler.\r\n* @returns {JSX.Element} JSX element representing the rendered settings modal.\r\n**/\r\nexport function SettingsModal({ isOpen, onClose }: SettingsModalProps) {\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <DialogContent className=\"sm:max-w-[420px] border border-border/50 backdrop-blur-sm\" aria-describedby=\"settings-dialog-description\">\r\n        <DialogHeader className=\"pb-2\">\r\n          <DialogTitle className=\"text-lg font-semibold\">Settings</DialogTitle>\r\n          <DialogDescription id=\"settings-dialog-description\" className=\"sr-only\">\r\n            Configure app settings and preferences\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        <Tabs defaultValue=\"appearance\" className=\"w-full\">\r\n          <TabsList className=\"grid w-full grid-cols-2 mb-6\">\r\n            <TabsTrigger value=\"appearance\" className=\"flex items-center gap-2 text-sm\">\r\n              <Palette className=\"h-4 w-4\" />\r\n              Theme\r\n            </TabsTrigger>\r\n            <TabsTrigger value=\"coming-soon\" className=\"flex items-center gap-2 text-sm\">\r\n              <Sparkles className=\"h-4 w-4\" />\r\n              More\r\n            </TabsTrigger>\r\n          </TabsList>\r\n\r\n          <TabsContent value=\"appearance\" className=\"space-y-6 mt-0\">\r\n            <div className=\"flex items-center justify-between py-4 px-1\">\r\n              <div className=\"space-y-1\">\r\n                <p className=\"text-sm font-medium\">Appearance</p>\r\n                <p className=\"text-xs text-muted-foreground\">\r\n                  Switch between light and dark themes\r\n                </p>\r\n              </div>\r\n              <div className=\"transform transition-transform duration-200 hover:scale-105\">\r\n                <ThemeToggle />\r\n              </div>\r\n            </div>\r\n          </TabsContent>\r\n\r\n          <TabsContent value=\"coming-soon\" className=\"space-y-6 mt-0\">\r\n            <div className=\"text-center py-8 px-4\">\r\n              <div className=\"mx-auto w-16 h-16 bg-gradient-to-br from-primary/20 to-primary/10 rounded-full flex items-center justify-center mb-4\">\r\n                <Sparkles className=\"h-8 w-8 text-primary animate-pulse\" />\r\n              </div>\r\n              <h3 className=\"text-lg font-semibold mb-2\">More Features Coming Soon</h3>\r\n              <p className=\"text-sm text-muted-foreground leading-relaxed\">\r\n                We&apos;re working on exciting new features to enhance your LinksVault experience.\r\n                Stay tuned for updates!\r\n              </p>\r\n            </div>\r\n          </TabsContent>\r\n        </Tabs>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\modals\\share-folder-modal.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":12,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { useState, useEffect, useCallback } from 'react';\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@/components/ui/dialog';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Label } from '@/components/ui/label';\r\nimport { Copy, Link as LinkIcon, Eye, EyeOff, CheckCircle, Share2 } from 'lucide-react';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useStore } from '@/store/useStore';\r\n\r\ninterface ShareFolderModalProps {\r\n  isOpen?: boolean;\r\n  onClose?: () => void;\r\n  folder?: {\r\n    id: string;\r\n    name: string;\r\n    linkCount: number;\r\n  };\r\n}\r\n\r\nexport function ShareFolderModal({ isOpen, onClose, folder }: ShareFolderModalProps) {\r\n  const [isGenerating, setIsGenerating] = useState(false);\r\n  const [shareUrl, setShareUrl] = useState('');\r\n  const [copySuccess, setCopySuccess] = useState(false);\r\n\r\n  // Store-based state for global modal usage\r\n  const isShareFolderModalOpen = useStore((state) => state.isShareFolderModalOpen);\r\n  const setShareFolderModalOpen = useStore((state) => state.setShareFolderModalOpen);\r\n  const folderToShare = useStore((state) => state.folderToShare);\r\n\r\n  // Use props if provided, otherwise fall back to store\r\n  const effectiveIsOpen = isOpen !== undefined ? isOpen : isShareFolderModalOpen;\r\n  const effectiveFolder = folder || folderToShare;\r\n  const effectiveOnClose = onClose || (() => setShareFolderModalOpen(false));\r\n\r\n  const { toast } = useToast();\r\n\r\n  // Clean component initialization (minimal logging)\r\n  useEffect(() => {\r\n    if (isOpen !== undefined || folder !== undefined) {\r\n      console.log('ShareFolderModal: Initialized');\r\n    }\r\n  }, [isOpen, folder]);\r\n\r\n  const generateShareUrl = useCallback(async () => {\r\n    // Prevent multiple simultaneous calls\r\n    if (!effectiveFolder || isGenerating || shareUrl) return;\r\n\r\n    setIsGenerating(true);\r\n\r\n    try {\r\n      const response = await fetch(`/api/folders/${effectiveFolder.id}/share`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({}),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorData = await response.json();\r\n        throw new Error(errorData.error || `Failed to create share link (Status: ${response.status})`);\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      if (data.success) {\r\n        setShareUrl(data.shareUrl);\r\n        toast({\r\n          title: \"Share link created\",\r\n          description: \"Your folder is now shareable with a secure link.\",\r\n        });\r\n      } else {\r\n        throw new Error('Failed to create share link');\r\n      }\r\n    } catch (error) {\r\n      console.error('Share link creation failed:', error);\r\n      toast({\r\n        variant: \"destructive\",\r\n        title: \"Error creating share link\",\r\n        description: error instanceof Error ? error.message : \"Please try again.\",\r\n      });\r\n    } finally {\r\n      setIsGenerating(false);\r\n    }\r\n  }, [effectiveFolder, isGenerating, shareUrl, toast]);\r\n\r\n  useEffect(() => {\r\n    // Clear share URL when modal closes\r\n    if (!effectiveIsOpen) {\r\n      setShareUrl('');\r\n      setCopySuccess(false);\r\n    }\r\n  }, [effectiveIsOpen]);\r\n\r\n  useEffect(() => {\r\n    // Auto-create share when modal opens (only once)\r\n    if (effectiveIsOpen && effectiveFolder && !shareUrl && !isGenerating) {\r\n      generateShareUrl();\r\n    }\r\n  }, [effectiveIsOpen, effectiveFolder, shareUrl, generateShareUrl, isGenerating]);\r\n\r\n  const handleCopyUrl = useCallback(async () => {\r\n    if (!shareUrl) return;\r\n\r\n    try {\r\n      await navigator.clipboard.writeText(shareUrl);\r\n      setCopySuccess(true);\r\n      setTimeout(() => setCopySuccess(false), 2000);\r\n\r\n      toast({\r\n        title: \"Link copied\",\r\n        description: \"Share link copied to clipboard.\",\r\n      });\r\n    } catch (error) {\r\n      toast({\r\n        variant: \"destructive\",\r\n        title: \"Failed to copy\",\r\n        description: \"Please copy the link manually.\",\r\n      });\r\n    }\r\n  }, [shareUrl, toast]);\r\n\r\n  const handleClose = useCallback(() => {\r\n    effectiveOnClose();\r\n    setShareUrl('');\r\n    setCopySuccess(false);\r\n  }, [effectiveOnClose]);\r\n\r\n  // Removed excessive render logging for cleaner console\r\n\r\n  return (\r\n    <Dialog open={effectiveIsOpen || false} onOpenChange={(open) => {\r\n      if (!open) {\r\n        handleClose();\r\n      }\r\n    }}>\r\n      <DialogContent className=\"sm:max-w-md max-w-full mx-4\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"flex items-center gap-2\">\r\n            <Share2 className=\"h-5 w-5 text-orange-500\" />\r\n            Share Folder\r\n          </DialogTitle>\r\n          <DialogDescription>\r\n            Share &ldquo;{effectiveFolder?.name}&rdquo; ({effectiveFolder?.linkCount} links)\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n\r\n        <div className=\"space-y-4\">\r\n          {/* Share URL Display */}\r\n          <div className=\"space-y-2\">\r\n            <Label htmlFor=\"share-url\">Share Link</Label>\r\n            <div className=\"flex gap-2 flex-col sm:flex-row\">\r\n              <div className=\"flex-1\">\r\n                <Input\r\n                  id=\"share-url\"\r\n                  value={shareUrl || ''}\r\n                  readOnly\r\n                  className=\"font-mono text-sm break-all\"\r\n                  placeholder={isGenerating ? \"Generating share link...\" : \"Click Share to generate link\"}\r\n                />\r\n              </div>\r\n              {isGenerating && (\r\n                <div className=\"flex items-center justify-center sm:justify-start\">\r\n                  <div className=\"animate-spin-gpu rounded-full border-2 border-orange-500 border-t-transparent h-4 w-4\" />\r\n                </div>\r\n              )}\r\n              <div className=\"sm:min-w-[80px]\">\r\n                <Button\r\n                  onClick={handleCopyUrl}\r\n                  variant=\"outline\"\r\n                  size=\"sm\"\r\n                  className=\"w-full sm:w-auto\"\r\n                  disabled={!shareUrl || isGenerating}\r\n                >\r\n                  {copySuccess ? (\r\n                    <CheckCircle className=\"h-4 w-4 text-green-500 mr-1\" />\r\n                  ) : (\r\n                    <Copy className=\"h-4 w-4 mr-1\" />\r\n                  )}\r\n                  Copy\r\n                </Button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Share Actions */}\r\n          <div className=\"flex gap-2 flex-col sm:flex-row\">\r\n            <Button\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              className=\"text-orange-500 hover:text-orange-600 flex-1 py-2\"\r\n              onClick={() => {\r\n                if (shareUrl) {\r\n                  window.open(shareUrl, '_blank');\r\n                }\r\n              }}\r\n              disabled={!shareUrl}\r\n            >\r\n              <Eye className=\"mr-2 h-4 w-4\" />\r\n              Preview\r\n            </Button>\r\n            <Button\r\n              onClick={handleClose}\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              className=\"flex-1 py-2\"\r\n            >\r\n              Close\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\providers\\query-provider.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":6,"column":43,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\r\nimport { useState } from 'react';\r\n\r\nexport function QueryProvider({ children }: { children: React.ReactNode }) {\r\n  const [queryClient] = useState(() => new QueryClient({\r\n    defaultOptions: {\r\n      queries: {\r\n        staleTime: 1000 * 60 * 60 * 24, // 24h\r\n        gcTime: 1000 * 60 * 60 * 24 * 7, // 7 days\r\n      },\r\n    },\r\n  }));\r\n\r\n  return (\r\n    <QueryClientProvider client={queryClient}>\r\n      {children}\r\n    </QueryClientProvider>\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\providers\\resource-hints.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":13,"column":33,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/providers/resource-hints.tsx\r\n * @description Adds resource hints for faster external resource loading\r\n * OPTIMIZED: Uses script tag for immediate execution before React hydration\r\n * @created 2025-11-06\r\n */\r\n\r\nexport function ResourceHints() {\r\n  // OPTIMIZED: Add resource hints immediately via script tag (runs before React hydration)\r\n  if (typeof window !== 'undefined' && !document.querySelector('link[data-resource-hints]')) {\r\n    const addResourceHint = (rel: string, href: string, crossOrigin?: string) => {\r\n      const existing = document.querySelector(`link[rel=\"${rel}\"][href=\"${href}\"]`);\r\n      if (!existing) {\r\n        const link = document.createElement('link');\r\n        link.rel = rel;\r\n        link.href = href;\r\n        link.setAttribute('data-resource-hints', 'true');\r\n        if (crossOrigin) {\r\n          link.setAttribute('crossOrigin', crossOrigin);\r\n        }\r\n        document.head.appendChild(link);\r\n      }\r\n    };\r\n\r\n    // Add preconnect and dns-prefetch for Supabase (critical for fast API calls)\r\n    addResourceHint('preconnect', 'https://supabase.co');\r\n    addResourceHint('dns-prefetch', 'https://supabase.co');\r\n    \r\n    // Get actual Supabase URL from environment or config\r\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';\r\n    if (supabaseUrl) {\r\n      try {\r\n        const url = new URL(supabaseUrl);\r\n        addResourceHint('preconnect', url.origin);\r\n        addResourceHint('dns-prefetch', url.origin);\r\n      } catch {\r\n        // Invalid URL, skip\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\providers\\store-initializer.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token {","line":24,"column":13,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/providers/store-initializer.tsx\r\n * @description Initializes store from Supabase and sets up real-time sync\r\n * @created 2025-10-18\r\n * @updated 2025-11-02 - Added Supabase integration with real-time sync\r\n * @updated 2025-11-02 - Fixed authentication timing issue\r\n * @updated 2025-11-12 - Fixed undefined function references\r\n */\r\n\r\nimport React, { useEffect, useRef } from 'react';\r\nimport { useLinksStore } from '@/store/useLinksStore';\r\nimport { useFoldersStore } from '@/store/useFoldersStore';\r\nimport { useSettingsStore } from '@/store/useSettingsStore';\r\nimport { useUIStore } from '@/store/useUIStore';\r\nimport { useAuth } from '@/lib/contexts/auth-context';\r\nimport { supabaseDatabaseService } from '@/lib/services/supabase-database.service';\r\nimport { performanceMonitor } from '@/lib/services/performance-monitor.service';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport { DEFAULT_SETTINGS } from '@/constants';\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { Link, Folder, AppSettings } from '@/types';\r\nimport type { AuthResponse } from '@supabase/supabase-js';\r\n\r\nexport function StoreInitializer() {\r\n  // Use modular stores\r\n  const { setLinks } = useLinksStore();\r\n  const { setFolders } = useFoldersStore();\r\n  const { setSettings, loadSettings } = useSettingsStore();\r\n  const { setHydrated, setIsLoadingData } = useUIStore();\r\n  const { user, loading: authLoading } = useAuth();\r\n  const hasLoaded = useRef(false);\r\n  const prevUserId = useRef<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    // CRITICAL: Check for logout flag in localStorage (set by logout handler)\r\n    // This prevents loading data after logout\r\n    if (typeof window !== 'undefined') {\r\n      const isLoggingOut = localStorage.getItem('linkvault_logging_out');\r\n      if (isLoggingOut === 'true') {\r\n        // Logout in progress, don't load data\r\n        setHydrated(true);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Wait for authentication to complete\r\n    if (authLoading) {\r\n      return; // Still loading auth, don't do anything yet\r\n    }\r\n\r\n    // Check if user has changed (logout or login with different user)\r\n    const currentUserId = user?.id || null;\r\n    if (prevUserId.current !== currentUserId) {\r\n      // User changed, clear old data and reset loading state\r\n      setLinks([]);\r\n      setFolders([]);\r\n      loadSettings(); // This will load from Supabase\r\n      hasLoaded.current = false;\r\n      // Force re-render by setting isHydrated to false\r\n      setHydrated(false);\r\n    }\r\n    prevUserId.current = currentUserId;\r\n\r\n    // Only load data if user is authenticated\r\n    if (!user) {\r\n      // No user, don't try to load data\r\n      // Set hydrated to true so app doesn't show infinite loading\r\n      setHydrated(true);\r\n      return;\r\n    }\r\n\r\n    // Prevent double loading\r\n    if (hasLoaded.current) {\r\n      return;\r\n    }\r\n    hasLoaded.current = true;\r\n\r\n    // CRITICAL: Enhanced session validation with mobile-specific handling\r\n    const validateSessionAndLoad = async () => {\r\n      try {\r\n        // Mobile browsers need special handling due to storage limitations\r\n        const isMobile = typeof window !== 'undefined' &&\r\n          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n\r\n        if (isMobile) {\r\n          logger.debug('Mobile browser detected, using enhanced session validation');\r\n\r\n          // Try multiple session validation strategies for mobile\r\n          let session = null;\r\n          let validationError = null;\r\n\r\n          // Strategy 1: Direct Supabase session check\r\n          try {\r\n            const { data: { session: supabaseSession }, error } = await createClient().auth.getSession();\r\n            if (!error && supabaseSession) {\r\n              session = supabaseSession;\r\n              logger.debug('Mobile session validated via Supabase');\r\n            }\r\n          } catch (error) {\r\n            validationError = error;\r\n            logger.warn('Mobile Supabase session validation failed:', error);\r\n          }\r\n\r\n          // Strategy 2: If no session found, try manual localStorage check\r\n          if (!session && typeof window !== 'undefined') {\r\n            try {\r\n              const storedSession = localStorage.getItem('sb-' + process.env.NEXT_PUBLIC_SUPABASE_URL?.split('//')[1]?.split('.')[0] + '-auth-token');\r\n              if (storedSession) {\r\n                const sessionData = JSON.parse(storedSession);\r\n                if (sessionData?.access_token && sessionData?.user) {\r\n                  // Try to set the session manually\r\n                  const { data: { session: manualSession }, error } = await createClient().auth.setSession({\r\n                    access_token: sessionData.access_token,\r\n                    refresh_token: sessionData.refresh_token\r\n                  });\r\n\r\n                  if (!error && manualSession) {\r\n                    session = manualSession;\r\n                    logger.debug('Mobile session recovered via localStorage');\r\n                  }\r\n                }\r\n              }\r\n            } catch (storageError) {\r\n              logger.warn('Mobile localStorage session recovery failed:', storageError);\r\n            }\r\n          }\r\n\r\n          if (!session) {\r\n            logger.warn('Mobile session validation failed completely, skipping data load');\r\n            setHydrated(true);\r\n            return;\r\n          }\r\n        } else {\r\n          // Standard session validation for desktop\r\n          const { data: { session }, error } = await createClient().auth.getSession();\r\n          if (error || !session) {\r\n            logger.warn('Desktop session validation failed, skipping data load');\r\n            setHydrated(true);\r\n            return;\r\n          }\r\n        }\r\n\r\n        // Session is valid, proceed with data loading\r\n        initializeData();\r\n      } catch (error) {\r\n        logger.error('Session validation error:', error);\r\n        setHydrated(true);\r\n      }\r\n    };\r\n\r\n    // Function to load data from Supabase\r\n    const loadDataFromSupabase = async () => {\r\n      try {\r\n        logger.debug('Loading data from Supabase...');\r\n        \r\n        // Load all data in parallel\r\n        const [settingsResult, foldersResult, linksResult] = await Promise.allSettled([\r\n          supabaseDatabaseService.getSettings(),\r\n          supabaseDatabaseService.getFolders(),\r\n          supabaseDatabaseService.getLinks()\r\n        ]);\r\n\r\n        // Extract results with fallbacks\r\n        const settings: AppSettings = settingsResult.status === 'fulfilled' && settingsResult.value \r\n          ? settingsResult.value \r\n          : DEFAULT_SETTINGS;\r\n        const folders: Folder[] = foldersResult.status === 'fulfilled' && foldersResult.value \r\n          ? foldersResult.value \r\n          : [];\r\n        const links: Link[] = linksResult.status === 'fulfilled' && linksResult.value \r\n          ? linksResult.value \r\n          : [];\r\n\r\n        logger.debug(`Loaded ${links.length} links, ${folders.length} folders`);\r\n\r\n        // Update stores\r\n        setLinks(links);\r\n        setFolders(folders);\r\n        setSettings(settings);\r\n      } catch (error) {\r\n        logger.error('Error loading data from Supabase:', error);\r\n        // Set defaults on error\r\n        setLinks([]);\r\n        setFolders([]);\r\n        setSettings(DEFAULT_SETTINGS);\r\n        throw error;\r\n      }\r\n    };\r\n\r\n    // OPTIMIZED: Initial load from Supabase - completely non-blocking\r\n    const initializeData = async () => {\r\n      // OPTIMIZED: Set hydrated immediately to allow instant UI render\r\n      // This ensures LCP happens as fast as possible\r\n      setHydrated(true);\r\n      \r\n      // NEW: Set data loading state to true\r\n      setIsLoadingData(true);\r\n      \r\n      // OPTIMIZED: Use requestIdleCallback if available for even better performance\r\n      // Otherwise use setTimeout(0) to defer to next tick\r\n      // CRITICAL: Defer data loading to prevent blocking LCP\r\n      const deferLoad = typeof window !== 'undefined' && 'requestIdleCallback' in window\r\n        ? (fn: () => void) => {\r\n            (window as any).requestIdleCallback(fn, { timeout: 200 });\r\n          }\r\n        : (fn: () => void) => setTimeout(fn, 0);\r\n      \r\n      // Load data in background without blocking - deferred to next tick\r\n      deferLoad(async () => {\r\n        try {\r\n          await loadDataFromSupabase();\r\n        } catch (error) {\r\n          logger.error('Failed to load initial data:', error);\r\n          \r\n          // Enhanced error recovery with progressive fallbacks\r\n          try {\r\n            logger.debug('Attempting enhanced fallback data load...');\r\n            \r\n            // Try to load individual components that might still work\r\n            const supabase = createClient();\r\n            \r\n            supabase.auth.getUser().then(async (response: AuthResponse) => {\r\n              const authUser = response.data.user;\r\n              if (!authUser) {\r\n                setHydrated(true);\r\n                setLinks([]);\r\n                setFolders([]);\r\n                setSettings(DEFAULT_SETTINGS);\r\n                return;\r\n              }\r\n              \r\n              // OPTIMIZED: Load all data in parallel with individual error handling\r\n              const [settingsResult, foldersResult, linksResult] = await Promise.allSettled([\r\n                supabaseDatabaseService.getSettings().catch(() => null),\r\n                supabaseDatabaseService.getFolders().catch(() => []),\r\n                Promise.race([\r\n                  supabaseDatabaseService.getLinks(),\r\n                  new Promise<never>((_, reject) => \r\n                    setTimeout(() => reject(new Error('Links fallback timeout')), 5000)\r\n                  )\r\n                ]).catch(() => [])\r\n              ]);\r\n\r\n              // Extract results with fallbacks\r\n              const settings: AppSettings = settingsResult.status === 'fulfilled' && settingsResult.value \r\n                ? settingsResult.value \r\n                : DEFAULT_SETTINGS;\r\n              const folders: Folder[] = foldersResult.status === 'fulfilled' && foldersResult.value \r\n                ? foldersResult.value \r\n                : [];\r\n              const links: Link[] = linksResult.status === 'fulfilled' && linksResult.value \r\n                ? linksResult.value \r\n                : [];\r\n\r\n              logger.debug(`Fallback load: ${links.length} links, ${folders.length} folders, settings: ${settings ? 'loaded' : 'default'}`);\r\n\r\n              // Set partial data\r\n              setHydrated(true);\r\n              setLinks(links || []);\r\n              setFolders(folders || []);\r\n              setSettings(settings || DEFAULT_SETTINGS);\r\n              \r\n              logger.debug('Enhanced fallback load completed with partial data');\r\n            }).catch((fallbackError: unknown) => {\r\n              logger.error('Enhanced fallback load also failed:', fallbackError);\r\n              \r\n              // Final safety net: ensure app doesn't get stuck\r\n              setHydrated(true);\r\n              setLinks([]);\r\n              setFolders([]);\r\n              setSettings(DEFAULT_SETTINGS);\r\n              \r\n              logger.debug('Safety net activated - app ready with minimal state');\r\n            });\r\n          } catch (fallbackError: unknown) {\r\n            logger.error('Fallback initialization failed:', fallbackError);\r\n          }\r\n          \r\n          // Track the error for monitoring\r\n          performanceMonitor.trackError({\r\n            message: `Store initialization failed: ${(error as Error).message}`,\r\n            severity: 'high',\r\n            context: {\r\n              hasUser: !!user,\r\n              errorType: (error as Error).constructor.name,\r\n              fallbackUsed: true\r\n            }\r\n          });\r\n          \r\n          // Reset hasLoaded to allow retry on next auth change\r\n          hasLoaded.current = false;\r\n        } finally {\r\n          // NEW: Always set data loading to false when done\r\n          setIsLoadingData(false);\r\n        }\r\n      });\r\n    };\r\n\r\n    // Start validation and data loading\r\n    validateSessionAndLoad();\r\n\r\n    // Set up real-time subscriptions with proper error handling and retry logic\r\n    let unsubscribeLinks: (() => void) | null = null;\r\n    let unsubscribeFolders: (() => void) | null = null;\r\n    let subscriptionTimeout: NodeJS.Timeout | null = null;\r\n    let retryTimeout: NodeJS.Timeout | null = null;\r\n    let isComponentMounted = true;\r\n    let retryCount = 0;\r\n    const maxRetries = 3;\r\n    \r\n    const setupSubscriptions = () => {\r\n      if (!isComponentMounted) return;\r\n\r\n      try {\r\n        // OPTIMIZED: Make realtime subscriptions gracefully degrade if they fail\r\n        // This prevents blocking the app if WebSocket connections fail\r\n        unsubscribeLinks = supabaseDatabaseService.subscribeToLinks((updatedLinks) => {\r\n          if (isComponentMounted) {\r\n            setLinks(updatedLinks);\r\n            retryCount = 0; // Reset retry count on successful update\r\n          }\r\n        });\r\n\r\n        unsubscribeFolders = supabaseDatabaseService.subscribeToFolders((updatedFolders) => {\r\n          if (isComponentMounted) {\r\n            setFolders(updatedFolders);\r\n            retryCount = 0; // Reset retry count on successful update\r\n          }\r\n        });\r\n      } catch (error) {\r\n        // OPTIMIZED: Gracefully handle subscription failures\r\n        // App continues to work without realtime updates\r\n        logger.warn('Real-time subscriptions unavailable, app will continue without live updates:', error);\r\n        \r\n        // OPTIMIZED: Don't retry aggressively - realtime is not critical\r\n        // App will refetch data on navigation/refresh\r\n        if (retryCount === 0 && isComponentMounted) {\r\n          // Only retry once after 5 seconds\r\n          retryCount++;\r\n          retryTimeout = setTimeout(() => {\r\n            if (isComponentMounted) {\r\n              setupSubscriptions();\r\n            }\r\n          }, 5000);\r\n        }\r\n      }\r\n    };\r\n\r\n    // OPTIMIZED: Delay realtime subscriptions to prioritize initial data load\r\n    // Realtime is nice-to-have, not critical for app functionality\r\n    subscriptionTimeout = setTimeout(setupSubscriptions, 2000);\r\n\r\n    // Cleanup subscriptions on unmount\r\n    return () => {\r\n      isComponentMounted = false;\r\n      \r\n      if (subscriptionTimeout) {\r\n        clearTimeout(subscriptionTimeout);\r\n      }\r\n      \r\n      if (retryTimeout) {\r\n        clearTimeout(retryTimeout);\r\n      }\r\n      \r\n      // Safely cleanup subscriptions\r\n      try {\r\n        if (unsubscribeLinks) {\r\n          unsubscribeLinks();\r\n        }\r\n        if (unsubscribeFolders) {\r\n          unsubscribeFolders();\r\n        }\r\n        } catch (error) {\r\n          logger.error('Error cleaning up subscriptions:', error);\r\n        }\r\n    };\r\n  }, [user, authLoading, setLinks, setFolders, setSettings, loadSettings, setHydrated, setIsLoadingData]);\r\n\r\n  return null;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\components\\providers\\theme-provider.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ThemeProviderProps","line":10,"column":52,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file components/providers/theme-provider.tsx\r\n * @description Integrated theme provider combining next-themes and centralized theme system\r\n * @created 2025-10-18\r\n */\r\n\r\nimport * as React from \"react\";\r\nimport { ThemeProvider as NextThemesProvider, type ThemeProviderProps as NextThemeProviderProps } from \"next-themes\";\r\nimport { ThemeProvider as CentralizedThemeProvider } from \"@/lib/theme\";\r\n\r\n/**\r\n * Props for the ThemeProvider component\r\n */\r\ntype ThemeProviderProps = NextThemeProviderProps;\r\n\r\n/**\r\n * Integrated theme provider component that combines next-themes and centralized theme system\r\n * @param children - React children components\r\n * @param props - Theme provider configuration props\r\n * @returns JSX element\r\n */\r\nexport function ThemeProvider({ \r\n  children, \r\n  attribute = \"class\",\r\n  defaultTheme = \"system\",\r\n  enableSystem = true,\r\n  disableTransitionOnChange = false,\r\n  ...props \r\n}: ThemeProviderProps) {\r\n  return (\r\n    <NextThemesProvider \r\n      attribute={attribute}\r\n      defaultTheme={defaultTheme}\r\n      enableSystem={enableSystem}\r\n      disableTransitionOnChange={disableTransitionOnChange}\r\n      {...props}\r\n    >\r\n      <CentralizedThemeProvider>\r\n        {children}\r\n      </CentralizedThemeProvider>\r\n    </NextThemesProvider>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\constants\\auth.constants.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token as","line":39,"column":3,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file constants/auth.constants.ts\r\n * @description Authentication-related constants for consistent configuration\r\n * @created 2025-01-21\r\n */\r\n\r\nexport const AUTH_CONSTANTS = {\r\n    /**\r\n     * Interval for periodic session validation (milliseconds)\r\n     * Reduced from 30s to 120s to conserve mobile battery\r\n     */\r\n    SESSION_CHECK_INTERVAL: 120000, // 2 minutes\r\n\r\n    /**\r\n     * Timeout for auth initialization (milliseconds)\r\n     * Reduced from 35s/15s to 8s for faster feedback\r\n     */\r\n    INIT_TIMEOUT: 8000, // 8 seconds\r\n\r\n    /**\r\n     * Delay between retry attempts (milliseconds)\r\n     */\r\n    RETRY_DELAY: 500, // 500ms\r\n\r\n    /**\r\n     * Maximum number of retry attempts for session verification\r\n     */\r\n    MAX_RETRIES: 2,\r\n\r\n    /**\r\n     * Duration to wait after logout before allowing session recovery (milliseconds)\r\n     */\r\n    POST_LOGOUT_COOLDOWN: 300000, // 5 minutes\r\n\r\n    /**\r\n     * Timeout for network requests (milliseconds)\r\n     */\r\n    FETCH_TIMEOUT: 15000, // 15 seconds\r\n} as const;\r\n\r\n/**\r\n * User-friendly error messages for common auth errors\r\n */\r\nexport const AUTH_ERROR_MESSAGES = {\r\n    INVALID_CREDENTIALS: 'Invalid email or password. Please check your credentials and try again.',\r\n    EMAIL_NOT_CONFIRMED: 'Please verify your email address before signing in. Check your inbox for a verification link.',\r\n    TOO_MANY_REQUESTS: 'Too many login attempts. Please wait a few minutes and try again.',\r\n    NETWORK_ERROR: 'Network error. Please check your internet connection and try again.',\r\n    SESSION_NOT_ESTABLISHED: 'Session not established. Please try again.',\r\n    OFFLINE: 'You are currently offline. Please check your internet connection and try again.',\r\n    UNEXPECTED_ERROR: 'An unexpected error occurred. Please try again.',\r\n    SESSION_EXPIRED: 'Your session has expired. Please sign in again.',\r\n    INIT_TIMEOUT: 'Authentication is taking longer than expected. Please refresh the page or try logging in again.',\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\constants\\folder-icons.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token LucideIcon","line":38,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file constants/folder-icons.ts\r\n * @description Available icons for folder customization\r\n * @created 2025-10-18\r\n */\r\n\r\nimport {\r\n  Briefcase,\r\n  Code,\r\n  Folder,\r\n  Heart,\r\n  Home,\r\n  Image,\r\n  Music,\r\n  ShoppingCart,\r\n  Star,\r\n  Video,\r\n  // Social Media\r\n  Youtube,\r\n  Github,\r\n  Instagram,\r\n  Twitter,\r\n  Linkedin,\r\n  // Productivity\r\n  FileText,\r\n  Calendar,\r\n  Bookmark,\r\n  Clock,\r\n  // Technical\r\n  Database,\r\n  Terminal,\r\n  Cpu,\r\n  Lightbulb,\r\n  Zap,\r\n  Cloud,\r\n  Gift,\r\n  Map,\r\n  type LucideIcon,\r\n} from \"lucide-react\";\r\n\r\nexport interface FolderIconOption {\r\n  name: string;\r\n  icon: LucideIcon;\r\n  category: \"social\" | \"productivity\" | \"technical\" | \"general\";\r\n  color: string;\r\n}\r\n\r\nexport const FOLDER_ICONS: FolderIconOption[] = [\r\n  // Social Media\r\n  { name: \"Youtube\", icon: Youtube, category: \"social\", color: \"#FF0000\" },\r\n  { name: \"Instagram\", icon: Instagram, category: \"social\", color: \"#E4405F\" },\r\n  { name: \"Github\", icon: Github, category: \"social\", color: \"#333333\" },\r\n  { name: \"Twitter\", icon: Twitter, category: \"social\", color: \"#1DA1F2\" },\r\n  { name: \"Linkedin\", icon: Linkedin, category: \"social\", color: \"#0A66C2\" },\r\n\r\n  // Productivity\r\n  { name: \"Briefcase\", icon: Briefcase, category: \"productivity\", color: \"#8B4513\" },\r\n  { name: \"FileText\", icon: FileText, category: \"productivity\", color: \"#4B5563\" },\r\n  { name: \"Calendar\", icon: Calendar, category: \"productivity\", color: \"#DC2626\" },\r\n  { name: \"Bookmark\", icon: Bookmark, category: \"productivity\", color: \"#FFA500\" },\r\n  { name: \"Clock\", icon: Clock, category: \"productivity\", color: \"#6366F1\" },\r\n\r\n  // Technical\r\n  { name: \"Code\", icon: Code, category: \"technical\", color: \"#10B981\" },\r\n  { name: \"Database\", icon: Database, category: \"technical\", color: \"#3B82F6\" },\r\n  { name: \"Terminal\", icon: Terminal, category: \"technical\", color: \"#22C55E\" },\r\n  { name: \"Cpu\", icon: Cpu, category: \"technical\", color: \"#8B5CF6\" },\r\n  { name: \"Lightbulb\", icon: Lightbulb, category: \"technical\", color: \"#FCD34D\" },\r\n\r\n  // General\r\n  { name: \"Folder\", icon: Folder, category: \"general\", color: \"#F59E0B\" },\r\n  { name: \"Home\", icon: Home, category: \"general\", color: \"#059669\" },\r\n  { name: \"Heart\", icon: Heart, category: \"general\", color: \"#EF4444\" },\r\n  { name: \"Star\", icon: Star, category: \"general\", color: \"#FBBF24\" },\r\n  { name: \"Music\", icon: Music, category: \"general\", color: \"#EC4899\" },\r\n  { name: \"Zap\", icon: Zap, category: \"general\", color: \"#EAB308\" },\r\n  { name: \"Cloud\", icon: Cloud, category: \"general\", color: \"#0EA5E9\" }, // Sky-500\r\n  { name: \"Gift\", icon: Gift, category: \"general\", color: \"#F43F5E\" }, // Rose-500\r\n  { name: \"Map\", icon: Map, category: \"general\", color: \"#10B981\" }, // Emerald-500\r\n  { name: \"Video\", icon: Video, category: \"general\", color: \"#8B5CF6\" },\r\n  { name: \"Image\", icon: Image, category: \"general\", color: \"#14B8A6\" },\r\n  { name: \"ShoppingCart\", icon: ShoppingCart, category: \"general\", color: \"#F97316\" },\r\n];\r\n\r\n// Pre-defined default folders\r\nexport const PLATFORM_FOLDERS = [\r\n  {\r\n    name: \"YouTube\",\r\n    iconName: \"Youtube\",\r\n    platform: \"youtube\" as const,\r\n    color: \"#FF0000\",\r\n  },\r\n  {\r\n    name: \"Instagram\",\r\n    iconName: \"Instagram\",\r\n    platform: \"instagram\" as const,\r\n    color: \"#E4405F\",\r\n  },\r\n  {\r\n    name: \"Github\",\r\n    iconName: \"Github\",\r\n    platform: \"github\" as const,\r\n    color: \"#333333\",\r\n  },\r\n  {\r\n    name: \"Development\",\r\n    iconName: \"Code\",\r\n    platform: \"other\" as const,\r\n    color: \"#3B82F6\",\r\n  },\r\n  {\r\n    name: \"Research\",\r\n    iconName: \"Lightbulb\",\r\n    platform: \"other\" as const,\r\n    color: \"#FCD34D\",\r\n  },\r\n];\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\constants\\image.constants.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token as","line":53,"column":7,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file constants/image.constants.ts\r\n * @description Image loading and optimization constants\r\n * @created 2025-11-21\r\n */\r\n\r\n/**\r\n * Image quality and performance constants\r\n */\r\nexport const IMAGE_CONSTANTS = {\r\n    // Quality settings for Next.js Image component\r\n    QUALITY_HIGH: 75,      // Used for priority/above-the-fold images\r\n    QUALITY_STANDARD: 60,  // Used for lazy-loaded images (30-40% smaller file size)\r\n\r\n    // Priority image settings\r\n    PRIORITY_IMAGE_COUNT: 2,  // Number of images to load eagerly for LCP optimization\r\n\r\n    // Lazy loading configuration\r\n    INITIAL_LOAD_COUNT: 8,   // Initial batch of items to display\r\n    LOAD_MORE_COUNT: 8,      // Number of items to load when scrolling\r\n\r\n    // Blur placeholder for priority images (SVG base64)\r\n    BLUR_DATA_URL: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzAwIiBoZWlnaHQ9IjQ3NSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiLz4=',\r\n\r\n    /**\r\n     * Allowed image domains for Next.js Image optimization\r\n     * These domains are configured in next.config.ts\r\n     */\r\n    ALLOWED_DOMAINS: [\r\n        'img.youtube.com',\r\n        'i.ytimg.com',\r\n        'pbs.twimg.com',\r\n        'scontent.cdninstagram.com',\r\n        'instagram.com',\r\n        'media.licdn.com',\r\n        'avatars.githubusercontent.com',\r\n        'github.com',\r\n        'miro.medium.com',\r\n        'cdn-images-1.medium.com',\r\n        'external-preview.redd.it',\r\n        'preview.redd.it',\r\n        'scontent.xx.fbcdn.net',\r\n        'p16-sign-sg.tiktokcdn.com',\r\n        'images.unsplash.com',\r\n        'via.placeholder.com',\r\n        'c1.tablecdn.com',\r\n        'www.google.com',\r\n        'www.google.com.sg',\r\n        'favicons.githubusercontent.com',\r\n        'logo.clearbit.com',\r\n        'icons.duckduckgo.com',\r\n        'www.favicon.cc',\r\n    ] as const,\r\n} as const;\r\n\r\n/**\r\n * Fetch priority values for browser-level resource hints\r\n */\r\nexport const FETCH_PRIORITY = {\r\n    HIGH: 'high',\r\n    LOW: 'low',\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\constants\\index.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":9,"column":29,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file constants/index.ts\r\n * @description Application-wide constants and configuration\r\n * @created 2025-10-18\r\n */\r\n\r\nimport { Platform } from '@/types';\r\n\r\nexport const PLATFORM_CONFIG: Record<Platform, { \r\n  name: string; \r\n  color: string; \r\n  icon: string;\r\n  domains: string[];\r\n}> = {\r\n  youtube: {\r\n    name: 'YouTube',\r\n    color: '#FF0000',\r\n    icon: 'Youtube',\r\n    domains: ['youtube.com', 'youtu.be'],\r\n  },\r\n  twitter: {\r\n    name: 'Twitter',\r\n    color: '#1DA1F2',\r\n    icon: 'Twitter',\r\n    domains: ['twitter.com', 'x.com'],\r\n  },\r\n  instagram: {\r\n    name: 'Instagram',\r\n    color: '#E4405F',\r\n    icon: 'Instagram',\r\n    domains: ['instagram.com'],\r\n  },\r\n  linkedin: {\r\n    name: 'LinkedIn',\r\n    color: '#0077B5',\r\n    icon: 'Linkedin',\r\n    domains: ['linkedin.com'],\r\n  },\r\n  tiktok: {\r\n    name: 'TikTok',\r\n    color: '#000000',\r\n    icon: 'Music',\r\n    domains: ['tiktok.com'],\r\n  },\r\n  github: {\r\n    name: 'GitHub',\r\n    color: '#181717',\r\n    icon: 'Github',\r\n    domains: ['github.com'],\r\n  },\r\n  medium: {\r\n    name: 'Medium',\r\n    color: '#00AB6C',\r\n    icon: 'BookOpen',\r\n    domains: ['medium.com'],\r\n  },\r\n  reddit: {\r\n    name: 'Reddit',\r\n    color: '#FF4500',\r\n    icon: 'MessageCircle',\r\n    domains: ['reddit.com'],\r\n  },\r\n  facebook: {\r\n    name: 'Facebook',\r\n    color: '#1877F2',\r\n    icon: 'Facebook',\r\n    domains: ['facebook.com'],\r\n  },\r\n  other: {\r\n    name: 'Other',\r\n    color: '#6B7280',\r\n    icon: 'Link',\r\n    domains: [],\r\n  },\r\n};\r\n\r\nexport const STORAGE_KEYS = {\r\n  LINKS: 'linkvault_links',\r\n  FOLDERS: 'linkvault_folders',\r\n  SETTINGS: 'linkvault_settings',\r\n  CACHE: 'linkvault_cache',\r\n} as const;\r\n\r\nexport const DEFAULT_SETTINGS = {\r\n  theme: 'system' as const,\r\n  viewMode: 'grid' as const,\r\n};\r\n\r\n// Timing constants\r\nexport const DEBOUNCE_DELAY = 300; // ms\r\nexport const SEARCH_DEBOUNCE_DELAY = 300; // ms\r\nexport const METADATA_FETCH_TIMEOUT = 10000; // ms\r\nexport const INITIAL_LOAD_DELAY = 50; // ms for lazy loading - reduced for faster LCP\r\n\r\n// UI Animation constants\r\nexport const ANIMATION_DURATION = {\r\n  FAST: 300, // ms - for quick transitions\r\n  NORMAL: 500, // ms - for standard animations\r\n  SLOW: 1000, // ms - for slow animations\r\n} as const;\r\n\r\n// Toast constants\r\nexport const TOAST_DURATION = 2000; // ms - Shorter duration for better UX\r\nexport const TOAST_REMOVE_DELAY = 2000; // ms - Shorter delay for smoother experience\r\nexport const LOGIN_TOAST_DURATION = 1500; // ms - Even shorter for login success\r\n\r\n// Tooltip constants\r\nexport const TOOLTIP_DELAY = {\r\n  SHORT: 300, // ms\r\n  NORMAL: 500, // ms\r\n} as const;\r\n\r\n// Form validation constants\r\nexport const VALIDATION_LIMITS = {\r\n  DESCRIPTION_MAX_LENGTH: 500,\r\n  TITLE_MAX_LENGTH: 200,\r\n  URL_MAX_LENGTH: 2048,\r\n} as const;\r\n\r\n// Layout constants\r\nexport const LAYOUT = {\r\n  MIN_HEIGHT_EMPTY_STATE: 400, // px\r\n  ICON_SIZE_SMALL: 16, // px\r\n  ICON_SIZE_MEDIUM: 24, // px\r\n  ICON_SIZE_LARGE: 32, // px\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-debounce.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":24,"column":28,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file hooks/use-debounce.ts\r\n * @description Custom hook for debouncing values\r\n * @created 2025-10-18\r\n */\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { DEBOUNCE_DELAY } from '@/constants';\r\n\r\n/**\r\n * Custom hook that debounces a value\r\n * \r\n * @example\r\n * const debouncedSearchTerm = useDebounce(searchTerm, 500);\r\n * \r\n * @example\r\n * useDebounce('search term', 500)\r\n * // 'search term' (returned after 500 ms of no changes)\r\n * \r\n * @param {T} value - The value to debounce.\r\n * @param {number} [delay=DEBOUNCE_DELAY] - Delay in milliseconds before updating the debounced value.\r\n * @returns {T} The debounced value.\r\n */\r\nexport function useDebounce<T>(value: T, delay: number = DEBOUNCE_DELAY): T {\r\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\r\n\r\n  useEffect(() => {\r\n    const handler = setTimeout(() => {\r\n      setDebouncedValue(value);\r\n    }, delay);\r\n\r\n    return () => {\r\n      clearTimeout(handler);\r\n    };\r\n  }, [value, delay]);\r\n\r\n  return debouncedValue;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-folder-actions.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":44,"column":37,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file hooks/use-folder-actions.ts\r\n * @description Shared folder actions hook for sidebar components\r\n * @author LinkVault Team\r\n * @created 2025-10-19\r\n * @modified 2025-10-19\r\n */\r\n\r\nimport { useStore } from \"@/store/useStore\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { Folder } from \"@/types\";\r\nimport {\r\n  canAddSubFolder,\r\n  MAX_SUB_FOLDERS_PER_FOLDER,\r\n  getSubFolderCount,\r\n  getAllDescendantFolderIds\r\n} from \"@/utils/folder-utils\";\r\n\r\n/**\r\n * Custom hook providing shared folder management actions\r\n * Extracts common logic from sidebar and mobile-sidebar components\r\n * \r\n * @returns Object containing folder action handlers and utility functions\r\n */\r\nexport function useFolderActions() {\r\n  const folders = useStore((state) => state.folders);\r\n  const links = useStore((state) => state.links);\r\n  const selectedFolderId = useStore((state) => state.selectedFolderId);\r\n  const setCreateFolderModalOpen = useStore((state) => state.setCreateFolderModalOpen);\r\n  const setEditingFolder = useStore((state) => state.setEditingFolder);\r\n  const setParentFolder = useStore((state) => state.setParentFolder);\r\n  const deleteFolder = useStore((state) => state.deleteFolder);\r\n  const setSelectedFolder = useStore((state) => state.setSelectedFolder);\r\n  const deleteConfirmOpen = useStore((state) => state.isFolderDeleteModalOpen);\r\n  const setDeleteConfirmOpen = useStore((state) => state.setFolderDeleteModalOpen);\r\n  const folderToDelete = useStore((state) => state.folderToDelete);\r\n  const setFolderToDelete = useStore((state) => state.setFolderToDelete);\r\n  const { toast } = useToast();\r\n\r\n  /**\r\n   * Handles editing a folder\r\n   * Opens the folder modal in edit mode\r\n   */\r\n  const handleEditFolder = (folderId: string) => {\r\n    setEditingFolder(folderId);\r\n    setCreateFolderModalOpen(true);\r\n  };\r\n\r\n  /**\r\n   * Handles adding a sub-folder\r\n   * Validates sub-folder limit before opening modal\r\n   */\r\n  const handleAddSubFolder = (parentId: string) => {\r\n    // Check if parent folder has reached the sub-folder limit\r\n    if (!canAddSubFolder(parentId, folders)) {\r\n      const parentFolder = folders.find(f => f.id === parentId);\r\n      const count = getSubFolderCount(parentId, folders);\r\n      toast({\r\n        title: \"Maximum sub-folders reached\",\r\n        description: `\"${parentFolder?.name || 'This folder'}\" already has ${count} sub-folders. You cannot create more than ${MAX_SUB_FOLDERS_PER_FOLDER} sub-folders per folder.`,\r\n        variant: \"destructive\",\r\n      });\r\n      return;\r\n    }\r\n    \r\n    setParentFolder(parentId);\r\n    setCreateFolderModalOpen(true);\r\n  };\r\n\r\n  /**\r\n   * Handles folder deletion with confirmation\r\n   * Shows appropriate warning based on folder contents\r\n   */\r\n  const handleDeleteFolder = (folderId: string, folderName: string) => {\r\n    // Get all sub-folder IDs recursively\r\n    const getAllSubFolderIds = (parentId: string): string[] => {\r\n      const subFolders = folders.filter(f => f.parentId === parentId);\r\n      const subFolderIds = subFolders.map(f => f.id);\r\n      const nestedIds = subFolders.flatMap(f => getAllSubFolderIds(f.id));\r\n      return [...subFolderIds, ...nestedIds];\r\n    };\r\n    \r\n    const allAffectedFolderIds = [folderId, ...getAllSubFolderIds(folderId)];\r\n    const linksInFolder = links.filter(link => \r\n      allAffectedFolderIds.includes(link.folderId || '')\r\n    );\r\n    const linkCount = linksInFolder.length;\r\n    \r\n    // Open custom confirmation modal\r\n    setFolderToDelete({ id: folderId, name: folderName, linkCount });\r\n    setDeleteConfirmOpen(true);\r\n  };\r\n\r\n  /**\r\n   * Confirms folder deletion\r\n   */\r\n  const confirmDeleteFolder = () => {\r\n    if (!folderToDelete) return;\r\n\r\n    deleteFolder(folderToDelete.id);\r\n    \r\n    // Clear selection if the deleted folder was selected\r\n    if (selectedFolderId === folderToDelete.id) {\r\n      setSelectedFolder(null);\r\n    }\r\n    \r\n    toast({\r\n      title: \"Deleted\",\r\n      description: `(1)`,\r\n      variant: \"destructive\",\r\n    });\r\n\r\n    setDeleteConfirmOpen(false);\r\n    setFolderToDelete(null);\r\n  };\r\n\r\n  /**\r\n   * Calculates number of links in a specific folder (recursive - includes sub-folders)\r\n   */\r\n  const getFolderCount = (folderId: string): number => {\r\n    // Get all descendant folder IDs (including the folder itself)\r\n    const descendantIds = getAllDescendantFolderIds(folderId, folders);\r\n\r\n    // Count links in all descendant folders\r\n    return links.filter(\r\n      link => link.folderId && descendantIds.includes(link.folderId) && link.deletedAt === null\r\n    ).length;\r\n  };\r\n\r\n  return {\r\n    handleEditFolder,\r\n    handleAddSubFolder,\r\n    handleDeleteFolder,\r\n    confirmDeleteFolder,\r\n    getFolderCount,\r\n    deleteConfirmOpen,\r\n    setDeleteConfirmOpen,\r\n    folderToDelete,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-folder-descendants.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":25,"column":45,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file hooks/use-folder-descendants.ts\r\n * @description Custom hook for managing folder descendants with memoization\r\n * @created 2025-10-18\r\n */\r\n\r\nimport React, { useMemo } from 'react';\r\nimport { Folder } from '@/types';\r\nimport { getAllDescendantFolderIds } from '@/utils/folder-utils';\r\n\r\n/**\r\n * Hook that memoizes descendant folder IDs for all folders\r\n * This prevents recalculating descendants on every render\r\n * \r\n * Performance: O(n) calculation, cached for all folders\r\n * \r\n * @param folders - Array of all folders\r\n * @returns Map of folderId to descendant IDs (including self)\r\n * \r\n * @example\r\n * const descendantMap = useFolderDescendants(folders);\r\n * const allIds = descendantMap.get('parent-folder-id');\r\n * // Use allIds to filter links\r\n */\r\nexport function useFolderDescendants(folders: Folder[]): Map<string, string[]> {\r\n  return useMemo(() => {\r\n    const map = new Map<string, string[]>();\r\n    \r\n    // Pre-calculate descendants for all folders\r\n    folders.forEach(folder => {\r\n      map.set(folder.id, getAllDescendantFolderIds(folder.id, folders));\r\n    });\r\n    \r\n    return map;\r\n  }, [folders]);\r\n}\r\n\r\n/**\r\n * Hook that returns descendants for a specific folder ID\r\n * \r\n * @param folderId - Target folder ID (null returns empty array)\r\n * @param folders - Array of all folders\r\n * @returns Array of descendant folder IDs including the folder itself\r\n * \r\n * @example\r\n * const descendants = useSpecificFolderDescendants('work-id', folders);\r\n * // Returns: ['work-id', 'projects-id', 'clienta-id', ...]\r\n */\r\nexport function useSpecificFolderDescendants(\r\n  folderId: string | null,\r\n  folders: Folder[]\r\n): string[] {\r\n  return useMemo(() => {\r\n    if (!folderId) return [];\r\n    return getAllDescendantFolderIds(folderId, folders);\r\n  }, [folderId, folders]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-keyboard-shortcuts.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":11,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\n/**\r\n * @file hooks/use-keyboard-shortcuts.ts\r\n * @description Custom hook for global keyboard shortcuts\r\n * @created 2025-10-18\r\n */\r\n\r\nimport React, { useEffect } from 'react';\r\n\r\ninterface KeyboardShortcut {\r\n  key: string;\r\n  ctrlKey?: boolean;\r\n  shiftKey?: boolean;\r\n  altKey?: boolean;\r\n  callback: () => void;\r\n}\r\n\r\n/**\r\n* React hook that binds multiple keyboard shortcuts to their respective callback functions.\r\n* @example\r\n* useKeyboardShortcuts([\r\n*   { key: 's', ctrlKey: true, shiftKey: false, altKey: false, callback: () => console.log('Save') }\r\n* ])\r\n* // Pressing Ctrl+S will log 'Save' to the console\r\n* @param {{KeyboardShortcut[]}} shortcuts - Array of shortcut objects describing key combinations and callbacks.\r\n* @returns {{void}} Returns nothing.\r\n**/\r\nexport function useKeyboardShortcuts(shortcuts: KeyboardShortcut[]) {\r\n  useEffect(() => {\r\n    /**\r\n    * Handles registered keyboard shortcuts and executes their callbacks.\r\n    * @example\r\n    * handleKeyboardShortcuts(event)\r\n    * // Executes the callback bound to the matching shortcut and prevents default browser behavior\r\n    * @param {KeyboardEvent} event - Keyboard event captured from a keydown listener.\r\n    * @returns {void} Function does not return anything.\r\n    **/\r\n    const handleKeyDown = (event: KeyboardEvent) => {\r\n      // Skip if event.key is not available (e.g., during paste events)\r\n      if (!event.key) return;\r\n      \r\n      shortcuts.forEach((shortcut) => {\r\n        const matchesKey = event.key.toLowerCase() === shortcut.key.toLowerCase();\r\n        const matchesCtrl = shortcut.ctrlKey ? event.ctrlKey || event.metaKey : !event.ctrlKey && !event.metaKey;\r\n        const matchesShift = shortcut.shiftKey ? event.shiftKey : !event.shiftKey;\r\n        const matchesAlt = shortcut.altKey ? event.altKey : !event.altKey;\r\n\r\n        if (matchesKey && matchesCtrl && matchesShift && matchesAlt) {\r\n          event.preventDefault();\r\n          shortcut.callback();\r\n        }\r\n      });\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n    };\r\n  }, [shortcuts]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-link-counts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-logout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-meta.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":3,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useQuery } from '@tanstack/react-query';\r\n\r\ninterface Metadata {\r\n  title?: string;\r\n  description?: string;\r\n  image?: string;\r\n  siteName?: string;\r\n  url: string;\r\n  favicon?: string;\r\n  domain?: string;\r\n  processingTime?: number;\r\n  cached?: boolean;\r\n}\r\n\r\nasync function fetchMetadata(url: string): Promise<Metadata> {\r\n  const response = await fetch('/api/fetch-metadata', {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n    body: JSON.stringify({ url }),\r\n  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error('Failed to fetch metadata');\r\n  }\r\n\r\n  return response.json();\r\n}\r\n\r\nexport function useMeta(url: string, enabled: boolean = true) {\r\n  return useQuery({\r\n    queryKey: ['meta', url],\r\n    queryFn: () => fetchMetadata(url),\r\n    enabled: enabled && !!url,\r\n    staleTime: 1000 * 60 * 60 * 24, // 24h\r\n    gcTime: 1000 * 60 * 60 * 24 * 7, // 7 days\r\n  });\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-online-status.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":13,"column":34,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file hooks/use-online-status.ts\r\n * @description Hook to detect online/offline status and network connectivity\r\n * @created 2025-11-04\r\n */\r\n\r\nimport { useState, useEffect } from 'react';\r\n\r\n/**\r\n * Hook to track online/offline status\r\n * @returns {boolean} Whether the user is online\r\n */\r\nexport function useOnlineStatus(): boolean {\r\n  const [isOnline, setIsOnline] = useState<boolean>(\r\n    typeof navigator !== 'undefined' ? navigator.onLine : true\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    const handleOnline = () => setIsOnline(true);\r\n    const handleOffline = () => setIsOnline(false);\r\n\r\n    window.addEventListener('online', handleOnline);\r\n    window.addEventListener('offline', handleOffline);\r\n\r\n    return () => {\r\n      window.removeEventListener('online', handleOnline);\r\n      window.removeEventListener('offline', handleOffline);\r\n    };\r\n  }, []);\r\n\r\n  return isOnline;\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-performance-monitor.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":10,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file use-performance-monitor.ts\r\n * @description React hook for integrating performance monitoring into components\r\n * @created 2024-12-19\r\n */\r\n\r\nimport { useEffect, useRef, useCallback, useMemo } from 'react';\r\nimport { performanceMonitor } from '@/lib/services/performance-monitor.service';\r\n\r\ninterface UsePerformanceMonitorOptions {\r\n  componentName: string;\r\n  trackRenders?: boolean;\r\n  trackInteractions?: boolean;\r\n  trackErrors?: boolean;\r\n  renderThreshold?: number; // ms threshold for slow render warning\r\n}\r\n\r\ninterface PerformanceHookReturn {\r\n  trackInteraction: (type: string, element?: string, metadata?: Record<string, any>) => void;\r\n  trackError: (error: Error | string, context?: Record<string, any>) => void;\r\n  trackMetric: (name: string, value: number, tags?: Record<string, string>) => void;\r\n  startTimer: (name: string) => () => void;\r\n  measureAsync: <T>(name: string, asyncFn: () => Promise<T>) => Promise<T>;\r\n}\r\n\r\n/**\r\n * Hook for performance monitoring in React components\r\n * @param {UsePerformanceMonitorOptions} options - Configuration options\r\n * @returns {PerformanceHookReturn} Performance tracking functions\r\n */\r\nexport function usePerformanceMonitor(options: UsePerformanceMonitorOptions): PerformanceHookReturn {\r\n  const {\r\n    componentName,\r\n    trackRenders = true,\r\n    trackInteractions = true,\r\n    trackErrors = true,\r\n    renderThreshold = 16 // 60fps threshold\r\n  } = options;\r\n\r\n  const renderStartTime = useRef<number>(0);\r\n  const mountTime = useRef<number>(0);\r\n  const renderCount = useRef<number>(0);\r\n\r\n  // Track component mount - only if tracking is enabled\r\n  useEffect(() => {\r\n    if (!trackRenders && !trackInteractions && !trackErrors) return;\r\n    \r\n    mountTime.current = performance.now();\r\n    \r\n    if (trackInteractions) {\r\n      performanceMonitor.trackInteraction({\r\n        type: 'modal_open', // Using existing type, could be extended\r\n        element: componentName,\r\n        timestamp: Date.now(),\r\n        metadata: { action: 'component_mount' }\r\n      });\r\n    }\r\n\r\n    return () => {\r\n      if (!trackRenders && !trackInteractions && !trackErrors) return;\r\n      \r\n      const unmountTime = performance.now();\r\n      const totalLifetime = unmountTime - mountTime.current;\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      const finalRenderCount = renderCount.current; // Capture ref value\r\n      \r\n      if (trackRenders) {\r\n        performanceMonitor.trackMetric('component_lifetime', totalLifetime, {\r\n          component: componentName,\r\n          type: 'lifecycle'\r\n        }, {\r\n          renderCount: finalRenderCount\r\n        });\r\n      }\r\n\r\n      if (trackInteractions) {\r\n        performanceMonitor.trackInteraction({\r\n          type: 'modal_close', // Using existing type, could be extended\r\n          element: componentName,\r\n          timestamp: Date.now(),\r\n          duration: totalLifetime,\r\n          metadata: { \r\n            action: 'component_unmount',\r\n            renderCount: finalRenderCount\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }, [componentName, trackRenders, trackInteractions, trackErrors]);\r\n\r\n  // Track renders with optimized performance\r\n  useEffect(() => {\r\n    if (!trackRenders) return;\r\n\r\n    const renderEndTime = performance.now();\r\n    const renderDuration = renderEndTime - renderStartTime.current;\r\n    \r\n    if (renderStartTime.current > 0) {\r\n      renderCount.current++;\r\n      \r\n      // Only track performance metrics if render time is significant or exceeds threshold\r\n      const threshold = process.env.NODE_ENV === 'development' ? 50 : 16;\r\n      \r\n      // Throttle tracking to avoid performance overhead\r\n      if (renderDuration > 10 && renderCount.current % 5 === 0) {\r\n        performanceMonitor.trackComponentRender(\r\n          componentName, \r\n          renderDuration,\r\n          { renderCount: renderCount.current }\r\n        );\r\n      }\r\n\r\n      // Only log slow renders, not all renders\r\n      if (renderDuration > threshold) {\r\n        performanceMonitor.trackError({\r\n          message: `Slow component render: ${componentName}`,\r\n          severity: renderDuration > threshold * 2 ? 'medium' : 'low',\r\n          context: {\r\n            componentName,\r\n            renderTime: renderDuration,\r\n            threshold: threshold,\r\n            environment: process.env.NODE_ENV,\r\n            props: undefined // Don't log props to avoid overhead\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    renderStartTime.current = performance.now();\r\n  });\r\n\r\n  /**\r\n   * Track user interaction\r\n   */\r\n  const trackInteraction = useCallback((\r\n    type: string, \r\n    element?: string, \r\n    metadata?: Record<string, any>\r\n  ) => {\r\n    if (!trackInteractions) return;\r\n\r\n    performanceMonitor.trackInteraction({\r\n      type: type as any, // Cast to satisfy the union type\r\n      element: element || componentName,\r\n      timestamp: Date.now(),\r\n      metadata: {\r\n        component: componentName,\r\n        ...metadata\r\n      }\r\n    });\r\n  }, [componentName, trackInteractions]);\r\n\r\n  /**\r\n   * Track error with component context\r\n   */\r\n  const trackError = useCallback((\r\n    error: Error | string, \r\n    context?: Record<string, any>\r\n  ) => {\r\n    if (!trackErrors) return;\r\n\r\n    const errorMessage = error instanceof Error ? error.message : error;\r\n    const errorStack = error instanceof Error ? error.stack : undefined;\r\n\r\n    performanceMonitor.trackError({\r\n      message: errorMessage,\r\n      stack: errorStack,\r\n      severity: 'medium',\r\n      context: {\r\n        component: componentName,\r\n        renderCount: renderCount.current,\r\n        ...context\r\n      }\r\n    });\r\n  }, [componentName, trackErrors]);\r\n\r\n  /**\r\n   * Track custom metric with component context\r\n   */\r\n  const trackMetric = useCallback((\r\n    name: string, \r\n    value: number, \r\n    tags?: Record<string, string>\r\n  ) => {\r\n    performanceMonitor.trackMetric(name, value, {\r\n      component: componentName,\r\n      ...tags\r\n    });\r\n  }, [componentName]);\r\n\r\n  /**\r\n   * Start a timer and return a function to end it\r\n   */\r\n  const startTimer = useCallback((name: string) => {\r\n    const startTime = performance.now();\r\n    \r\n    return () => {\r\n      const endTime = performance.now();\r\n      const duration = endTime - startTime;\r\n      \r\n      trackMetric(name, duration, { type: 'timer' });\r\n      return duration;\r\n    };\r\n  }, [trackMetric]);\r\n\r\n  /**\r\n   * Measure async operation performance\r\n   */\r\n  const measureAsync = useCallback(async <T>(\r\n    name: string, \r\n    asyncFn: () => Promise<T>\r\n  ): Promise<T> => {\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      const result = await asyncFn();\r\n      const duration = performance.now() - startTime;\r\n      \r\n      trackMetric(name, duration, { \r\n        type: 'async_operation',\r\n        status: 'success'\r\n      });\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      \r\n      trackMetric(name, duration, { \r\n        type: 'async_operation',\r\n        status: 'error'\r\n      });\r\n      \r\n      trackError(error as Error, {\r\n        operation: name,\r\n        duration\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  }, [trackMetric, trackError]);\r\n\r\n  return useMemo(() => ({\r\n    trackInteraction,\r\n    trackError,\r\n    trackMetric,\r\n    startTimer,\r\n    measureAsync\r\n  }), [trackInteraction, trackError, trackMetric, startTimer, measureAsync]);\r\n}\r\n\r\n/**\r\n * Hook for tracking API calls with automatic performance monitoring\r\n */\r\nexport function useApiPerformanceMonitor() {\r\n  const trackApiCall = useCallback(async <T>(\r\n    endpoint: string,\r\n    apiCall: () => Promise<T>,\r\n    metadata?: Record<string, any>\r\n  ): Promise<T> => {\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      const result = await apiCall();\r\n      const duration = performance.now() - startTime;\r\n      \r\n      performanceMonitor.trackApiCall(endpoint, duration, true, {\r\n        ...metadata,\r\n        resultType: typeof result\r\n      });\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      const duration = performance.now() - startTime;\r\n      \r\n      performanceMonitor.trackApiCall(endpoint, duration, false, {\r\n        ...metadata,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  return { trackApiCall };\r\n}\r\n\r\n/**\r\n * Hook for tracking form performance\r\n */\r\nexport function useFormPerformanceMonitor(formName: string) {\r\n  const { trackInteraction, trackMetric, trackError } = usePerformanceMonitor({\r\n    componentName: formName,\r\n    trackRenders: false // Forms don't need render tracking\r\n  });\r\n\r\n  const trackFormStart = useCallback(() => {\r\n    trackInteraction('form_start', formName);\r\n    return performance.now();\r\n  }, [trackInteraction, formName]);\r\n\r\n  const trackFormSubmit = useCallback((\r\n    startTime: number, \r\n    success: boolean, \r\n    validationErrors?: string[]\r\n  ) => {\r\n    const duration = performance.now() - startTime;\r\n    \r\n    trackMetric('form_completion_time', duration, {\r\n      form: formName,\r\n      success: success.toString()\r\n    });\r\n\r\n    trackInteraction('form_submit', formName, {\r\n      duration,\r\n      success,\r\n      validationErrors: validationErrors?.length || 0\r\n    });\r\n\r\n    if (!success && validationErrors?.length) {\r\n      trackError(`Form validation failed: ${formName}`, {\r\n        validationErrors,\r\n        duration\r\n      });\r\n    }\r\n  }, [trackMetric, trackInteraction, trackError, formName]);\r\n\r\n  const trackFieldInteraction = useCallback((fieldName: string, action: string) => {\r\n    trackInteraction('form_field_interaction', `${formName}.${fieldName}`, {\r\n      action,\r\n      field: fieldName\r\n    });\r\n  }, [trackInteraction, formName]);\r\n\r\n  return {\r\n    trackFormStart,\r\n    trackFormSubmit,\r\n    trackFieldInteraction\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-realtime-subscription.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":14,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file hooks/use-realtime-subscription.ts\r\n * @description React hook for optimized real-time subscriptions with automatic cleanup\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { useEffect, useRef, useCallback, useMemo, useState } from 'react';\r\nimport { RealtimePostgresChangesPayload } from '@supabase/supabase-js';\r\nimport { realtimeSubscriptionManager } from '@/services/realtime-subscription-manager.service';\r\n\r\n/**\r\n * Subscription configuration interface\r\n */\r\ninterface SubscriptionConfig {\r\n  table: string;\r\n  event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*';\r\n  filter?: string;\r\n  schema?: string;\r\n}\r\n\r\n/**\r\n * Debounced update configuration\r\n */\r\ninterface DebouncedUpdateConfig {\r\n  delay?: number;\r\n  maxWait?: number;\r\n  leading?: boolean;\r\n  trailing?: boolean;\r\n}\r\n\r\n/**\r\n * Hook options interface\r\n */\r\ninterface UseRealtimeSubscriptionOptions {\r\n  enabled?: boolean;\r\n  debounce?: DebouncedUpdateConfig;\r\n  dependencies?: any[];\r\n}\r\n\r\n/**\r\n * Hook return interface\r\n */\r\ninterface UseRealtimeSubscriptionReturn {\r\n  isConnected: boolean;\r\n  subscriptionId: string | null;\r\n  pause: () => void;\r\n  resume: () => void;\r\n  unsubscribe: () => void;\r\n}\r\n\r\n/**\r\n * React hook for optimized real-time subscriptions\r\n * Automatically manages subscription lifecycle and cleanup\r\n * \r\n * @param config - Subscription configuration\r\n * @param callback - Callback function for updates\r\n * @param options - Hook options\r\n * @returns Subscription management object\r\n * \r\n * @example\r\n * ```tsx\r\n * const { isConnected, pause, resume } = useRealtimeSubscription(\r\n *   { table: 'links', event: 'INSERT' },\r\n *   (payload) => {\r\n *     console.log('New link:', payload.new);\r\n *   },\r\n *   { \r\n *     enabled: true,\r\n *     debounce: { delay: 500 },\r\n *     dependencies: [userId]\r\n *   }\r\n * );\r\n * ```\r\n */\r\nexport function useRealtimeSubscription(\r\n  config: SubscriptionConfig,\r\n  callback: (payload: RealtimePostgresChangesPayload<any>) => void,\r\n  options: UseRealtimeSubscriptionOptions = {}\r\n): UseRealtimeSubscriptionReturn {\r\n  const {\r\n    enabled = true,\r\n    debounce,\r\n    dependencies = []\r\n  } = options;\r\n\r\n  const subscriptionIdRef = useRef<string | null>(null);\r\n  const isConnectedRef = useRef<boolean>(false);\r\n  const callbackRef = useRef(callback);\r\n\r\n  // Update callback ref when callback changes\r\n  useEffect(() => {\r\n    callbackRef.current = callback;\r\n  }, [callback]);\r\n\r\n  /**\r\n   * Pause the subscription\r\n   */\r\n  const pause = useCallback(() => {\r\n    if (subscriptionIdRef.current) {\r\n      realtimeSubscriptionManager.pauseSubscription(subscriptionIdRef.current);\r\n      isConnectedRef.current = false;\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Resume the subscription\r\n   */\r\n  const resume = useCallback(() => {\r\n    if (subscriptionIdRef.current) {\r\n      realtimeSubscriptionManager.resumeSubscription(subscriptionIdRef.current);\r\n      isConnectedRef.current = true;\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Manually unsubscribe\r\n   */\r\n  const unsubscribe = useCallback(() => {\r\n    if (subscriptionIdRef.current) {\r\n      realtimeSubscriptionManager.unsubscribe(subscriptionIdRef.current);\r\n      subscriptionIdRef.current = null;\r\n      isConnectedRef.current = false;\r\n    }\r\n  }, []);\r\n\r\n  // Main subscription effect\r\n  useEffect(() => {\r\n    if (!enabled) {\r\n      // Clean up existing subscription if disabled\r\n      if (subscriptionIdRef.current) {\r\n        unsubscribe();\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Create subscription\r\n    const subscriptionConfig = {\r\n      table: config.table,\r\n      event: config.event,\r\n      filter: config.filter,\r\n      schema: config.schema\r\n    };\r\n\r\n    const subscriptionId = realtimeSubscriptionManager.subscribe(\r\n      subscriptionConfig,\r\n      (payload) => {\r\n        // Use the latest callback from ref\r\n        callbackRef.current(payload);\r\n      },\r\n      debounce\r\n    );\r\n\r\n    subscriptionIdRef.current = subscriptionId;\r\n    isConnectedRef.current = true;\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      if (subscriptionIdRef.current) {\r\n        realtimeSubscriptionManager.unsubscribe(subscriptionIdRef.current);\r\n        subscriptionIdRef.current = null;\r\n        isConnectedRef.current = false;\r\n      }\r\n    };\r\n  }, [\r\n    enabled,\r\n    config.table,\r\n    config.event,\r\n    config.filter,\r\n    config.schema,\r\n    debounce,\r\n    unsubscribe,\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    ...dependencies\r\n  ]);\r\n\r\n  return {\r\n    isConnected: isConnectedRef.current,\r\n    subscriptionId: subscriptionIdRef.current,\r\n    pause,\r\n    resume,\r\n    unsubscribe\r\n  };\r\n}\r\n\r\n/**\r\n * Hook for subscribing to multiple tables with shared configuration\r\n * \r\n * @param configs - Array of subscription configurations\r\n * @param callback - Callback function for updates\r\n * @param options - Hook options\r\n * @returns Array of subscription management objects\r\n * \r\n * @example\r\n * ```tsx\r\n * const subscriptions = useMultipleRealtimeSubscriptions(\r\n *   [\r\n *     { table: 'links', event: 'INSERT' },\r\n *     { table: 'folders', event: 'UPDATE' }\r\n *   ],\r\n *   (payload) => {\r\n *     console.log('Update from:', payload.table);\r\n *   }\r\n * );\r\n * ```\r\n */\r\nexport function useMultipleRealtimeSubscriptions(\r\n  configs: SubscriptionConfig[],\r\n  callback: (payload: RealtimePostgresChangesPayload<any>) => void,\r\n  options: UseRealtimeSubscriptionOptions = {}\r\n): UseRealtimeSubscriptionReturn[] {\r\n  const {\r\n    enabled = true,\r\n    debounce,\r\n    dependencies = []\r\n  } = options;\r\n\r\n  const subscriptionIdsRef = useRef<(string | null)[]>([]);\r\n  const isConnectedRef = useRef<boolean[]>([]);\r\n  const callbackRef = useRef(callback);\r\n\r\n  // Update callback ref when callback changes\r\n  useEffect(() => {\r\n    callbackRef.current = callback;\r\n  }, [callback]);\r\n\r\n  // Memoize serialized configs to avoid complex expressions in dependencies\r\n  const serializedConfigs = useMemo(() => \r\n    JSON.stringify(configs.map(c => ({ \r\n      table: c.table, \r\n      event: c.event, \r\n      filter: c.filter, \r\n      schema: c.schema \r\n    }))), [configs]);\r\n\r\n  // Main subscription effect\r\n  useEffect(() => {\r\n    if (!enabled) {\r\n      // Clean up existing subscriptions if disabled\r\n      subscriptionIdsRef.current.forEach(id => {\r\n        if (id) {\r\n          realtimeSubscriptionManager.unsubscribe(id);\r\n        }\r\n      });\r\n      subscriptionIdsRef.current = [];\r\n      isConnectedRef.current = [];\r\n      return;\r\n    }\r\n\r\n    const subscriptions: string[] = [];\r\n\r\n    configs.forEach((config) => {\r\n      const subscriptionConfig = {\r\n        table: config.table,\r\n        event: config.event,\r\n        filter: config.filter,\r\n        schema: config.schema\r\n      };\r\n\r\n      const subscriptionId = realtimeSubscriptionManager.subscribe(\r\n        subscriptionConfig,\r\n        (payload) => {\r\n          // Use the latest callback from ref\r\n          callbackRef.current(payload);\r\n        },\r\n        debounce\r\n      );\r\n\r\n      subscriptions.push(subscriptionId);\r\n    });\r\n\r\n    subscriptionIdsRef.current = subscriptions;\r\n    isConnectedRef.current = new Array(subscriptions.length).fill(true);\r\n\r\n    return () => {\r\n      subscriptions.forEach(id => {\r\n        realtimeSubscriptionManager.unsubscribe(id);\r\n      });\r\n      subscriptionIdsRef.current = [];\r\n      isConnectedRef.current = [];\r\n    };\r\n  }, [\r\n    enabled,\r\n    serializedConfigs,\r\n    configs,\r\n    debounce,\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    ...dependencies\r\n  ]);\r\n\r\n  // Create subscription management objects for each config\r\n  const subscriptions = configs.map((_, index) => ({\r\n    isConnected: isConnectedRef.current[index] || false,\r\n    subscriptionId: subscriptionIdsRef.current[index] || null,\r\n    pause: () => {\r\n      const id = subscriptionIdsRef.current[index];\r\n      if (id) {\r\n        realtimeSubscriptionManager.pauseSubscription(id);\r\n        isConnectedRef.current[index] = false;\r\n      }\r\n    },\r\n    resume: () => {\r\n      const id = subscriptionIdsRef.current[index];\r\n      if (id) {\r\n        realtimeSubscriptionManager.resumeSubscription(id);\r\n        isConnectedRef.current[index] = true;\r\n      }\r\n    },\r\n    unsubscribe: () => {\r\n      const id = subscriptionIdsRef.current[index];\r\n      if (id) {\r\n        realtimeSubscriptionManager.unsubscribe(id);\r\n        subscriptionIdsRef.current[index] = null;\r\n        isConnectedRef.current[index] = false;\r\n      }\r\n    }\r\n  }));\r\n\r\n  return subscriptions;\r\n}\r\n\r\n/**\r\n * Hook for conditional real-time subscriptions based on user permissions or state\r\n * \r\n * @param getConfig - Function that returns subscription config or null\r\n * @param callback - Callback function for updates\r\n * @param options - Hook options\r\n * @returns Subscription management object\r\n * \r\n * @example\r\n * ```tsx\r\n * const { isConnected } = useConditionalRealtimeSubscription(\r\n *   () => user?.canViewLinks ? { table: 'links' } : null,\r\n *   (payload) => handleLinkUpdate(payload),\r\n *   { dependencies: [user] }\r\n * );\r\n * ```\r\n */\r\nexport function useConditionalRealtimeSubscription(\r\n  getConfig: () => SubscriptionConfig | null,\r\n  callback: (payload: RealtimePostgresChangesPayload<any>) => void,\r\n  options: UseRealtimeSubscriptionOptions = {}\r\n): UseRealtimeSubscriptionReturn {\r\n  const config = getConfig();\r\n  const enabled = config !== null && (options.enabled !== false);\r\n\r\n  // Always call the hook to avoid rules-of-hooks violations\r\n  return useRealtimeSubscription(\r\n    config || { table: '' }, // Fallback config (won't be used if disabled)\r\n    callback,\r\n    { ...options, enabled }\r\n  );\r\n}\r\n\r\n/**\r\n * Hook for real-time subscriptions with automatic retry logic\r\n * \r\n * @param config - Subscription configuration\r\n * @param callback - Callback function for updates\r\n * @param options - Hook options with retry configuration\r\n * @returns Subscription management object with retry info\r\n * \r\n * @example\r\n * ```tsx\r\n * const { isConnected, retryCount } = useRealtimeSubscriptionWithRetry(\r\n *   { table: 'links' },\r\n *   handleUpdate,\r\n *   { \r\n *     maxRetries: 3,\r\n *     retryDelay: 1000,\r\n *     backoffMultiplier: 2\r\n *   }\r\n * );\r\n * ```\r\n */\r\nexport function useRealtimeSubscriptionWithRetry(\r\n  config: SubscriptionConfig,\r\n  callback: (payload: RealtimePostgresChangesPayload<any>) => void,\r\n  options: UseRealtimeSubscriptionOptions & {\r\n    maxRetries?: number;\r\n    retryDelay?: number;\r\n    backoffMultiplier?: number;\r\n  } = {}\r\n): UseRealtimeSubscriptionReturn & { retryCount: number } {\r\n  const {\r\n    maxRetries = 3,\r\n    retryDelay = 1000,\r\n    backoffMultiplier = 2,\r\n    enabled: originalEnabled = true,\r\n    ...hookOptions\r\n  } = options;\r\n\r\n  const retryCountRef = useRef(0);\r\n  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  const [enabled, setEnabled] = useState(originalEnabled);\r\n  const [retryCount, setRetryCount] = useState(0);\r\n\r\n  const wrappedCallback = useCallback((payload: RealtimePostgresChangesPayload<any>) => {\r\n    // Reset retry count on successful update\r\n    retryCountRef.current = 0;\r\n    setRetryCount(0);\r\n    callback(payload);\r\n  }, [callback]);\r\n\r\n  const subscription = useRealtimeSubscription(config, wrappedCallback, {\r\n    ...hookOptions,\r\n    enabled\r\n  });\r\n\r\n  // Retry logic for failed connections\r\n  useEffect(() => {\r\n    // Clear any existing timeout\r\n    if (retryTimeoutRef.current) {\r\n      clearTimeout(retryTimeoutRef.current);\r\n      retryTimeoutRef.current = null;\r\n    }\r\n\r\n    if (!subscription.isConnected && retryCountRef.current < maxRetries && enabled) {\r\n      const delay = retryDelay * Math.pow(backoffMultiplier, retryCountRef.current);\r\n      \r\n      retryTimeoutRef.current = setTimeout(() => {\r\n        retryCountRef.current++;\r\n        setRetryCount(retryCountRef.current);\r\n        \r\n        // Force re-subscription by toggling enabled state\r\n        setEnabled(false);\r\n        setTimeout(() => {\r\n          setEnabled(true);\r\n        }, 100);\r\n      }, delay);\r\n    } else if (subscription.isConnected) {\r\n      // Reset retry count on successful connection\r\n      retryCountRef.current = 0;\r\n      setRetryCount(0);\r\n    }\r\n\r\n    return () => {\r\n      if (retryTimeoutRef.current) {\r\n        clearTimeout(retryTimeoutRef.current);\r\n        retryTimeoutRef.current = null;\r\n      }\r\n    };\r\n  }, [subscription.isConnected, maxRetries, retryDelay, backoffMultiplier, enabled]);\r\n\r\n  // Update enabled state when originalEnabled prop changes\r\n  useEffect(() => {\r\n    setEnabled(originalEnabled);\r\n    if (!originalEnabled) {\r\n      retryCountRef.current = 0;\r\n      setRetryCount(0);\r\n    }\r\n  }, [originalEnabled]);\r\n\r\n  return {\r\n    ...subscription,\r\n    retryCount\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-store-action.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":10,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file hooks/use-store-action.ts\r\n * @description Hook to handle async store actions with loading states and error handling\r\n * @created 2025-11-02\r\n */\r\n\r\nimport { useState, useCallback } from 'react';\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\ninterface UseStoreActionOptions {\r\n  successMessage?: string;\r\n  errorMessage?: string;\r\n  showSuccess?: boolean;\r\n  showError?: boolean;\r\n}\r\n\r\n/**\r\n * Hook to handle async store actions with automatic error handling and toast notifications\r\n * @param {Function} action - The async store action to wrap\r\n * @param {UseStoreActionOptions} options - Configuration options\r\n * @returns {Object} - Object with execute function, loading state, and error state\r\n */\r\nexport function useStoreAction<T extends (...args: any[]) => Promise<void>>(\r\n  action: T,\r\n  options: UseStoreActionOptions = {}\r\n) {\r\n  const { toast } = useToast();\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  const {\r\n    successMessage,\r\n    errorMessage = 'Operation failed. Please try again.',\r\n    showSuccess = false,\r\n    showError = true,\r\n  } = options;\r\n\r\n  const execute = useCallback(\r\n    async (...args: Parameters<T>) => {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      try {\r\n        await action(...args);\r\n\r\n        if (showSuccess && successMessage) {\r\n          toast({\r\n            title: 'Success',\r\n            description: successMessage,\r\n            variant: 'success',\r\n          });\r\n        }\r\n      } catch (err) {\r\n        const error = err instanceof Error ? err : new Error('Unknown error');\r\n        setError(error);\r\n\r\n        if (showError) {\r\n          toast({\r\n            title: 'Error',\r\n            description: errorMessage,\r\n            variant: 'destructive',\r\n          });\r\n        }\r\n\r\n        throw error; // Re-throw for component-level handling if needed\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    },\r\n    [action, successMessage, errorMessage, showSuccess, showError, toast]\r\n  );\r\n\r\n  return {\r\n    execute,\r\n    isLoading,\r\n    error,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\hooks\\use-toast.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token {","line":7,"column":13,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\"\r\n\r\n// Inspired by react-hot-toast library\r\nimport * as React from \"react\"\r\nimport { TOAST_REMOVE_DELAY } from \"@/constants\"\r\n\r\nimport type {\r\n  ToastActionElement,\r\n  ToastProps,\r\n} from \"@/components/ui/toast\"\r\n\r\nconst TOAST_LIMIT = 1\r\n\r\ntype ToasterToast = ToastProps & {\r\n  id: string\r\n  title?: React.ReactNode\r\n  description?: React.ReactNode\r\n  action?: ToastActionElement\r\n  icon?: React.ReactNode\r\n}\r\n\r\nconst actionTypes = {\r\n  ADD_TOAST: \"ADD_TOAST\",\r\n  UPDATE_TOAST: \"UPDATE_TOAST\",\r\n  DISMISS_TOAST: \"DISMISS_TOAST\",\r\n  REMOVE_TOAST: \"REMOVE_TOAST\",\r\n} as const\r\n\r\nlet count = 0\r\n\r\nfunction genId() {\r\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\r\n  return count.toString()\r\n}\r\n\r\ntype ActionType = typeof actionTypes\r\n\r\ntype Action =\r\n  | {\r\n      type: ActionType[\"ADD_TOAST\"]\r\n      toast: ToasterToast\r\n    }\r\n  | {\r\n      type: ActionType[\"UPDATE_TOAST\"]\r\n      toast: Partial<ToasterToast>\r\n    }\r\n  | {\r\n      type: ActionType[\"DISMISS_TOAST\"]\r\n      toastId?: ToasterToast[\"id\"]\r\n    }\r\n  | {\r\n      type: ActionType[\"REMOVE_TOAST\"]\r\n      toastId?: ToasterToast[\"id\"]\r\n    }\r\n\r\ninterface State {\r\n  toasts: ToasterToast[]\r\n}\r\n\r\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\r\n\r\n/**\r\n* Schedules automatic removal of a toast notification after a preset delay if it is not already scheduled.\r\n* @example\r\n* scheduleToastRemoval(\"toast_123\")\r\n* // undefined\r\n* @param {string} toastId - Unique identifier for the toast to remove.\r\n* @returns {void} Does not return a value.\r\n**/\r\nconst addToRemoveQueue = (toastId: string) => {\r\n  if (toastTimeouts.has(toastId)) {\r\n    return\r\n  }\r\n\r\n  const timeout = setTimeout(() => {\r\n    toastTimeouts.delete(toastId)\r\n    dispatch({\r\n      type: \"REMOVE_TOAST\",\r\n      toastId: toastId,\r\n    })\r\n  }, TOAST_REMOVE_DELAY)\r\n\r\n  toastTimeouts.set(toastId, timeout)\r\n}\r\n\r\n/**\r\n* Reducer function that manages toast notifications state based on dispatched actions.\r\n* @example\r\n* toastReducer(state, { type: \"ADD_TOAST\", toast: { id: \"1\", title: \"Hello\" } })\r\n* // returns the new state with the toast added\r\n* @param {State} state - Current state of the toast system.\r\n* @param {Action} action - Action object describing the update to perform.\r\n* @returns {State} The new state after applying the specified action.\r\n**/\r\nexport const reducer = (state: State, action: Action): State => {\r\n  switch (action.type) {\r\n    case \"ADD_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\r\n      }\r\n\r\n    case \"UPDATE_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\r\n        ),\r\n      }\r\n\r\n    case \"DISMISS_TOAST\": {\r\n      const { toastId } = action\r\n\r\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\r\n      // but I'll keep it here for simplicity\r\n      if (toastId) {\r\n        addToRemoveQueue(toastId)\r\n      } else {\r\n        state.toasts.forEach((toast) => {\r\n          addToRemoveQueue(toast.id)\r\n        })\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === toastId || toastId === undefined\r\n            ? {\r\n                ...t,\r\n                open: false,\r\n              }\r\n            : t\r\n        ),\r\n      }\r\n    }\r\n    case \"REMOVE_TOAST\":\r\n      if (action.toastId === undefined) {\r\n        return {\r\n          ...state,\r\n          toasts: [],\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\r\n      }\r\n  }\r\n}\r\n\r\nconst listeners: Array<(state: State) => void> = []\r\n\r\nlet memoryState: State = { toasts: [] }\r\n\r\nfunction dispatch(action: Action) {\r\n  memoryState = reducer(memoryState, action)\r\n  listeners.forEach((listener) => {\r\n    listener(memoryState)\r\n  })\r\n}\r\n\r\ntype Toast = Omit<ToasterToast, \"id\">\r\n\r\n/**\r\n* Creates and dispatches a toast notification and returns helper functions to manage it.\r\n* @example\r\n* toast({ title: \"File saved\", description: \"Your changes were stored.\" })\r\n* { id: \"toast_1\", update: [Function], dismiss: [Function] }\r\n* @param {Toast} props - Configuration object that defines the toastΓÇÖs content and behavior.\r\n* @returns {{ id: string, update: (props: ToasterToast) => void, dismiss: () => void }} Object containing the toast identifier and functions to update or dismiss the toast.\r\n**/\r\nfunction toast({ ...props }: Toast) {\r\n  const id = genId()\r\n\r\n  const update = (props: ToasterToast) =>\r\n    dispatch({\r\n      type: \"UPDATE_TOAST\",\r\n      toast: { ...props, id },\r\n    })\r\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\r\n\r\n  dispatch({\r\n    type: \"ADD_TOAST\",\r\n    toast: {\r\n      ...props,\r\n      id,\r\n      open: true,\r\n      onOpenChange: (open) => {\r\n        if (!open) dismiss()\r\n      },\r\n    },\r\n  })\r\n\r\n  return {\r\n    id: id,\r\n    dismiss,\r\n    update,\r\n  }\r\n}\r\n\r\n/**\r\n* React hook that provides toast notification state and related helper actions.\r\n* @example\r\n* useToast()\r\n* { ...state, toast: fn, dismiss: fn }\r\n* @param {{void}} None - This hook accepts no parameters.\r\n* @returns {{object}} Object containing the current toast state and helper functions `toast` and `dismiss`.\r\n**/\r\nfunction useToast() {\r\n  const [state, setState] = React.useState<State>(memoryState)\r\n\r\n  React.useEffect(() => {\r\n    listeners.push(setState)\r\n    return () => {\r\n      const index = listeners.indexOf(setState)\r\n      if (index > -1) {\r\n        listeners.splice(index, 1)\r\n      }\r\n    }\r\n  }, [state])\r\n\r\n  return {\r\n    ...state,\r\n    toast,\r\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\r\n  }\r\n}\r\n\r\nexport { useToast, toast }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\contexts\\auth-context.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":17,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/contexts/auth-context.tsx\r\n * @description Simplified React context for authentication state management\r\n * @created 2025-01-01\r\n * @modified 2025-01-21\r\n */\r\n\r\n'use client';\r\n\r\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\r\nimport { authService } from '@/lib/services/auth';\r\nimport { AuthUser, AuthState, SignUpData, SignInData, AuthError } from '@/lib/types/auth';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport { AUTH_CONSTANTS } from '@/constants/auth.constants';\r\nimport { recoverSession, validateSession, markUserLoggedOut, clearLogoutMarker } from '@/lib/services/session-recovery.service';\r\n\r\ninterface AuthContextType extends AuthState {\r\n  signUp: (data: SignUpData) => Promise<{ error: AuthError | null }>;\r\n  signIn: (data: SignInData) => Promise<{ error: AuthError | null }>;\r\n  signOut: () => Promise<{ error: AuthError | null }>;\r\n  resetPassword: (email: string) => Promise<{ error: AuthError | null }>;\r\n  updatePassword: (newPassword: string) => Promise<{ error: AuthError | null }>;\r\n  clearError: () => void;\r\n  refreshUser: () => Promise<void>;\r\n}\r\n\r\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\ninterface AuthProviderProps {\r\n  children: React.ReactNode;\r\n  initialUser?: AuthUser | null;\r\n}\r\n\r\n/**\r\n * Authentication provider component that manages auth state\r\n * OPTIMIZED: Reduced from 800 lines to ~300 lines by extracting session recovery logic\r\n * @param {AuthProviderProps} props - Component props\r\n * @returns {JSX.Element} Provider component\r\n */\r\nexport function AuthProvider({ children, initialUser }: AuthProviderProps): React.JSX.Element {\r\n  const [state, setState] = useState<AuthState>({\r\n    user: initialUser || null,\r\n    loading: !initialUser,\r\n    error: null,\r\n  });\r\n\r\n  /**\r\n   * Clear any authentication errors\r\n   */\r\n  const clearError = useCallback(() => {\r\n    setState(prev => ({ ...prev, error: null }));\r\n  }, []);\r\n\r\n  /**\r\n   * Set loading state\r\n   */\r\n  const setLoading = useCallback((loading: boolean) => {\r\n    setState(prev => ({ ...prev, loading }));\r\n  }, []);\r\n\r\n  /**\r\n   * Set error state\r\n   */\r\n  const setError = useCallback((error: AuthError | null) => {\r\n    setState(prev => ({ ...prev, error, loading: false }));\r\n  }, []);\r\n\r\n  /**\r\n   * Set user state\r\n   */\r\n  const setUser = useCallback((user: AuthUser | null) => {\r\n    setState(prev => ({ ...prev, user, loading: false, error: null }));\r\n  }, []);\r\n\r\n  /**\r\n   * Refresh current user data\r\n   */\r\n  const refreshUser = useCallback(async () => {\r\n    try {\r\n      setLoading(true);\r\n      const user = await authService.getCurrentUser();\r\n      setUser(user);\r\n    } catch (error) {\r\n      logger.error('Error refreshing user:', error);\r\n      setError({\r\n        message: error instanceof Error ? error.message : 'Failed to refresh user data',\r\n      });\r\n    }\r\n  }, [setLoading, setUser, setError]);\r\n\r\n  /**\r\n   * Sign up a new user\r\n   */\r\n  const signUp = useCallback(async (data: SignUpData): Promise<{ error: AuthError | null }> => {\r\n    try {\r\n      setLoading(true);\r\n      clearError();\r\n\r\n      const { user, error } = await authService.signUp(data);\r\n\r\n      if (error) {\r\n        setError(error);\r\n        return { error };\r\n      }\r\n\r\n      setUser(user);\r\n      return { error: null };\r\n    } catch (error) {\r\n      const authError = {\r\n        message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n      };\r\n      setError(authError);\r\n      return { error: authError };\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [setLoading, clearError, setError, setUser]);\r\n\r\n  /**\r\n   * Sign in an existing user\r\n   */\r\n  const signIn = useCallback(async (data: SignInData): Promise<{ error: AuthError | null }> => {\r\n    try {\r\n      setLoading(true);\r\n      clearError();\r\n\r\n      const { user, error } = await authService.signIn(data);\r\n\r\n      if (error) {\r\n        setError(error);\r\n        return { error };\r\n      }\r\n\r\n      // Clear logout marker on successful login\r\n      clearLogoutMarker();\r\n\r\n      setUser(user);\r\n      return { error: null };\r\n    } catch (error) {\r\n      const authError = {\r\n        message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n      };\r\n      setError(authError);\r\n      return { error: authError };\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [setLoading, clearError, setError, setUser]);\r\n\r\n  /**\r\n   * Sign out current user\r\n   */\r\n  const signOut = useCallback(async (): Promise<{ error: AuthError | null }> => {\r\n    try {\r\n      setLoading(true);\r\n      clearError();\r\n\r\n      // Mark user as logged out BEFORE actual signout\r\n      markUserLoggedOut();\r\n\r\n      // Sign out from Supabase\r\n      const { error } = await authService.signOut();\r\n\r\n      if (error) {\r\n        setError(error);\r\n        return { error };\r\n      }\r\n\r\n      setUser(null);\r\n      return { error: null };\r\n    } catch (error) {\r\n      const authError = {\r\n        message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n      };\r\n      setError(authError);\r\n      return { error: authError };\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [setLoading, clearError, setError, setUser]);\r\n\r\n  /**\r\n   * Reset user password\r\n   */\r\n  const resetPassword = useCallback(async (email: string): Promise<{ error: AuthError | null }> => {\r\n    try {\r\n      clearError();\r\n      return await authService.resetPassword(email);\r\n    } catch (error) {\r\n      const authError = {\r\n        message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n      };\r\n      setError(authError);\r\n      return { error: authError };\r\n    }\r\n  }, [clearError, setError]);\r\n\r\n  /**\r\n   * Update user password\r\n   */\r\n  const updatePassword = useCallback(async (newPassword: string): Promise<{ error: AuthError | null }> => {\r\n    try {\r\n      clearError();\r\n      return await authService.updatePassword(newPassword);\r\n    } catch (error) {\r\n      const authError = {\r\n        message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n      };\r\n      setError(authError);\r\n      return { error: authError };\r\n    }\r\n  }, [clearError, setError]);\r\n\r\n  // Initialize auth state and listen for changes\r\n  useEffect(() => {\r\n    let mounted = true;\r\n    let sessionCheckInterval: NodeJS.Timeout | null = null;\r\n\r\n    /**\r\n     * Initialize authentication state\r\n     * OPTIMIZED: Reduced timeout from 35s/15s to 8s\r\n     */\r\n    const initializeAuth = async () => {\r\n      // If we have an initial user from SSR, skip client-side recovery\r\n      if (initialUser) {\r\n        logger.debug('Auth initialized with SSR user');\r\n        return;\r\n      }\r\n\r\n      try {\r\n        // Set timeout for auth initialization\r\n        const timeoutPromise = new Promise<never>((_, reject) => {\r\n          setTimeout(() => reject(new Error('Auth initialization timeout')), AUTH_CONSTANTS.INIT_TIMEOUT);\r\n        });\r\n\r\n        const userPromise = recoverSession();\r\n\r\n        try {\r\n          const user = await Promise.race([userPromise, timeoutPromise]);\r\n\r\n          if (mounted) {\r\n            setUser(user);\r\n\r\n            // Set up periodic session validation (every 2 minutes)\r\n            // Only validate if we have a user\r\n            sessionCheckInterval = setInterval(async () => {\r\n              // Check if we have a current user before validating session\r\n              // This prevents spurious \"session expired\" toasts on public pages\r\n              const currentUser = await authService.getCurrentUser();\r\n              if (!currentUser) return;\r\n\r\n              const isValid = await validateSession();\r\n              if (!isValid && mounted) {\r\n                logger.warn('Session expired, redirecting to login');\r\n                setUser(null);\r\n                if (typeof window !== 'undefined' && !window.location.pathname.startsWith('/login')) {\r\n                  window.location.replace('/login?expired=true');\r\n                }\r\n              }\r\n            }, AUTH_CONSTANTS.SESSION_CHECK_INTERVAL);\r\n          }\r\n        } catch (timeoutError) {\r\n          if (mounted) {\r\n            logger.warn('Auth initialization timed out');\r\n            setUser(null);\r\n            setError({\r\n              message: 'Authentication is taking longer than expected. Please refresh the page or try logging in again.',\r\n            });\r\n          }\r\n        }\r\n      } catch (error) {\r\n        logger.error('Error initializing auth:', error);\r\n        if (mounted) {\r\n          setError({\r\n            message: 'Failed to initialize authentication',\r\n          });\r\n        }\r\n      }\r\n    };\r\n\r\n    initializeAuth();\r\n\r\n    // Listen for auth state changes\r\n    const { data: { subscription } } = authService.onAuthStateChange(async (event, session) => {\r\n      if (!mounted) return;\r\n\r\n      try {\r\n        if (event === 'SIGNED_IN' && session?.user) {\r\n          const user = await authService.getCurrentUser();\r\n          if (user && mounted) {\r\n            setUser(user);\r\n          }\r\n        } else if (event === 'SIGNED_OUT') {\r\n          if (mounted) {\r\n            logger.info('Auth state changed to SIGNED_OUT');\r\n            setUser(null);\r\n\r\n            // Only redirect if not already on login page\r\n            if (typeof window !== 'undefined' && !window.location.pathname.startsWith('/login')) {\r\n              window.location.replace('/login');\r\n            }\r\n          }\r\n        } else if (event === 'TOKEN_REFRESHED' && session?.user) {\r\n          const user = await authService.getCurrentUser();\r\n          if (user && mounted) {\r\n            setUser(user);\r\n          }\r\n        } else if (!session && mounted) {\r\n          setUser(null);\r\n        }\r\n      } catch (error) {\r\n        logger.error('Error handling auth state change:', error);\r\n        if (mounted) {\r\n          setError({\r\n            message: 'Authentication state change failed',\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    // Listen for logout broadcasts from other tabs\r\n    if (typeof window !== 'undefined' && 'BroadcastChannel' in window) {\r\n      const channel = new BroadcastChannel('auth-sync');\r\n      channel.addEventListener('message', (event) => {\r\n        try {\r\n          if (event.data.type === 'LOGOUT' && mounted) {\r\n            setUser(null);\r\n            if (!window.location.pathname.startsWith('/login')) {\r\n              window.location.replace('/login');\r\n            }\r\n          } else if (event.data.type === 'SESSION_EXPIRED' && mounted) {\r\n            setUser(null);\r\n            if (!window.location.pathname.startsWith('/login')) {\r\n              window.location.replace('/login?expired=true');\r\n            }\r\n          }\r\n        } catch (error) {\r\n          logger.error('Error handling broadcast message:', error);\r\n        }\r\n      });\r\n\r\n      return () => {\r\n        mounted = false;\r\n        if (sessionCheckInterval) {\r\n          clearInterval(sessionCheckInterval);\r\n        }\r\n        subscription?.unsubscribe();\r\n        try {\r\n          channel.close();\r\n        } catch (error) {\r\n          logger.warn('Error closing broadcast channel:', error);\r\n        }\r\n      };\r\n    }\r\n\r\n    return () => {\r\n      mounted = false;\r\n      if (sessionCheckInterval) {\r\n        clearInterval(sessionCheckInterval);\r\n      }\r\n      subscription?.unsubscribe();\r\n    };\r\n  }, [setUser, setError, initialUser]);\r\n\r\n  const value: AuthContextType = {\r\n    ...state,\r\n    signUp,\r\n    signIn,\r\n    signOut,\r\n    resetPassword,\r\n    updatePassword,\r\n    clearError,\r\n    refreshUser,\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={value}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n}\r\n\r\n/**\r\n * Hook to use authentication context\r\n * @returns {AuthContextType} Authentication context\r\n * @throws {Error} When used outside AuthProvider\r\n */\r\nexport function useAuth(): AuthContextType {\r\n  const context = useContext(AuthContext);\r\n\r\n  if (context === undefined) {\r\n    throw new Error('useAuth must be used within an AuthProvider');\r\n  }\r\n\r\n  return context;\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\errors\\app-error.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token readonly","line":11,"column":10,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/errors/app-error.ts\r\n * @description Custom error classes for standardized error handling\r\n * @created 2025-01-01\r\n */\r\n\r\n/**\r\n * Base application error class with error context\r\n */\r\nexport class AppError extends Error {\r\n  public readonly code: string;\r\n  public readonly context?: Record<string, unknown>;\r\n  public readonly timestamp: Date;\r\n  public readonly originalError?: Error;\r\n\r\n  constructor(\r\n    message: string,\r\n    code: string = 'APP_ERROR',\r\n    context?: Record<string, unknown>,\r\n    originalError?: Error\r\n  ) {\r\n    super(message);\r\n    this.name = this.constructor.name;\r\n    this.code = code;\r\n    this.context = context;\r\n    this.timestamp = new Date();\r\n    this.originalError = originalError;\r\n\r\n    // Maintains proper stack trace for where error was thrown\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, this.constructor);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get error details for logging/debugging\r\n   */\r\n  getDetails(): Record<string, unknown> {\r\n    return {\r\n      name: this.name,\r\n      code: this.code,\r\n      message: this.message,\r\n      context: this.context,\r\n      timestamp: this.timestamp.toISOString(),\r\n      ...(this.originalError && {\r\n        originalError: {\r\n          name: this.originalError.name,\r\n          message: this.originalError.message,\r\n          stack: this.originalError.stack,\r\n        },\r\n      }),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Convert error to JSON for logging\r\n   */\r\n  toJSON(): Record<string, unknown> {\r\n    return this.getDetails();\r\n  }\r\n}\r\n\r\n/**\r\n * Database operation error\r\n */\r\nexport class DatabaseError extends AppError {\r\n  constructor(\r\n    message: string,\r\n    context?: Record<string, unknown>,\r\n    originalError?: Error\r\n  ) {\r\n    super(message, 'DATABASE_ERROR', context, originalError);\r\n  }\r\n}\r\n\r\n/**\r\n * Authentication error\r\n */\r\nexport class AuthenticationError extends AppError {\r\n  constructor(\r\n    message: string = 'User not authenticated',\r\n    context?: Record<string, unknown>\r\n  ) {\r\n    super(message, 'AUTHENTICATION_ERROR', context);\r\n  }\r\n}\r\n\r\n/**\r\n * Validation error\r\n */\r\nexport class ValidationError extends AppError {\r\n  constructor(\r\n    message: string,\r\n    field?: string,\r\n    context?: Record<string, unknown>\r\n  ) {\r\n    super(\r\n      message,\r\n      'VALIDATION_ERROR',\r\n      { field, ...context }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Cache operation error\r\n */\r\nexport class CacheError extends AppError {\r\n  constructor(\r\n    message: string,\r\n    context?: Record<string, unknown>,\r\n    originalError?: Error\r\n  ) {\r\n    super(message, 'CACHE_ERROR', context, originalError);\r\n  }\r\n}\r\n\r\n/**\r\n * Network/API error\r\n */\r\nexport class NetworkError extends AppError {\r\n  constructor(\r\n    message: string,\r\n    statusCode?: number,\r\n    context?: Record<string, unknown>,\r\n    originalError?: Error\r\n  ) {\r\n    super(\r\n      message,\r\n      'NETWORK_ERROR',\r\n      { statusCode, ...context },\r\n      originalError\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Not found error\r\n */\r\nexport class NotFoundError extends AppError {\r\n  constructor(\r\n    resource: string,\r\n    identifier?: string,\r\n    context?: Record<string, unknown>\r\n  ) {\r\n    super(\r\n      `${resource} not found${identifier ? `: ${identifier}` : ''}`,\r\n      'NOT_FOUND_ERROR',\r\n      { resource, identifier, ...context }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Permission error\r\n */\r\nexport class PermissionError extends AppError {\r\n  constructor(\r\n    message: string = 'Insufficient permissions',\r\n    context?: Record<string, unknown>\r\n  ) {\r\n    super(message, 'PERMISSION_ERROR', context);\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\middleware\\rate-limit.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":7,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/middleware/rate-limit.ts\r\n * @description Rate limiting middleware for API routes\r\n * @created 2025-11-11\r\n */\r\n\r\ninterface RateLimitConfig {\r\n  interval: number; // Time window in milliseconds\r\n  maxRequests: number; // Max requests per interval\r\n}\r\n\r\ninterface RateLimitStore {\r\n  count: number;\r\n  resetTime: number;\r\n}\r\n\r\nconst rateLimitStore = new Map<string, RateLimitStore>();\r\n\r\n/**\r\n * Rate limiter for API routes\r\n * @param {RateLimitConfig} config - Rate limiting configuration\r\n * @returns {Function} Rate limiting function\r\n */\r\nexport function createRateLimiter(config: RateLimitConfig) {\r\n  const { interval, maxRequests } = config;\r\n\r\n  return {\r\n    /**\r\n     * Check if request is within rate limit\r\n     * @param {Request} request - Incoming request\r\n     * @param {string} identifier - Optional identifier (defaults to IP)\r\n     * @returns {{allowed: boolean; remaining: number; resetTime: number}}\r\n     */\r\n    check(request: Request, identifier?: string) {\r\n      const key = identifier || getClientIp(request);\r\n      const now = Date.now();\r\n      \r\n      // Clean up old entries periodically\r\n      if (Math.random() < 0.01) { // 1% chance to clean up\r\n        cleanupOldEntries(now);\r\n      }\r\n\r\n      let store = rateLimitStore.get(key);\r\n      \r\n      if (!store || now >= store.resetTime) {\r\n        // Create new store or reset expired one\r\n        store = {\r\n          count: 0,\r\n          resetTime: now + interval,\r\n        };\r\n        rateLimitStore.set(key, store);\r\n      }\r\n\r\n      if (store.count >= maxRequests) {\r\n        return {\r\n          allowed: false,\r\n          remaining: 0,\r\n          resetTime: store.resetTime,\r\n        };\r\n      }\r\n\r\n      store.count++;\r\n      \r\n      return {\r\n        allowed: true,\r\n        remaining: maxRequests - store.count,\r\n        resetTime: store.resetTime,\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Reset rate limit for a specific identifier\r\n     * @param {string} identifier - Identifier to reset\r\n     */\r\n    reset(identifier: string) {\r\n      rateLimitStore.delete(identifier);\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Get client IP address from request\r\n * @param {Request} request - Incoming request\r\n * @returns {string} Client IP address\r\n */\r\nfunction getClientIp(request: Request): string {\r\n  // Check for forwarded IP (behind proxy)\r\n  const forwarded = request.headers.get('x-forwarded-for');\r\n  if (forwarded) {\r\n    return forwarded.split(',')[0].trim();\r\n  }\r\n\r\n  // Check for real IP\r\n  const realIp = request.headers.get('x-real-ip');\r\n  if (realIp) {\r\n    return realIp;\r\n  }\r\n\r\n  // Fallback to a generic identifier (less accurate but prevents errors)\r\n  return 'unknown-ip';\r\n}\r\n\r\n/**\r\n * Clean up expired entries from the rate limit store\r\n * @param {number} now - Current timestamp\r\n */\r\nfunction cleanupOldEntries(now: number): void {\r\n  for (const [key, store] of rateLimitStore.entries()) {\r\n    if (now >= store.resetTime) {\r\n      rateLimitStore.delete(key);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create a rate limit response\r\n * @param {boolean} allowed - Whether request is allowed\r\n * @param {number} remaining - Remaining requests\r\n * @param {number} resetTime - Time when limit resets\r\n * @returns {Response} Rate limit response\r\n */\r\nexport function createRateLimitResponse(\r\n  allowed: boolean,\r\n  remaining: number,\r\n  resetTime: number\r\n): Response {\r\n  const headers = {\r\n    'X-RateLimit-Limit': '10',\r\n    'X-RateLimit-Remaining': remaining.toString(),\r\n    'X-RateLimit-Reset': Math.ceil(resetTime / 1000).toString(),\r\n  };\r\n\r\n  if (!allowed) {\r\n    return new Response(\r\n      JSON.stringify({\r\n        error: 'Too many requests',\r\n        message: 'Rate limit exceeded. Please try again later.',\r\n        retryAfter: Math.ceil((resetTime - Date.now()) / 1000),\r\n      }),\r\n      {\r\n        status: 429,\r\n        headers: {\r\n          ...headers,\r\n          'Content-Type': 'application/json',\r\n          'Retry-After': Math.ceil((resetTime - Date.now()) / 1000).toString(),\r\n        },\r\n      }\r\n    );\r\n  }\r\n\r\n  return new Response(null, {\r\n    status: 200,\r\n    headers,\r\n  });\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\auth-debug.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":10,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/auth-debug.service.ts\r\n * @description Enhanced authentication debugging service for session management analysis\r\n * @created 2025-11-15\r\n */\r\n\r\nimport { debugLogger } from './debug-logger.service';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface AuthDebugSession {\r\n  sessionId: string;\r\n  startTime: number;\r\n  endTime?: number;\r\n  strategiesAttempted: string[];\r\n  finalStrategy?: string;\r\n  success: boolean;\r\n  totalDuration: number;\r\n  retryCount: number;\r\n  browserInfo: {\r\n    isMobile: boolean;\r\n    isIOS: boolean;\r\n    isAndroid: boolean;\r\n    isSafari: boolean;\r\n    supportsPersistentStorage: boolean;\r\n    hasReliableStorage: boolean;\r\n  };\r\n}\r\n\r\ninterface SessionRecoveryAttempt {\r\n  strategy: string;\r\n  startTime: number;\r\n  endTime?: number;\r\n  success: boolean;\r\n  error?: string;\r\n  retryCount: number;\r\n}\r\n\r\nclass AuthDebugService {\r\n  private currentSession: AuthDebugSession | null = null;\r\n  private recoveryAttempts: SessionRecoveryAttempt[] = [];\r\n  private isEnabled: boolean;\r\n\r\n  constructor() {\r\n    this.isEnabled = process.env.NODE_ENV === 'development' || process.env.DEBUG_MODE === 'true';\r\n  }\r\n\r\n  /**\r\n   * Start a new authentication debugging session\r\n   */\r\n  startAuthSession(browserInfo: any): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    const sessionId = debugLogger.debugInfo().sessionId;\r\n    const startTime = Date.now();\r\n\r\n    this.currentSession = {\r\n      sessionId,\r\n      startTime,\r\n      endTime: undefined,\r\n      strategiesAttempted: [],\r\n      finalStrategy: undefined,\r\n      success: false,\r\n      totalDuration: 0,\r\n      retryCount: 0,\r\n      browserInfo: {\r\n        isMobile: browserInfo.isMobile || false,\r\n        isIOS: browserInfo.isIOS || false,\r\n        isAndroid: browserInfo.isAndroid || false,\r\n        isSafari: browserInfo.isSafari || false,\r\n        supportsPersistentStorage: browserInfo.supportsPersistentStorage || false,\r\n        hasReliableStorage: browserInfo.hasReliableStorage || false,\r\n      }\r\n    };\r\n\r\n    debugLogger.auth({\r\n      operation: 'auth_session_start',\r\n      success: true,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        browserInfo: this.currentSession.browserInfo\r\n      }\r\n    });\r\n\r\n    logger.debug('Auth debugging session started', {\r\n      sessionId: this.currentSession.sessionId,\r\n      browserInfo: this.currentSession.browserInfo\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log a session recovery attempt\r\n   */\r\n  logRecoveryAttempt(strategy: string, success: boolean, error?: string, retryCount: number = 0): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    const attempt: SessionRecoveryAttempt = {\r\n      strategy,\r\n      startTime: Date.now(),\r\n      endTime: success || error ? Date.now() : undefined,\r\n      success,\r\n      error,\r\n      retryCount\r\n    };\r\n\r\n    this.recoveryAttempts.push(attempt);\r\n\r\n    if (this.currentSession) {\r\n      this.currentSession.strategiesAttempted.push(strategy);\r\n      this.currentSession.retryCount = Math.max(this.currentSession.retryCount, retryCount);\r\n    }\r\n\r\n    debugLogger.auth({\r\n      operation: `session_recovery_${strategy}`,\r\n      success,\r\n      duration: attempt.endTime ? attempt.endTime - attempt.startTime : 0,\r\n      strategy,\r\n      retryCount,\r\n      error,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        attemptIndex: this.recoveryAttempts.length\r\n      }\r\n    });\r\n\r\n    logger.debug(`Session recovery attempt: ${strategy}`, {\r\n      success,\r\n      retryCount,\r\n      error,\r\n      sessionId: this.currentSession.sessionId\r\n    });\r\n\r\n    // If this is a final result (success or error), log completion\r\n    if (success || error) {\r\n      const duration = attempt.endTime! - attempt.startTime;\r\n      debugLogger.auth({\r\n        operation: `session_recovery_${strategy}_complete`,\r\n        success,\r\n        duration,\r\n        strategy,\r\n        retryCount,\r\n        error,\r\n        metadata: {\r\n          sessionId: this.currentSession.sessionId,\r\n          attemptIndex: this.recoveryAttempts.length,\r\n          finalResult: true\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark a recovery strategy as successful\r\n   */\r\n  markRecoverySuccess(strategy: string): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    this.currentSession.finalStrategy = strategy;\r\n    this.currentSession.success = true;\r\n    this.currentSession.endTime = Date.now();\r\n    this.currentSession.totalDuration = this.currentSession.endTime - this.currentSession.startTime;\r\n\r\n    debugLogger.auth({\r\n      operation: 'session_recovery_success',\r\n      success: true,\r\n      duration: this.currentSession.totalDuration,\r\n      strategy,\r\n      retryCount: this.currentSession.retryCount,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        strategiesAttempted: this.currentSession.strategiesAttempted,\r\n        browserInfo: this.currentSession.browserInfo\r\n      }\r\n    });\r\n\r\n    logger.info('Session recovery successful', {\r\n      strategy,\r\n      totalDuration: this.currentSession.totalDuration,\r\n      strategiesAttempted: this.currentSession.strategiesAttempted,\r\n      retryCount: this.currentSession.retryCount,\r\n      browserInfo: this.currentSession.browserInfo\r\n    });\r\n\r\n    this.endAuthSession();\r\n  }\r\n\r\n  /**\r\n   * Mark recovery as failed\r\n   */\r\n  markRecoveryFailed(finalError: string): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    this.currentSession.success = false;\r\n    this.currentSession.endTime = Date.now();\r\n    this.currentSession.totalDuration = this.currentSession.endTime - this.currentSession.startTime;\r\n\r\n    debugLogger.auth({\r\n      operation: 'session_recovery_failed',\r\n      success: false,\r\n      duration: this.currentSession.totalDuration,\r\n      error: finalError,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        strategiesAttempted: this.currentSession.strategiesAttempted,\r\n        finalError,\r\n        browserInfo: this.currentSession.browserInfo\r\n      }\r\n    });\r\n\r\n    logger.error('Session recovery failed', {\r\n      totalDuration: this.currentSession.totalDuration,\r\n      strategiesAttempted: this.currentSession.strategiesAttempted,\r\n      finalError,\r\n      browserInfo: this.currentSession.browserInfo\r\n    });\r\n\r\n    this.endAuthSession();\r\n  }\r\n\r\n  /**\r\n   * End the current authentication session\r\n   */\r\n  private endAuthSession(): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    debugLogger.auth({\r\n      operation: 'auth_session_end',\r\n      success: this.currentSession.success,\r\n      duration: this.currentSession.totalDuration,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        finalStrategy: this.currentSession.finalStrategy,\r\n        strategiesAttempted: this.currentSession.strategiesAttempted,\r\n        browserInfo: this.currentSession.browserInfo\r\n      }\r\n    });\r\n\r\n    // Store session data for analysis\r\n    this.storeSessionData();\r\n\r\n    // Reset for next session\r\n    this.currentSession = null;\r\n    this.recoveryAttempts = [];\r\n  }\r\n\r\n  /**\r\n   * Log authentication state changes\r\n   */\r\n  logAuthStateChange(event: string, session: any, metadata?: Record<string, any>): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    debugLogger.auth({\r\n      operation: `auth_state_change_${event}`,\r\n      success: ['SIGNED_IN', 'TOKEN_REFRESHED'].includes(event),\r\n      metadata: {\r\n        event,\r\n        hasSession: !!session,\r\n        userId: session?.user?.id,\r\n        sessionId: this.currentSession?.sessionId,\r\n        ...metadata\r\n      }\r\n    });\r\n\r\n    logger.debug(`Auth state change: ${event}`, { \r\n      event, \r\n      hasSession: !!session,\r\n      userId: session?.user?.id,\r\n      sessionId: this.currentSession?.sessionId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log middleware authentication checks\r\n   */\r\n  logMiddlewareAuthCheck(operation: string, success: boolean, duration: number, metadata?: Record<string, any>): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    debugLogger.auth({\r\n      operation: `middleware_${operation}`,\r\n      success,\r\n      duration,\r\n      metadata: {\r\n        sessionId: this.currentSession?.sessionId,\r\n        ...metadata\r\n      }\r\n    });\r\n\r\n    logger.debug(`Middleware auth check: ${operation}`, { \r\n      success, \r\n      duration,\r\n      sessionId: this.currentSession?.sessionId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log timeout events\r\n   */\r\n  logTimeout(operation: string, timeoutDuration: number, metadata?: Record<string, any>): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    debugLogger.auth({\r\n      operation: `auth_timeout_${operation}`,\r\n      success: false,\r\n      error: `Authentication timeout after ${timeoutDuration}ms`,\r\n      metadata: {\r\n        timeoutDuration,\r\n        sessionId: this.currentSession?.sessionId,\r\n        ...metadata\r\n      }\r\n    });\r\n\r\n    logger.warn(`Authentication timeout: ${operation}`, {\r\n      timeoutDuration,\r\n      sessionId: this.currentSession?.sessionId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Store session data for analysis\r\n   */\r\n  private storeSessionData(): void {\r\n    if (!this.currentSession) return;\r\n\r\n    // Store in localStorage for persistence (development only)\r\n    if (process.env.NODE_ENV === 'development' && typeof localStorage !== 'undefined') {\r\n      try {\r\n        const storedData = JSON.parse(localStorage.getItem('auth_debug_sessions') || '[]');\r\n        storedData.push(this.currentSession);\r\n        \r\n        // Keep only last 50 sessions\r\n        if (storedData.length > 50) {\r\n          storedData.splice(0, storedData.length - 50);\r\n        }\r\n        \r\n        localStorage.setItem('auth_debug_sessions', JSON.stringify(storedData));\r\n      } catch (error) {\r\n        logger.error('Failed to store auth debug session data:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get authentication performance summary\r\n   */\r\n  getAuthPerformanceSummary(): {\r\n    totalSessions: number;\r\n    successRate: number;\r\n    averageRecoveryTime: number;\r\n    mostSuccessfulStrategy: string;\r\n    strategyPerformance: Record<string, {\r\n      attempts: number;\r\n      successes: number;\r\n      averageDuration: number;\r\n    }>;\r\n    browserPerformance: Record<string, {\r\n      sessions: number;\r\n      successRate: number;\r\n      averageDuration: number;\r\n    }>;\r\n  } {\r\n    if (process.env.NODE_ENV !== 'development' || typeof localStorage === 'undefined') {\r\n      return {\r\n        totalSessions: 0,\r\n        successRate: 0,\r\n        averageRecoveryTime: 0,\r\n        mostSuccessfulStrategy: '',\r\n        strategyPerformance: {},\r\n        browserPerformance: {}\r\n      };\r\n    }\r\n\r\n    try {\r\n      const storedData = JSON.parse(localStorage.getItem('auth_debug_sessions') || '[]');\r\n      \r\n      if (storedData.length === 0) {\r\n        return {\r\n          totalSessions: 0,\r\n          successRate: 0,\r\n          averageRecoveryTime: 0,\r\n          mostSuccessfulStrategy: '',\r\n          strategyPerformance: {},\r\n          browserPerformance: {}\r\n        };\r\n      }\r\n\r\n      const successfulSessions = storedData.filter((session: AuthDebugSession) => session.success);\r\n      const successRate = (successfulSessions.length / storedData.length) * 100;\r\n\r\n      const averageRecoveryTime = storedData.reduce((sum: number, session: AuthDebugSession) => \r\n        sum + (session.totalDuration || 0), 0) / storedData.length;\r\n\r\n      // Strategy performance analysis\r\n      const strategyPerformance: Record<string, any> = {};\r\n      storedData.forEach((session: AuthDebugSession) => {\r\n        session.strategiesAttempted.forEach(strategy => {\r\n          if (!strategyPerformance[strategy]) {\r\n            strategyPerformance[strategy] = {\r\n              attempts: 0,\r\n              successes: 0,\r\n              durations: []\r\n            };\r\n          }\r\n          strategyPerformance[strategy].attempts++;\r\n          if (session.success && session.finalStrategy === strategy) {\r\n            strategyPerformance[strategy].successes++;\r\n          }\r\n          if (session.finalStrategy === strategy) {\r\n            strategyPerformance[strategy].durations.push(session.totalDuration);\r\n          }\r\n        });\r\n      });\r\n\r\n      // Calculate strategy averages\r\n      Object.keys(strategyPerformance).forEach(strategy => {\r\n        const data = strategyPerformance[strategy];\r\n        data.averageDuration = data.durations.length > 0 \r\n          ? data.durations.reduce((sum: number, dur: number) => sum + dur, 0) / data.durations.length \r\n          : 0;\r\n        delete data.durations; // Remove raw data\r\n      });\r\n\r\n      // Find most successful strategy\r\n      let mostSuccessfulStrategy = '';\r\n      let highestSuccessRate = 0;\r\n      Object.entries(strategyPerformance).forEach(([strategy, data]: [string, any]) => {\r\n        const strategySuccessRate = (data.successes / data.attempts) * 100;\r\n        if (strategySuccessRate > highestSuccessRate) {\r\n          highestSuccessRate = strategySuccessRate;\r\n          mostSuccessfulStrategy = strategy;\r\n        }\r\n      });\r\n\r\n      // Browser performance analysis\r\n      const browserPerformance: Record<string, any> = {};\r\n      storedData.forEach((session: AuthDebugSession) => {\r\n        const browserKey = `${session.browserInfo.isMobile ? 'mobile' : 'desktop'}_${session.browserInfo.isIOS ? 'ios' : session.browserInfo.isAndroid ? 'android' : 'other'}`;\r\n        \r\n        if (!browserPerformance[browserKey]) {\r\n          browserPerformance[browserKey] = {\r\n            sessions: 0,\r\n            successes: 0,\r\n            durations: []\r\n          };\r\n        }\r\n        \r\n        browserPerformance[browserKey].sessions++;\r\n        if (session.success) {\r\n          browserPerformance[browserKey].successes++;\r\n        }\r\n        browserPerformance[browserKey].durations.push(session.totalDuration);\r\n      });\r\n\r\n      // Calculate browser averages\r\n      Object.keys(browserPerformance).forEach(browserKey => {\r\n        const data = browserPerformance[browserKey];\r\n        data.successRate = (data.successes / data.sessions) * 100;\r\n        data.averageDuration = data.durations.length > 0 \r\n          ? data.durations.reduce((sum: number, dur: number) => sum + dur, 0) / data.durations.length \r\n          : 0;\r\n        delete data.durations; // Remove raw data\r\n      });\r\n\r\n      return {\r\n        totalSessions: storedData.length,\r\n        successRate,\r\n        averageRecoveryTime,\r\n        mostSuccessfulStrategy,\r\n        strategyPerformance,\r\n        browserPerformance\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to analyze auth performance data:', error);\r\n      return {\r\n        totalSessions: 0,\r\n        successRate: 0,\r\n        averageRecoveryTime: 0,\r\n        mostSuccessfulStrategy: '',\r\n        strategyPerformance: {},\r\n        browserPerformance: {}\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear stored debug data\r\n   */\r\n  clearDebugData(): void {\r\n    if (process.env.NODE_ENV === 'development' && typeof localStorage !== 'undefined') {\r\n      try {\r\n        localStorage.removeItem('auth_debug_sessions');\r\n        logger.info('Auth debug data cleared');\r\n      } catch (error) {\r\n        logger.error('Failed to clear auth debug data:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Export debug data\r\n   */\r\n  exportDebugData(): string {\r\n    if (process.env.NODE_ENV === 'development' && typeof localStorage !== 'undefined') {\r\n      try {\r\n        const storedData = localStorage.getItem('auth_debug_sessions');\r\n        return storedData || '[]';\r\n      } catch (error) {\r\n        logger.error('Failed to export auth debug data:', error);\r\n        return '[]';\r\n      }\r\n    }\r\n    return '[]';\r\n  }\r\n\r\n  /**\r\n   * Enable/disable debugging\r\n   */\r\n  setEnabled(enabled: boolean): void {\r\n    this.isEnabled = enabled;\r\n    if (enabled) {\r\n      logger.info('Auth debugging enabled');\r\n    } else {\r\n      logger.info('Auth debugging disabled');\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const authDebugService = new AuthDebugService();\r\n\r\n// Export convenience functions\r\nexport const authDebug = {\r\n  startSession: (browserInfo: any) => authDebugService.startAuthSession(browserInfo),\r\n  logRecovery: (strategy: string, success: boolean, error?: string, retryCount?: number) => \r\n    authDebugService.logRecoveryAttempt(strategy, success, error, retryCount),\r\n  markSuccess: (strategy: string) => authDebugService.markRecoverySuccess(strategy),\r\n  markFailed: (error: string) => authDebugService.markRecoveryFailed(error),\r\n  logStateChange: (event: string, session: any, metadata?: Record<string, any>) => \r\n    authDebugService.logAuthStateChange(event, session, metadata),\r\n  logMiddleware: (operation: string, success: boolean, duration: number, metadata?: Record<string, any>) => \r\n    authDebugService.logMiddlewareAuthCheck(operation, success, duration, metadata),\r\n  logTimeout: (operation: string, timeoutDuration: number, metadata?: Record<string, any>) => \r\n    authDebugService.logTimeout(operation, timeoutDuration, metadata),\r\n  getSummary: () => authDebugService.getAuthPerformanceSummary(),\r\n  clearData: () => authDebugService.clearDebugData(),\r\n  exportData: () => authDebugService.exportDebugData(),\r\n  enable: () => authDebugService.setEnabled(true),\r\n  disable: () => authDebugService.setEnabled(false)\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\auth-optimization.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":13,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/auth-optimization.service.ts\r\n * @description Authentication optimization service for faster session recovery\r\n * @created 2025-11-15\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { AuthUser } from '@/lib/types/auth';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport { detectMobileBrowser, needsMobileSessionHandling } from '@/lib/utils/platform';\r\nimport { authDebug } from './auth-debug.service';\r\n\r\ninterface AuthStrategy {\r\n  name: string;\r\n  timeout: number;\r\n  retryCount: number;\r\n}\r\n\r\ninterface RecoveryResult {\r\n  user: AuthUser | null;\r\n  strategy: string;\r\n  duration: number;\r\n  success: boolean;\r\n}\r\n\r\nclass AuthOptimizationService {\r\n  private supabase = createClient();\r\n  private cache = new Map<string, { user: AuthUser; timestamp: number }>();\r\n  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\r\n\r\n  /**\r\n   * OPTIMIZED: Streamlined session recovery with faster timeouts and intelligent strategies\r\n   */\r\n  async recoverSession(): Promise<AuthUser | null> {\r\n    const startTime = Date.now();\r\n    const browserInfo = detectMobileBrowser();\r\n    const isMobile = needsMobileSessionHandling();\r\n\r\n    // OPTIMIZED: Faster timeouts based on device type\r\n    const strategies: AuthStrategy[] = isMobile \r\n      ? [\r\n          { name: 'direct', timeout: 3000, retryCount: 1 },    // Fast direct recovery\r\n          { name: 'cached', timeout: 2000, retryCount: 1 },    // Local storage cache\r\n          { name: 'refresh', timeout: 4000, retryCount: 1 }    // Token refresh\r\n        ]\r\n      : [\r\n          { name: 'direct', timeout: 2000, retryCount: 1 },    // Even faster for desktop\r\n          { name: 'cached', timeout: 1000, retryCount: 0 },    // No retries for cache\r\n          { name: 'refresh', timeout: 3000, retryCount: 1 }    // Token refresh\r\n        ];\r\n\r\n    authDebug.logRecovery('session_recovery_start', false, undefined, 0);\r\n\r\n    for (const strategy of strategies) {\r\n      try {\r\n        authDebug.logRecovery(strategy.name, false, undefined, 0);\r\n        \r\n        const result = await this.attemptStrategy(strategy);\r\n        \r\n        if (result.success && result.user) {\r\n          const duration = Date.now() - startTime;\r\n          authDebug.markSuccess(strategy.name);\r\n          authDebug.logRecovery(strategy.name, true, undefined, 0);\r\n          \r\n          // Cache successful recovery\r\n          this.cache.set('session_recovery', {\r\n            user: result.user,\r\n            timestamp: Date.now()\r\n          });\r\n\r\n          logger.info(`Session recovered via ${strategy.name} in ${duration}ms`);\r\n          return result.user;\r\n        }\r\n      } catch (error) {\r\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n        authDebug.logRecovery(strategy.name, false, errorMessage, 0);\r\n        logger.warn(`Session recovery strategy ${strategy.name} failed:`, error);\r\n      }\r\n    }\r\n\r\n    const totalDuration = Date.now() - startTime;\r\n    authDebug.markFailed('All recovery strategies failed');\r\n    logger.warn(`Session recovery failed after ${totalDuration}ms`);\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * OPTIMIZED: Individual recovery strategy with timeout protection\r\n   */\r\n  private async attemptStrategy(strategy: AuthStrategy): Promise<RecoveryResult> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      switch (strategy.name) {\r\n        case 'direct':\r\n          return await this.directRecovery(strategy.timeout);\r\n        \r\n        case 'cached':\r\n          return await this.cachedRecovery(strategy.timeout);\r\n        \r\n        case 'refresh':\r\n          return await this.refreshRecovery(strategy.timeout);\r\n        \r\n        default:\r\n          throw new Error(`Unknown recovery strategy: ${strategy.name}`);\r\n      }\r\n    } catch (error) {\r\n      const duration = Date.now() - startTime;\r\n      return {\r\n        user: null,\r\n        strategy: strategy.name,\r\n        duration,\r\n        success: false\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * OPTIMIZED: Direct session recovery with aggressive timeout\r\n   */\r\n  private async directRecovery(timeout: number): Promise<RecoveryResult> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const { data: { session }, error } = await Promise.race([\r\n        this.supabase.auth.getSession(),\r\n        this.createTimeoutPromise(timeout, 'Direct session recovery timeout')\r\n      ]);\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      if (!session?.user) {\r\n        return {\r\n          user: null,\r\n          strategy: 'direct',\r\n          duration: Date.now() - startTime,\r\n          success: false\r\n        };\r\n      }\r\n\r\n      // OPTIMIZED: Only fetch essential user data\r\n      const user = await this.getOptimizedUser(session.user.id);\r\n      \r\n      return {\r\n        user,\r\n        strategy: 'direct',\r\n        duration: Date.now() - startTime,\r\n        success: true\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        user: null,\r\n        strategy: 'direct',\r\n        duration: Date.now() - startTime,\r\n        success: false\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * OPTIMIZED: Cached session recovery with fallback validation\r\n   */\r\n  private async cachedRecovery(timeout: number): Promise<RecoveryResult> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Check in-memory cache first\r\n      const cached = this.cache.get('session_recovery');\r\n      if (cached && (Date.now() - cached.timestamp < this.CACHE_DURATION)) {\r\n        // Validate cached session with minimal API call\r\n        const { data: { session } } = await this.supabase.auth.getUser();\r\n        \r\n        if (session?.user) {\r\n          return {\r\n            user: cached.user,\r\n            strategy: 'cached',\r\n            duration: Date.now() - startTime,\r\n            success: true\r\n          };\r\n        }\r\n      }\r\n\r\n      // Check localStorage as fallback\r\n      if (typeof window !== 'undefined') {\r\n        const storageKey = 'sb-' + process.env.NEXT_PUBLIC_SUPABASE_URL?.split('//')[1]?.split('.')[0] + '-auth-token';\r\n        const storedSession = localStorage.getItem(storageKey);\r\n        \r\n        if (storedSession) {\r\n          const sessionData = JSON.parse(storedSession);\r\n          if (sessionData?.access_token) {\r\n            // OPTIMIZED: Quick token validation\r\n            const { data: { user }, error } = await Promise.race([\r\n              this.supabase.auth.getUser(),\r\n              this.createTimeoutPromise(timeout, 'Cached session validation timeout')\r\n            ]);\r\n\r\n            if (!error && user) {\r\n              const authUser = await this.getOptimizedUser(user.id);\r\n              return {\r\n                user: authUser,\r\n                strategy: 'cached',\r\n                duration: Date.now() - startTime,\r\n                success: true\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        user: null,\r\n        strategy: 'cached',\r\n        duration: Date.now() - startTime,\r\n        success: false\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        user: null,\r\n        strategy: 'cached',\r\n        duration: Date.now() - startTime,\r\n        success: false\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * OPTIMIZED: Token refresh with minimal overhead\r\n   */\r\n  private async refreshRecovery(timeout: number): Promise<RecoveryResult> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const { data: { user }, error } = await Promise.race([\r\n        this.supabase.auth.refreshSession(),\r\n        this.createTimeoutPromise(timeout, 'Token refresh timeout')\r\n      ]);\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      if (!user) {\r\n        return {\r\n          user: null,\r\n          strategy: 'refresh',\r\n          duration: Date.now() - startTime,\r\n          success: false\r\n        };\r\n      }\r\n\r\n      const authUser = await this.getOptimizedUser(user.id);\r\n      \r\n      return {\r\n        user: authUser,\r\n        strategy: 'refresh',\r\n        duration: Date.now() - startTime,\r\n        success: true\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        user: null,\r\n        strategy: 'refresh',\r\n        duration: Date.now() - startTime,\r\n        success: false\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * OPTIMIZED: Get minimal user data to reduce payload\r\n   */\r\n  private async getOptimizedUser(userId: string): Promise<AuthUser> {\r\n    // OPTIMIZED: Return minimal user object\r\n    return {\r\n      id: userId,\r\n      email: '', // Will be populated if needed\r\n      created_at: new Date().toISOString()\r\n    } as AuthUser;\r\n  }\r\n\r\n  /**\r\n   * Create timeout promise for race conditions\r\n   */\r\n  private createTimeoutPromise<T>(timeout: number, message: string): Promise<T> {\r\n    return new Promise((_, reject) => {\r\n      setTimeout(() => reject(new Error(message)), timeout);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear cached session data\r\n   */\r\n  clearCache(): void {\r\n    this.cache.clear();\r\n    logger.debug('Authentication cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getCacheStats(): { size: number; oldestEntry: number | null } {\r\n    const entries = Array.from(this.cache.entries());\r\n    const oldestEntry = entries.length > 0 \r\n      ? Math.min(...entries.map(([_, value]) => value.timestamp))\r\n      : null;\r\n\r\n    return {\r\n      size: this.cache.size,\r\n      oldestEntry\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const authOptimizationService = new AuthOptimizationService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\auth.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":19,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/auth.ts\r\n * @description Enhanced authentication service with improved session management and multi-tab sync\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport {\r\n  AuthUser,\r\n  SignUpData,\r\n  SignInData,\r\n  AuthError,\r\n  UserProfile,\r\n  UserSettings\r\n} from '@/lib/types/auth';\r\nimport { AuthError as SupabaseAuthError } from '@supabase/supabase-js';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface RetryConfig {\r\n  maxRetries: number;\r\n  baseDelay: number;\r\n  maxDelay: number;\r\n}\r\n\r\nexport class AuthService {\r\n  private supabase = createClient();\r\n  private sessionCheckInterval: NodeJS.Timeout | null = null;\r\n  private retryConfig: RetryConfig = {\r\n    maxRetries: 3,\r\n    baseDelay: 1000,\r\n    maxDelay: 10000,\r\n  };\r\n  private isSigningIn = false; // Prevent concurrent sign-in operations\r\n  private isSigningOut = false; // Prevent concurrent sign-out operations\r\n\r\n  // Session synchronization across tabs\r\n  private broadcastChannel: BroadcastChannel | null = null;\r\n  private isInitialized = false;\r\n\r\n  constructor() {\r\n    this.initializeBroadcastChannel();\r\n    this.startSessionMonitoring();\r\n    this.initializeMobileSessionRecovery();\r\n  }\r\n\r\n  /**\r\n   * Initialize mobile-specific session recovery mechanisms\r\n   */\r\n  private initializeMobileSessionRecovery(): void {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // Mobile browsers may need session recovery on visibility change\r\n    document.addEventListener('visibilitychange', () => {\r\n      if (!document.hidden) {\r\n        // Page became visible again, check if session needs recovery\r\n        this.checkMobileSessionRecovery();\r\n      }\r\n    });\r\n\r\n    // Mobile browsers may need session recovery on focus\r\n    window.addEventListener('focus', () => {\r\n      this.checkMobileSessionRecovery();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check and recover mobile sessions when needed\r\n   */\r\n  private async checkMobileSessionRecovery(): Promise<void> {\r\n    try {\r\n      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n      if (!isMobile) return;\r\n\r\n      // Only attempt recovery if we don't have a current session\r\n      const { data: { session } } = await this.supabase.auth.getSession();\r\n      if (session) return; // Already have a session\r\n\r\n      // Try to recover from storage\r\n      const projectRef = process.env.NEXT_PUBLIC_SUPABASE_URL?.split('//')[1]?.split('.')[0];\r\n      if (!projectRef) return;\r\n\r\n      const storageKey = `sb-${projectRef}-auth-token`;\r\n\r\n      // Try localStorage first\r\n      try {\r\n        const storedSession = localStorage.getItem(storageKey);\r\n        if (storedSession) {\r\n          const sessionData = JSON.parse(storedSession);\r\n          if (sessionData?.access_token && sessionData?.refresh_token) {\r\n            const { error } = await this.supabase.auth.setSession({\r\n              access_token: sessionData.access_token,\r\n              refresh_token: sessionData.refresh_token\r\n            });\r\n\r\n            if (!error) {\r\n              logger.debug('Mobile session recovered on page focus');\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        logger.warn('Mobile session recovery failed:', error);\r\n      }\r\n    } catch (error) {\r\n      logger.error('Mobile session recovery check failed:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get access to the Supabase client for internal use\r\n   * @returns Supabase client instance\r\n   */\r\n  getSupabaseClient() {\r\n    return this.supabase;\r\n  }\r\n\r\n  /**\r\n   * Initialize broadcast channel for cross-tab communication\r\n   */\r\n  private initializeBroadcastChannel(): void {\r\n    if (typeof window !== 'undefined' && 'BroadcastChannel' in window) {\r\n      this.broadcastChannel = new BroadcastChannel('auth-sync');\r\n      this.broadcastChannel.addEventListener('message', this.handleBroadcastMessage.bind(this));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle broadcast messages from other tabs\r\n   * @param {MessageEvent} event - Broadcast message event\r\n   */\r\n  private handleBroadcastMessage(event: MessageEvent): void {\r\n    const { type, payload } = event.data;\r\n\r\n    switch (type) {\r\n      case 'AUTH_STATE_CHANGED':\r\n        // Sync auth state across tabs without triggering infinite loops\r\n        if (payload.user) {\r\n          this.notifyAuthStateChange(payload.user, false);\r\n        } else {\r\n          this.notifyAuthStateChange(null, false);\r\n        }\r\n        break;\r\n      case 'SESSION_EXPIRED':\r\n        // Handle session expiration across tabs\r\n        this.handleSessionExpiration();\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Broadcast auth state changes to other tabs\r\n   * @param {string} type - Message type\r\n   * @param {any} payload - Message payload\r\n   */\r\n  private broadcastAuthChange(type: string, payload: any): void {\r\n    if (this.broadcastChannel) {\r\n      this.broadcastChannel.postMessage({ type, payload });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start session monitoring for automatic refresh\r\n   */\r\n  private startSessionMonitoring(): void {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // Check session every 5 minutes\r\n    this.sessionCheckInterval = setInterval(async () => {\r\n      try {\r\n        const { data: { session }, error } = await this.supabase.auth.getSession();\r\n\r\n        if (error) {\r\n          logger.error('Session check error:', error);\r\n          return;\r\n        }\r\n\r\n        if (session) {\r\n          // Check if session is about to expire (within 5 minutes)\r\n          const expiresAt = session.expires_at ? session.expires_at * 1000 : 0;\r\n          const now = Date.now();\r\n          const fiveMinutes = 5 * 60 * 1000;\r\n\r\n          if (expiresAt - now < fiveMinutes) {\r\n            await this.refreshSession();\r\n          }\r\n        }\r\n      } catch (error) {\r\n        logger.error('Session monitoring error:', error);\r\n      }\r\n    }, 5 * 60 * 1000); // 5 minutes\r\n  }\r\n\r\n  /**\r\n   * Refresh the current session\r\n   */\r\n  private async refreshSession(): Promise<void> {\r\n    try {\r\n      const { data, error } = await this.supabase.auth.refreshSession();\r\n\r\n      if (error) {\r\n        logger.error('Session refresh error:', error);\r\n        this.handleSessionExpiration();\r\n        return;\r\n      }\r\n\r\n      if (data.session) {\r\n        logger.debug('Session refreshed successfully');\r\n      }\r\n    } catch (error) {\r\n      logger.error('Session refresh failed:', error);\r\n      this.handleSessionExpiration();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle session expiration\r\n   */\r\n  private handleSessionExpiration(): void {\r\n    this.broadcastAuthChange('SESSION_EXPIRED', {});\r\n    // Clear any cached data or redirect to login\r\n    if (typeof window !== 'undefined') {\r\n      window.location.replace('/login?expired=true');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Exponential backoff retry mechanism\r\n   * @param {Function} operation - Operation to retry\r\n   * @param {number} attempt - Current attempt number\r\n   * @returns {Promise<T>} Operation result\r\n   */\r\n  private async retryWithBackoff<T>(\r\n    operation: () => Promise<T>,\r\n    attempt: number = 0\r\n  ): Promise<T> {\r\n    try {\r\n      return await operation();\r\n    } catch (error) {\r\n      if (attempt >= this.retryConfig.maxRetries) {\r\n        throw error;\r\n      }\r\n\r\n      const delay = Math.min(\r\n        this.retryConfig.baseDelay * Math.pow(2, attempt),\r\n        this.retryConfig.maxDelay\r\n      );\r\n\r\n      logger.warn(`Operation failed, retrying in ${delay}ms (attempt ${attempt + 1}/${this.retryConfig.maxRetries})`);\r\n\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n      return this.retryWithBackoff(operation, attempt + 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sign up a new user with email and password\r\n   * @param {SignUpData} data - User signup data\r\n   * @returns {Promise<{user: AuthUser | null, error: AuthError | null}>}\r\n   * @throws {Error} When signup fails\r\n   */\r\n  async signUp(data: SignUpData): Promise<{\r\n    user: AuthUser | null;\r\n    error: AuthError | null;\r\n  }> {\r\n    try {\r\n      const { data: authData, error: authError } = await this.supabase.auth.signUp({\r\n        email: data.email,\r\n        password: data.password,\r\n        options: {\r\n          data: {\r\n            display_name: data.displayName || data.email.split('@')[0],\r\n          },\r\n        },\r\n      });\r\n\r\n      if (authError) {\r\n        return {\r\n          user: null,\r\n          error: this.formatAuthError(authError),\r\n        };\r\n      }\r\n\r\n      if (!authData.user) {\r\n        return {\r\n          user: null,\r\n          error: { message: 'Failed to create user account' },\r\n        };\r\n      }\r\n\r\n      // OPTIMIZED: Fetch profile and settings in parallel\r\n      const [profile, settings] = await Promise.all([\r\n        this.getUserProfile(authData.user.id),\r\n        this.getUserSettings(authData.user.id)\r\n      ]);\r\n\r\n      const user: AuthUser = {\r\n        ...authData.user,\r\n        profile: profile || undefined,\r\n        settings: settings || undefined,\r\n      };\r\n\r\n      return { user, error: null };\r\n    } catch (error) {\r\n      return {\r\n        user: null,\r\n        error: {\r\n          message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sign in an existing user with email and password\r\n   * Includes protection against concurrent sign-in operations\r\n   * @param {SignInData} data - User signin data\r\n   * @returns {Promise<{user: AuthUser | null, error: AuthError | null}>}\r\n   * @throws {Error} When signin fails\r\n   */\r\n  async signIn(data: SignInData): Promise<{\r\n    user: AuthUser | null;\r\n    error: AuthError | null;\r\n  }> {\r\n    // Prevent concurrent sign-in operations\r\n    if (this.isSigningIn) {\r\n      return {\r\n        user: null,\r\n        error: { message: 'Sign in already in progress. Please wait.' },\r\n      };\r\n    }\r\n\r\n    this.isSigningIn = true;\r\n\r\n    try {\r\n      const { data: authData, error: authError } = await this.supabase.auth.signInWithPassword({\r\n        email: data.email,\r\n        password: data.password,\r\n      });\r\n\r\n      if (authError) {\r\n        return {\r\n          user: null,\r\n          error: this.formatAuthError(authError),\r\n        };\r\n      }\r\n\r\n      if (!authData.user) {\r\n        return {\r\n          user: null,\r\n          error: { message: 'Failed to sign in' },\r\n        };\r\n      }\r\n\r\n      // OPTIMIZED: Fetch profile and settings in parallel\r\n      const [profile, settings] = await Promise.all([\r\n        this.getUserProfile(authData.user.id),\r\n        this.getUserSettings(authData.user.id)\r\n      ]);\r\n\r\n      const user: AuthUser = {\r\n        ...authData.user,\r\n        profile: profile || undefined,\r\n        settings: settings || undefined,\r\n      };\r\n\r\n      // Broadcast auth state change to other tabs\r\n      this.broadcastAuthChange('AUTH_STATE_CHANGED', { user });\r\n\r\n      return { user, error: null };\r\n    } catch (error) {\r\n      return {\r\n        user: null,\r\n        error: {\r\n          message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n        },\r\n      };\r\n    } finally {\r\n      this.isSigningIn = false;\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n    * Sign out the current user\r\n    * CRITICAL: Instant logout with immediate session clearing and race condition fixes\r\n    * @returns {Promise<{error: AuthError | null}>}\r\n    */\r\n  async signOut(): Promise<{ error: AuthError | null }> {\r\n    // Prevent concurrent sign-out operations\r\n    if (this.isSigningOut) {\r\n      logger.warn('Sign out already in progress');\r\n      return { error: null };\r\n    }\r\n\r\n    this.isSigningOut = true;\r\n\r\n    try {\r\n      // CRITICAL: Clear session monitoring immediately (synchronous)\r\n      if (this.sessionCheckInterval) {\r\n        clearInterval(this.sessionCheckInterval);\r\n        this.sessionCheckInterval = null;\r\n      }\r\n\r\n      // CRITICAL: Broadcast logout immediately (synchronous)\r\n      this.broadcastAuthChange('LOGOUT', { timestamp: Date.now() });\r\n\r\n      // CRITICAL: Clear Supabase session cookies immediately\r\n      // This prevents StoreInitializer from detecting a session\r\n      try {\r\n        // Clear all Supabase auth cookies with comprehensive cleanup\r\n        if (typeof document !== 'undefined') {\r\n          const cookies = document.cookie.split(';');\r\n          cookies.forEach(cookie => {\r\n            const eqPos = cookie.indexOf('=');\r\n            const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();\r\n            // Clear Supabase auth cookies - expanded pattern matching\r\n            if (name.startsWith('sb-') ||\r\n              name.includes('supabase') ||\r\n              name.includes('auth-token') ||\r\n              name.includes('session')) {\r\n              // Clear with multiple domain variations for cross-domain support\r\n              const domains = [\r\n                window.location.hostname,\r\n                `.${window.location.hostname}`,\r\n                ''\r\n              ];\r\n              domains.forEach(domain => {\r\n                document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;${domain ? `domain=${domain};` : ''}secure;samesite=lax`;\r\n                document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;${domain ? `domain=${domain};` : ''}secure;samesite=strict`;\r\n              });\r\n            }\r\n          });\r\n\r\n          // Clear localStorage and sessionStorage\r\n          try {\r\n            localStorage.removeItem('supabase.auth.token');\r\n            sessionStorage.removeItem('supabase.auth.token');\r\n            // Clear any other auth-related storage\r\n            Object.keys(localStorage).forEach(key => {\r\n              if (key.includes('supabase') || key.includes('auth')) {\r\n                localStorage.removeItem(key);\r\n              }\r\n            });\r\n            Object.keys(sessionStorage).forEach(key => {\r\n              if (key.includes('supabase') || key.includes('auth')) {\r\n                sessionStorage.removeItem(key);\r\n              }\r\n            });\r\n          } catch (storageError) {\r\n            logger.warn('Error clearing storage:', storageError);\r\n          }\r\n        }\r\n      } catch (cookieError) {\r\n        logger.warn('Error clearing cookies:', cookieError);\r\n      }\r\n\r\n      // Sign out from Supabase with timeout protection\r\n      // Use Promise.race to prevent hanging\r\n      const signOutPromise = this.supabase.auth.signOut();\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('SignOut timeout')), 5000)\r\n      );\r\n\r\n      try {\r\n        await Promise.race([signOutPromise, timeoutPromise]);\r\n        logger.debug('Supabase signOut completed successfully');\r\n      } catch (signOutError) {\r\n        logger.warn('Supabase signOut timed out or failed (non-blocking):', signOutError);\r\n        // Continue with logout even if Supabase signOut fails\r\n      }\r\n\r\n      // CRITICAL: Force redirect immediately after cleanup\r\n      // Use replace instead of href to prevent back button issues\r\n      if (typeof window !== 'undefined') {\r\n        window.location.replace('/login');\r\n      }\r\n\r\n      logger.debug('Logout initiated successfully');\r\n      return { error: null };\r\n    } catch (error) {\r\n      logger.error('Error during signOut:', error);\r\n      // Even on error, attempt redirect\r\n      if (typeof window !== 'undefined') {\r\n        window.location.replace('/login?logout=error');\r\n      }\r\n      return { error: null };\r\n    } finally {\r\n      // Reset flag after a short delay to allow redirect\r\n      setTimeout(() => {\r\n        this.isSigningOut = false;\r\n      }, 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the current authenticated user with mobile-specific handling\r\n   * @returns {Promise<AuthUser | null>}\r\n   * @throws {Error} When fetching user fails\r\n   */\r\n  async getCurrentUser(): Promise<AuthUser | null> {\r\n    try {\r\n      // For mobile browsers, try multiple strategies to get the user\r\n      const isMobile = typeof window !== 'undefined' &&\r\n        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n\r\n      let user = null;\r\n      let error = null;\r\n\r\n      if (isMobile) {\r\n        // Mobile strategy: Try getUser first, then fallback to getSession\r\n        const { data: { user: directUser }, error: directError } = await this.supabase.auth.getUser();\r\n\r\n        if (directError || !directUser) {\r\n          // Fallback: Try getSession and extract user\r\n          const { data: { session }, error: sessionError } = await this.supabase.auth.getSession();\r\n          if (!sessionError && session?.user) {\r\n            user = session.user;\r\n            logger.debug('Mobile user fetched via session fallback');\r\n          } else {\r\n            error = directError || sessionError;\r\n          }\r\n        } else {\r\n          user = directUser;\r\n        }\r\n      } else {\r\n        // Standard desktop flow\r\n        const { data: { user: desktopUser }, error: desktopError } = await this.supabase.auth.getUser();\r\n        user = desktopUser;\r\n        error = desktopError;\r\n      }\r\n\r\n      if (error || !user) {\r\n        return null;\r\n      }\r\n\r\n      // OPTIMIZED: Fetch profile and settings in parallel with mobile-specific timeout\r\n      const timeout = isMobile ? 8000 : 5000;\r\n      const profilePromise = this.getUserProfile(user.id);\r\n      const settingsPromise = this.getUserSettings(user.id);\r\n\r\n      const [profile, settings] = await Promise.race([\r\n        Promise.all([profilePromise, settingsPromise]),\r\n        new Promise<never>((_, reject) =>\r\n          setTimeout(() => reject(new Error('Profile/settings fetch timeout')), timeout)\r\n        )\r\n      ]).catch(() => [null, null]);\r\n\r\n      return {\r\n        ...user,\r\n        profile: profile || undefined,\r\n        settings: settings || undefined,\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error fetching current user:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset password for a user\r\n   * @param {string} email - User's email address\r\n   * @returns {Promise<{error: AuthError | null}>}\r\n   * @throws {Error} When password reset fails\r\n   */\r\n  async resetPassword(email: string): Promise<{ error: AuthError | null }> {\r\n    try {\r\n      const { error: authError } = await this.supabase.auth.resetPasswordForEmail(email, {\r\n        redirectTo: `${window.location.origin}/auth/reset-password`,\r\n      });\r\n\r\n      if (authError) {\r\n        return { error: this.formatAuthError(authError) };\r\n      }\r\n\r\n      return { error: null };\r\n    } catch (error) {\r\n      return {\r\n        error: {\r\n          message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update user password\r\n   * @param {string} newPassword - New password\r\n   * @returns {Promise<{error: AuthError | null}>}\r\n   * @throws {Error} When password update fails\r\n   */\r\n  async updatePassword(newPassword: string): Promise<{ error: AuthError | null }> {\r\n    try {\r\n      const { error: authError } = await this.supabase.auth.updateUser({\r\n        password: newPassword,\r\n      });\r\n\r\n      if (authError) {\r\n        return { error: this.formatAuthError(authError) };\r\n      }\r\n\r\n      return { error: null };\r\n    } catch (error) {\r\n      return {\r\n        error: {\r\n          message: error instanceof Error ? error.message : 'An unexpected error occurred',\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to authentication state changes\r\n   * @param {Function} callback - Callback function to handle auth state changes\r\n   * @returns {Function} Unsubscribe function\r\n   */\r\n  onAuthStateChange(callback: (event: string, session: any) => void) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    return this.supabase.auth.onAuthStateChange(async (event: any, session: any) => {\r\n      // Pass event and session directly to callback\r\n      // The auth context will handle user fetching\r\n      callback(event, session);\r\n\r\n      // Also broadcast auth state changes\r\n      if (session?.user) {\r\n        // OPTIMIZED: Fetch profile and settings in parallel\r\n        const [profile, settings] = await Promise.all([\r\n          this.getUserProfile(session.user.id),\r\n          this.getUserSettings(session.user.id)\r\n        ]);\r\n\r\n        const user: AuthUser = {\r\n          ...session.user,\r\n          profile: profile || undefined,\r\n          settings: settings || undefined,\r\n        };\r\n\r\n        this.broadcastAuthChange('AUTH_STATE_CHANGED', { user });\r\n      } else {\r\n        this.broadcastAuthChange('AUTH_STATE_CHANGED', { user: null });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notify auth state change (internal method for broadcast handling)\r\n   * @param {AuthUser | null} user - User data\r\n   * @param {boolean} broadcast - Whether to broadcast to other tabs\r\n   */\r\n  private notifyAuthStateChange(user: AuthUser | null, broadcast: boolean = true): void {\r\n    // This method would be used by the auth context to handle broadcast messages\r\n    // Implementation depends on how the auth context is structured\r\n    if (broadcast) {\r\n      this.broadcastAuthChange('AUTH_STATE_CHANGED', { user });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources when service is destroyed\r\n   */\r\n  destroy(): void {\r\n    if (this.sessionCheckInterval) {\r\n      clearInterval(this.sessionCheckInterval);\r\n      this.sessionCheckInterval = null;\r\n    }\r\n\r\n    if (this.broadcastChannel) {\r\n      this.broadcastChannel.close();\r\n      this.broadcastChannel = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user profile from database\r\n   * @param {string} userId - User ID\r\n   * @returns {Promise<UserProfile | null>}\r\n   * @throws {Error} When fetching profile fails\r\n   */\r\n  private async getUserProfile(userId: string): Promise<UserProfile | null> {\r\n    try {\r\n      const { data, error } = await this.supabase\r\n        .from('user_profiles')\r\n        .select('*')\r\n        .eq('id', userId)\r\n        .single();\r\n\r\n      if (error || !data) {\r\n        return null;\r\n      }\r\n\r\n      return data as UserProfile;\r\n    } catch (error) {\r\n      logger.error('Error fetching user profile:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user settings from database\r\n   * @param {string} userId - User ID\r\n   * @returns {Promise<UserSettings | null>}\r\n   * @throws {Error} When fetching settings fails\r\n   */\r\n  private async getUserSettings(userId: string): Promise<UserSettings | null> {\r\n    try {\r\n      const { data, error } = await this.supabase\r\n        .from('user_settings')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .single();\r\n\r\n      if (error || !data) {\r\n        return null;\r\n      }\r\n\r\n      return data as UserSettings;\r\n    } catch (error) {\r\n      logger.error('Error fetching user settings:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format Supabase auth errors into a consistent format\r\n   * @param {SupabaseAuthError} error - Supabase auth error\r\n   * @returns {AuthError} Formatted error\r\n   */\r\n  private formatAuthError(error: SupabaseAuthError): AuthError {\r\n    const errorMessages: Record<string, string> = {\r\n      'invalid_credentials': 'Invalid email or password',\r\n      'email_not_confirmed': 'Please check your email and click the confirmation link',\r\n      'signup_disabled': 'New registrations are currently disabled',\r\n      'email_address_invalid': 'Please enter a valid email address',\r\n      'password_too_short': 'Password must be at least 6 characters long',\r\n      'user_already_registered': 'An account with this email already exists',\r\n      'weak_password': 'Password is too weak. Please choose a stronger password',\r\n    };\r\n\r\n    return {\r\n      message: errorMessages[error.message] || error.message || 'An authentication error occurred',\r\n      code: error.message,\r\n    };\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const authService = new AuthService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\cache-manager.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":9,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file cache-manager.ts\r\n * @description Smart cache manager with selective invalidation, varied TTLs, and persistence\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface CacheEntry<T> {\r\n  data: T;\r\n  timestamp: number;\r\n  ttl: number;\r\n  tags: string[];\r\n  accessCount: number;\r\n  lastAccessed: number;\r\n}\r\n\r\ninterface CacheConfig {\r\n  maxSize: number;\r\n  defaultTtl: number;\r\n  cleanupInterval: number;\r\n  enablePersistence?: boolean;\r\n  persistenceKey?: string;\r\n  maxStorageSize?: number; // Max size in bytes for localStorage\r\n}\r\n\r\nexport interface CacheOptions {\r\n  ttl?: number;\r\n  tags?: string[];\r\n  priority?: 'low' | 'medium' | 'high';\r\n  persist?: boolean; // Whether to persist this entry\r\n}\r\n\r\n/**\r\n * Smart cache manager with LRU eviction, tag-based invalidation, and persistence\r\n */\r\nexport class CacheManager {\r\n  private cache = new Map<string, CacheEntry<any>>();\r\n  private config: CacheConfig;\r\n  private cleanupTimer?: NodeJS.Timeout;\r\n  private accessOrder = new Map<string, number>();\r\n  private accessCounter = 0;\r\n  private hits = 0; // Track cache hits\r\n  private misses = 0; // Track cache misses\r\n  private persistTimer?: NodeJS.Timeout;\r\n  private lastMemoryCheck = 0;\r\n  private memoryCheckInterval = 60000; // Check memory every minute\r\n\r\n  constructor(config: Partial<CacheConfig> = {}) {\r\n    this.config = {\r\n      maxSize: config.maxSize || 1000,\r\n      defaultTtl: config.defaultTtl || 5 * 60 * 1000, // 5 minutes\r\n      cleanupInterval: config.cleanupInterval || 60 * 1000, // 1 minute\r\n      enablePersistence: config.enablePersistence !== false, // Default to true\r\n      persistenceKey: config.persistenceKey || 'linkvault_cache',\r\n      maxStorageSize: config.maxStorageSize || 5 * 1024 * 1024, // 5MB default\r\n    };\r\n\r\n    // Load persisted cache on initialization\r\n    if (this.config.enablePersistence) {\r\n      this.loadFromStorage();\r\n    }\r\n\r\n    this.startCleanupTimer();\r\n    this.startPersistenceTimer();\r\n  }\r\n\r\n  /**\r\n   * Get cached data\r\n   * @param {string} key - Cache key\r\n   * @returns {T | null} Cached data or null if not found/expired\r\n   */\r\n  get<T>(key: string): T | null {\r\n    const entry = this.cache.get(key);\r\n    \r\n    if (!entry) {\r\n      this.misses++;\r\n      return null;\r\n    }\r\n\r\n    const now = Date.now();\r\n    \r\n    // Check if expired\r\n    if (now - entry.timestamp > entry.ttl) {\r\n      this.cache.delete(key);\r\n      this.accessOrder.delete(key);\r\n      this.misses++;\r\n      return null;\r\n    }\r\n\r\n    // Update access tracking\r\n    entry.accessCount++;\r\n    entry.lastAccessed = now;\r\n    this.accessOrder.set(key, ++this.accessCounter);\r\n    this.hits++;\r\n\r\n    return entry.data;\r\n  }\r\n\r\n  /**\r\n   * Set cached data\r\n   * @param {string} key - Cache key\r\n   * @param {T} data - Data to cache\r\n   * @param {CacheOptions} options - Cache options\r\n   */\r\n  set<T>(key: string, data: T, options: CacheOptions = {}): void {\r\n    const now = Date.now();\r\n    const ttl = options.ttl || this.config.defaultTtl;\r\n    \r\n    // Adjust TTL based on priority\r\n    const adjustedTtl = this.adjustTtlByPriority(ttl, options.priority);\r\n\r\n    const entry: CacheEntry<T> = {\r\n      data,\r\n      timestamp: now,\r\n      ttl: adjustedTtl,\r\n      tags: options.tags || [],\r\n      accessCount: 1,\r\n      lastAccessed: now,\r\n    };\r\n\r\n    // Check if we need to evict entries\r\n    if (this.cache.size >= this.config.maxSize) {\r\n      this.evictLeastRecentlyUsed();\r\n    }\r\n\r\n    this.cache.set(key, entry);\r\n    this.accessOrder.set(key, ++this.accessCounter);\r\n\r\n    // Persist if enabled and option allows\r\n    if (this.config.enablePersistence && options.persist !== false) {\r\n      // Debounce persistence to avoid excessive writes\r\n      this.schedulePersistence();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if key exists and is not expired\r\n   * @param {string} key - Cache key\r\n   * @returns {boolean} Whether key exists and is valid\r\n   */\r\n  has(key: string): boolean {\r\n    return this.get(key) !== null;\r\n  }\r\n\r\n  /**\r\n   * Delete specific key\r\n   * @param {string} key - Cache key to delete\r\n   */\r\n  delete(key: string): void {\r\n    this.cache.delete(key);\r\n    this.accessOrder.delete(key);\r\n    \r\n    // Update persistence if enabled\r\n    if (this.config.enablePersistence) {\r\n      this.schedulePersistence();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate cache entries by tags\r\n   * @param {string[]} tags - Tags to invalidate\r\n   */\r\n  invalidateByTags(tags: string[]): void {\r\n    const keysToDelete: string[] = [];\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.tags.some(tag => tags.includes(tag))) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n\r\n    keysToDelete.forEach(key => this.delete(key));\r\n  }\r\n\r\n  /**\r\n   * Invalidate cache entries by pattern\r\n   * @param {RegExp} pattern - Pattern to match keys\r\n   */\r\n  invalidateByPattern(pattern: RegExp): void {\r\n    const keysToDelete: string[] = [];\r\n\r\n    for (const key of this.cache.keys()) {\r\n      if (pattern.test(key)) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n\r\n    keysToDelete.forEach(key => this.delete(key));\r\n  }\r\n\r\n  /**\r\n   * Clear all cache entries\r\n   */\r\n  clear(): void {\r\n    this.cache.clear();\r\n    this.accessOrder.clear();\r\n    this.accessCounter = 0;\r\n    this.hits = 0;\r\n    this.misses = 0;\r\n    \r\n    // Clear persistence\r\n    if (this.config.enablePersistence && typeof window !== 'undefined') {\r\n      try {\r\n        localStorage.removeItem(this.config.persistenceKey!);\r\n      } catch (error) {\r\n        logger.error('Error clearing persisted cache:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   * @returns {object} Cache statistics\r\n   */\r\n  getStats() {\r\n    const now = Date.now();\r\n    let expiredCount = 0;\r\n    let totalSize = 0;\r\n\r\n    for (const entry of this.cache.values()) {\r\n      if (now - entry.timestamp > entry.ttl) {\r\n        expiredCount++;\r\n      }\r\n      totalSize += JSON.stringify(entry.data).length;\r\n    }\r\n\r\n    return {\r\n      size: this.cache.size,\r\n      maxSize: this.config.maxSize,\r\n      expiredCount,\r\n      totalSize,\r\n      hitRate: this.calculateHitRate(),\r\n      hits: this.hits,\r\n      misses: this.misses,\r\n      totalRequests: this.hits + this.misses,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adjust TTL based on priority\r\n   * @param {number} baseTtl - Base TTL\r\n   * @param {string} priority - Priority level\r\n   * @returns {number} Adjusted TTL\r\n   */\r\n  private adjustTtlByPriority(baseTtl: number, priority?: 'low' | 'medium' | 'high'): number {\r\n    switch (priority) {\r\n      case 'high':\r\n        return baseTtl * 2; // Double TTL for high priority\r\n      case 'low':\r\n        return baseTtl * 0.5; // Half TTL for low priority\r\n      case 'medium':\r\n      default:\r\n        return baseTtl;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evict least recently used entries\r\n   */\r\n  private evictLeastRecentlyUsed(): void {\r\n    // Find the least recently used key\r\n    let lruKey: string | null = null;\r\n    let lruOrder = Infinity;\r\n\r\n    for (const [key, order] of this.accessOrder.entries()) {\r\n      if (order < lruOrder) {\r\n        lruOrder = order;\r\n        lruKey = key;\r\n      }\r\n    }\r\n\r\n    if (lruKey) {\r\n      this.delete(lruKey);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate cache hit rate (based on actual hits and misses)\r\n   * @returns {number} Hit rate percentage\r\n   */\r\n  private calculateHitRate(): number {\r\n    const totalRequests = this.hits + this.misses;\r\n    if (totalRequests === 0) return 0;\r\n    return Math.round((this.hits / totalRequests) * 100);\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired entries\r\n   */\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    const keysToDelete: string[] = [];\r\n    let cleanedCount = 0;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (now - entry.timestamp > entry.ttl) {\r\n        keysToDelete.push(key);\r\n        cleanedCount++;\r\n      }\r\n    }\r\n\r\n    keysToDelete.forEach(key => this.delete(key));\r\n\r\n    // Adaptive cleanup interval based on memory pressure\r\n    if (cleanedCount > 0) {\r\n      this.optimizeCleanupInterval();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start cleanup timer with adaptive interval\r\n   */\r\n  private startCleanupTimer(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n    }\r\n    \r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanup();\r\n    }, this.config.cleanupInterval);\r\n  }\r\n\r\n  /**\r\n   * Optimize cleanup interval based on memory pressure\r\n   */\r\n  private optimizeCleanupInterval(): void {\r\n    const now = Date.now();\r\n    if (now - this.lastMemoryCheck < this.memoryCheckInterval) {\r\n      return;\r\n    }\r\n    this.lastMemoryCheck = now;\r\n\r\n    if (typeof window === 'undefined' || !('performance' in window) || !('memory' in (performance as any))) {\r\n      return;\r\n    }\r\n\r\n    const memory = (performance as any).memory;\r\n    const usedMB = memory.usedJSHeapSize / 1048576;\r\n    const limitMB = memory.jsHeapSizeLimit / 1048576;\r\n    const memoryPressure = usedMB / limitMB;\r\n\r\n    // Adjust cleanup interval based on memory pressure\r\n    if (memoryPressure > 0.8) {\r\n      // High memory pressure - cleanup more frequently\r\n      this.config.cleanupInterval = 15 * 1000; // 15 seconds\r\n    } else if (memoryPressure > 0.6) {\r\n      // Medium memory pressure\r\n      this.config.cleanupInterval = 30 * 1000; // 30 seconds\r\n    } else {\r\n      // Low memory pressure - cleanup less frequently\r\n      this.config.cleanupInterval = 60 * 1000; // 1 minute\r\n    }\r\n\r\n    this.startCleanupTimer();\r\n  }\r\n\r\n  /**\r\n   * Load cache from localStorage\r\n   */\r\n  private loadFromStorage(): void {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    try {\r\n      const stored = localStorage.getItem(this.config.persistenceKey!);\r\n      if (!stored) return;\r\n\r\n      const parsed = JSON.parse(stored);\r\n      const now = Date.now();\r\n      let loadedCount = 0;\r\n\r\n      for (const [key, entry] of Object.entries(parsed)) {\r\n        const cacheEntry = entry as CacheEntry<any>;\r\n        \r\n        // Only load non-expired entries\r\n        if (now - cacheEntry.timestamp < cacheEntry.ttl) {\r\n          this.cache.set(key, cacheEntry);\r\n          this.accessOrder.set(key, cacheEntry.lastAccessed);\r\n          loadedCount++;\r\n        }\r\n      }\r\n\r\n      if (loadedCount > 0) {\r\n        logger.debug(`Loaded ${loadedCount} cache entries from storage`);\r\n      }\r\n    } catch (error) {\r\n      logger.error('Error loading cache from storage:', error);\r\n      // Clear corrupted cache\r\n      if (typeof window !== 'undefined') {\r\n        localStorage.removeItem(this.config.persistenceKey!);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save cache to localStorage (debounced)\r\n   */\r\n  private persistTimerId?: NodeJS.Timeout;\r\n  \r\n  private schedulePersistence(): void {\r\n    if (this.persistTimerId) {\r\n      clearTimeout(this.persistTimerId);\r\n    }\r\n\r\n    // Debounce persistence to avoid excessive writes\r\n    this.persistTimerId = setTimeout(() => {\r\n      this.persistToStorage();\r\n    }, 1000); // Wait 1 second after last change\r\n  }\r\n\r\n  /**\r\n   * Persist cache to localStorage\r\n   */\r\n  private persistToStorage(): void {\r\n    if (typeof window === 'undefined' || !this.config.enablePersistence) return;\r\n\r\n    try {\r\n      const now = Date.now();\r\n      const persistableEntries: Record<string, CacheEntry<any>> = {};\r\n      let totalSize = 0;\r\n      const maxSize = this.config.maxStorageSize || 5 * 1024 * 1024; // 5MB default\r\n\r\n      // Only persist non-expired entries\r\n      for (const [key, entry] of this.cache.entries()) {\r\n        if (now - entry.timestamp < entry.ttl) {\r\n          const entrySize = JSON.stringify(entry).length;\r\n          if (totalSize + entrySize > maxSize) {\r\n            break; // Don't exceed storage limit\r\n          }\r\n          persistableEntries[key] = entry;\r\n          totalSize += entrySize;\r\n        }\r\n      }\r\n\r\n      const serialized = JSON.stringify(persistableEntries);\r\n      localStorage.setItem(this.config.persistenceKey!, serialized);\r\n    } catch (error) {\r\n      // Handle quota exceeded or other storage errors\r\n      if ((error as any).name === 'QuotaExceededError') {\r\n        logger.warn('Cache storage quota exceeded, clearing old entries');\r\n        // Clear oldest entries and retry\r\n        this.evictOldestEntries(0.3); // Evict 30% oldest entries\r\n        this.persistToStorage();\r\n      } else {\r\n        logger.error('Error persisting cache to storage:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start persistence timer (periodic saves)\r\n   */\r\n  private startPersistenceTimer(): void {\r\n    if (this.persistTimer) {\r\n      clearInterval(this.persistTimer);\r\n    }\r\n\r\n    // Persist every 30 seconds\r\n    this.persistTimer = setInterval(() => {\r\n      this.persistToStorage();\r\n    }, 30 * 1000);\r\n  }\r\n\r\n  /**\r\n   * Evict oldest entries by percentage\r\n   */\r\n  private evictOldestEntries(percentage: number): void {\r\n    const entriesToEvict = Math.floor(this.cache.size * percentage);\r\n    const sortedEntries = Array.from(this.accessOrder.entries())\r\n      .sort((a, b) => a[1] - b[1])\r\n      .slice(0, entriesToEvict);\r\n\r\n    sortedEntries.forEach(([key]) => {\r\n      this.delete(key);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop cleanup timer and clear cache\r\n   */\r\n  destroy(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n    }\r\n    if (this.persistTimer) {\r\n      clearInterval(this.persistTimer);\r\n    }\r\n    if (this.persistTimerId) {\r\n      clearTimeout(this.persistTimerId);\r\n    }\r\n    \r\n    // Final persistence before destruction\r\n    if (this.config.enablePersistence) {\r\n      this.persistToStorage();\r\n    }\r\n    \r\n    this.clear();\r\n  }\r\n}\r\n\r\n// Predefined cache configurations for different data types\r\nexport const CACHE_CONFIGS = {\r\n  USER_PROFILE: { ttl: 15 * 60 * 1000, tags: ['user'], priority: 'high' as const },\r\n  USER_SETTINGS: { ttl: 30 * 60 * 1000, tags: ['user', 'settings'], priority: 'high' as const },\r\n  LINKS: { ttl: 5 * 60 * 1000, tags: ['links'], priority: 'medium' as const },\r\n  FOLDERS: { ttl: 10 * 60 * 1000, tags: ['folders'], priority: 'medium' as const },\r\n  METADATA: { ttl: 60 * 60 * 1000, tags: ['metadata'], priority: 'low' as const },\r\n  SEARCH_RESULTS: { ttl: 2 * 60 * 1000, tags: ['search'], priority: 'low' as const },\r\n} as const;\r\n\r\n// Global cache instance with persistence enabled\r\nexport const globalCache = new CacheManager({\r\n  maxSize: 2000,\r\n  defaultTtl: 5 * 60 * 1000,\r\n  cleanupInterval: 60 * 1000, // Start with 1 minute, adapts based on memory pressure\r\n  enablePersistence: true,\r\n  persistenceKey: 'linkvault_cache',\r\n  maxStorageSize: 5 * 1024 * 1024, // 5MB max storage\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\data-loader.optimized.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":13,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/data-loader.optimized.ts\r\n * @description OPTIMIZED: Enhanced data loading service with aggressive caching for scalability\r\n * @created 2025-01-XX\r\n */\r\n\r\nimport { Link, Folder, AppSettings } from '@/types';\r\nimport { supabaseDatabaseService } from './supabase-database.service';\r\nimport { performanceMonitor } from './performance-monitor.service';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport { DEFAULT_SETTINGS } from '@/constants';\r\n\r\ninterface DataLoadResult {\r\n  links: Link[];\r\n  folders: Folder[];\r\n  settings: AppSettings;\r\n  loadingTime: number;\r\n  cacheHits: number;\r\n  totalRequests: number;\r\n  metadata?: {\r\n    loadingTime: number;\r\n    cacheHits: number;\r\n    totalItems: number;\r\n  };\r\n}\r\n\r\ninterface LoadingOptions {\r\n  priority?: 'high' | 'low';\r\n  timeout?: number;\r\n  retries?: number;\r\n  skipCache?: boolean;\r\n  onProgress?: (progress: number) => void;\r\n}\r\n\r\n/**\r\n * OPTIMIZED: Scalable data loading service with aggressive caching\r\n * This version is designed to handle large datasets efficiently\r\n */\r\nclass OptimizedDataLoaderService {\r\n  private loadingPromise: Promise<DataLoadResult> | null = null;\r\n  private abortController: AbortController | null = null;\r\n  private static instance: OptimizedDataLoaderService | null = null;\r\n\r\n  // OPTIMIZED: Singleton pattern for better resource management\r\n  static getInstance(): OptimizedDataLoaderService {\r\n    if (!OptimizedDataLoaderService.instance) {\r\n      OptimizedDataLoaderService.instance = new OptimizedDataLoaderService();\r\n    }\r\n    return OptimizedDataLoaderService.instance;\r\n  }\r\n\r\n  /**\r\n   * OPTIMIZED: Load user data with pagination for scalability\r\n   * @param {LoadingOptions} options - Loading configuration options\r\n   * @returns {Promise<DataLoadResult>} Complete data load result\r\n   */\r\n  async loadUserData(options: LoadingOptions = {}): Promise<DataLoadResult> {\r\n    const {\r\n      priority = 'high',\r\n      timeout = 5000,\r\n      retries = 1,\r\n      skipCache = false,\r\n      onProgress\r\n    } = options;\r\n\r\n    const startTime = Date.now();\r\n    \r\n    // Track loading start\r\n    performanceMonitor.trackInteraction({\r\n      type: 'navigation',\r\n      element: 'optimized_data_loader',\r\n      timestamp: Date.now(),\r\n      metadata: { \r\n        action: 'load_start',\r\n        options: { priority, timeout, retries, skipCache }\r\n      }\r\n    });\r\n\r\n    // Return existing promise if already loading\r\n    if (this.loadingPromise && !skipCache) {\r\n      logger.debug('Data loading already in progress, waiting...');\r\n      return this.loadingPromise;\r\n    }\r\n\r\n    // Cancel previous loading if exists\r\n    if (this.abortController) {\r\n      this.abortController.abort();\r\n    }\r\n\r\n    this.abortController = new AbortController();\r\n\r\n    this.loadingPromise = this.executeOptimizedLoad(\r\n      timeout,\r\n      retries,\r\n      onProgress\r\n    ).finally(() => {\r\n      this.loadingPromise = null;\r\n      this.abortController = null;\r\n    });\r\n\r\n    return this.loadingPromise;\r\n  }\r\n\r\n  /**\r\n   * OPTIMIZED: Execute parallel loading with pagination\r\n   * @private\r\n   */\r\n  private async executeOptimizedLoad(\r\n    timeout: number,\r\n    retries: number,\r\n    onProgress?: (progress: number) => void\r\n  ): Promise<DataLoadResult> {\r\n    const startTime = performance.now();\r\n    \r\n    const updateProgress = (progress: number) => {\r\n      onProgress?.(progress);\r\n    };\r\n\r\n    updateProgress(10);\r\n\r\n    try {\r\n      // OPTIMIZED: Load data in parallel with limits for better performance\r\n      // Use pagination to prevent loading too much data at once\r\n      const [links, folders, settings] = await Promise.all([\r\n        this.loadWithTimeout(\r\n          () => supabaseDatabaseService.getLinks({ limit: 100, offset: 0 }), // Load first 100 links\r\n          timeout,\r\n          'links'\r\n        ).catch((error) => {\r\n          logger.error('Failed to load links:', error);\r\n          return [] as Link[];\r\n        }),\r\n        this.loadWithTimeout(\r\n          () => supabaseDatabaseService.getFolders({ limit: 50 }), // Load first 50 folders\r\n          timeout,\r\n          'folders'\r\n        ).catch((error) => {\r\n          logger.error('Failed to load folders:', error);\r\n          return [] as Folder[];\r\n        }),\r\n        this.loadWithTimeout(\r\n          () => supabaseDatabaseService.getSettings(),\r\n          timeout,\r\n          'settings'\r\n        ).catch((error) => {\r\n          logger.error('Failed to load settings:', error);\r\n          return DEFAULT_SETTINGS;\r\n        })\r\n      ]);\r\n\r\n      updateProgress(100);\r\n\r\n      const loadingTime = performance.now() - startTime;\r\n\r\n      // Track performance\r\n      performanceMonitor.trackMetric('optimized_data_load_time', loadingTime, {\r\n        linksCount: links.length.toString(),\r\n        foldersCount: folders.length.toString(),\r\n        type: 'performance'\r\n      });\r\n\r\n      return {\r\n        links,\r\n        folders,\r\n        settings: settings || DEFAULT_SETTINGS,\r\n        loadingTime,\r\n        cacheHits: 0,\r\n        totalRequests: 3,\r\n        metadata: {\r\n          loadingTime,\r\n          cacheHits: 0,\r\n          totalItems: links.length + folders.length\r\n        }\r\n      };\r\n    } catch (error) {\r\n      logger.error('Optimized data loading failed:', error);\r\n      \r\n      // Return empty data set to prevent app crash\r\n      return {\r\n        links: [],\r\n        folders: [],\r\n        settings: DEFAULT_SETTINGS,\r\n        loadingTime: performance.now() - startTime,\r\n        cacheHits: 0,\r\n        totalRequests: 3,\r\n        metadata: {\r\n          loadingTime: performance.now() - startTime,\r\n          cacheHits: 0,\r\n          totalItems: 0\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load data with timeout\r\n   * @private\r\n   */\r\n  private async loadWithTimeout<T>(\r\n    fn: () => Promise<T>,\r\n    timeout: number,\r\n    name: string\r\n  ): Promise<T> {\r\n    return Promise.race([\r\n      fn(),\r\n      new Promise<never>((_, reject) => \r\n        setTimeout(() => reject(new Error(`${name} loading timeout`)), timeout)\r\n      )\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Prefetch additional data in background\r\n   * This loads more data after initial load without blocking UI\r\n   */\r\n  async prefetchAdditionalData(currentLinksCount: number): Promise<void> {\r\n    if (currentLinksCount >= 100) {\r\n      // Load more links in background\r\n      try {\r\n        const additionalLinks = await supabaseDatabaseService.getLinks({\r\n          limit: 100,\r\n          offset: 100\r\n        });\r\n        \r\n        if (additionalLinks.length > 0) {\r\n          // Update store with additional links\r\n          const { useLinksStore } = await import('@/store/useLinksStore');\r\n          const currentLinks = useLinksStore.getState().links;\r\n          useLinksStore.getState().setLinks([...currentLinks, ...additionalLinks]);\r\n        }\r\n      } catch (error) {\r\n        logger.warn('Background prefetch failed:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel ongoing load\r\n   */\r\n  cancelLoad(): void {\r\n    if (this.abortController) {\r\n      this.abortController.abort();\r\n      this.abortController = null;\r\n    }\r\n    this.loadingPromise = null;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const optimizedDataLoaderService = OptimizedDataLoaderService.getInstance();\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\data-loader.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token {","line":10,"column":13,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/data-loader.service.ts\r\n * @description Optimized data loading service with parallel fetching and intelligent caching\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { supabaseDatabaseService } from './supabase-database.service';\r\nimport { performanceMonitor } from './performance-monitor.service';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport type { Link, Folder, AppSettings } from '@/types';\r\nimport { DEFAULT_SETTINGS } from '@/constants';\r\n\r\ninterface LoadingState {\r\n  isLoading: boolean;\r\n  error: Error | null;\r\n  progress: number;\r\n  startTime?: number;\r\n}\r\n\r\ninterface DataLoadResult {\r\n  links: Link[];\r\n  folders: Folder[];\r\n  settings: AppSettings;\r\n  loadingTime: number;\r\n  cacheHits: number;\r\n  totalRequests: number;\r\n  metadata?: any;\r\n}\r\n\r\ninterface LoadingOptions {\r\n  priority?: 'high' | 'medium' | 'low';\r\n  timeout?: number;\r\n  retries?: number;\r\n  skipCache?: boolean;\r\n  onProgress?: (progress: number) => void;\r\n}\r\n\r\n/**\r\n * Optimized data loading service with parallel fetching and intelligent strategies\r\n */\r\nclass DataLoaderService {\r\n  private loadingPromise: Promise<DataLoadResult> | null = null;\r\n  private loadingState: LoadingState = {\r\n    isLoading: false,\r\n    error: null,\r\n    progress: 0,\r\n    startTime: undefined\r\n  };\r\n  private loadingStates: Map<string, LoadingState> = new Map();\r\n  private abortController: AbortController | null = null;\r\n\r\n  /**\r\n   * Load user data with optimized parallel fetching and performance monitoring\r\n   * @param {LoadingOptions} options - Loading configuration options\r\n   * @returns {Promise<DataLoadResult>} Complete data load result\r\n   * @throws {Error} When loading fails after all retries\r\n   */\r\n  async loadUserData(options: LoadingOptions = {}): Promise<DataLoadResult> {\r\n    const {\r\n      priority = 'high',\r\n      timeout = 5000, // REDUCED: Faster timeout for better UX\r\n      retries = 1, // REDUCED: Fewer retries for faster failure\r\n      skipCache = false,\r\n      onProgress\r\n    } = options;\r\n\r\n    const startTime = Date.now();\r\n\r\n    // Track loading start\r\n    performanceMonitor.trackInteraction({\r\n      type: 'navigation',\r\n      element: 'data_loader',\r\n      timestamp: Date.now(),\r\n      metadata: {\r\n        action: 'load_start',\r\n        options: { priority, timeout, retries, skipCache }\r\n      }\r\n    });\r\n\r\n    // Return existing promise if already loading\r\n    if (this.loadingPromise && !skipCache) {\r\n      logger.debug('Data loading already in progress, waiting...');\r\n      performanceMonitor.trackMetric('data_loading_cache_hit', Date.now() - startTime, {\r\n        type: 'cache_performance'\r\n      });\r\n      return this.loadingPromise;\r\n    }\r\n\r\n    // Cancel previous loading if exists\r\n    if (this.abortController) {\r\n      this.abortController.abort();\r\n    }\r\n\r\n    this.abortController = new AbortController();\r\n\r\n    // OPTIMIZED: Load minimal data first for faster initial display\r\n    this.loadingPromise = this.executeOptimizedLoad(\r\n      timeout,\r\n      retries,\r\n      onProgress,\r\n      this.abortController.signal\r\n    );\r\n\r\n    try {\r\n      const result = await this.loadingPromise;\r\n      const duration = Date.now() - startTime;\r\n\r\n      // Track successful loading\r\n      performanceMonitor.trackMetric('data_loading_success', duration, {\r\n        type: 'loading_performance'\r\n      });\r\n\r\n      performanceMonitor.trackInteraction({\r\n        type: 'navigation',\r\n        element: 'data_loader',\r\n        duration,\r\n        timestamp: Date.now(),\r\n        metadata: {\r\n          action: 'load_success',\r\n          dataSize: (result.links?.length || 0) + (result.folders?.length || 0)\r\n        }\r\n      });\r\n\r\n      this.loadingState = { isLoading: false, error: null, progress: 100, startTime: undefined };\r\n      logger.debug(`Data loading completed in ${duration}ms`);\r\n      return result;\r\n    } catch (error) {\r\n      const duration = Date.now() - startTime;\r\n\r\n      // Track loading error\r\n      performanceMonitor.trackError({\r\n        message: `Data loading failed: ${(error as Error).message}`,\r\n        severity: 'high',\r\n        context: {\r\n          duration,\r\n          timeout,\r\n          retries,\r\n          errorType: (error as Error).constructor.name\r\n        }\r\n      });\r\n\r\n      this.loadingState = {\r\n        isLoading: false,\r\n        error: error as Error,\r\n        progress: 0,\r\n        startTime: undefined\r\n      };\r\n      logger.error(`Data loading failed after ${duration}ms:`, error);\r\n      throw error;\r\n    } finally {\r\n      this.loadingPromise = null;\r\n      this.abortController = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute optimized data loading with progressive enhancement\r\n   * @private\r\n   */\r\n  private async executeOptimizedLoad(\r\n    timeout: number,\r\n    retries: number,\r\n    onProgress?: (progress: number) => void,\r\n    signal?: AbortSignal\r\n  ): Promise<DataLoadResult> {\r\n    this.loadingState = { isLoading: true, error: null, progress: 0, startTime: Date.now() };\r\n    \r\n    let attempt = 0;\r\n    let lastError: Error | null = null;\r\n\r\n    while (attempt <= retries) {\r\n      try {\r\n        // OPTIMIZED: Try fast initial load first\r\n        return await this.loadFastInitialData(timeout, onProgress, signal);\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        attempt++;\r\n        \r\n        if (attempt <= retries && !signal?.aborted) {\r\n          // SHORTER: Faster retry delay\r\n          const delay = Math.min(500 * Math.pow(2, attempt - 1), 2000);\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n      }\r\n    }\r\n\r\n    // If fast loading fails, try full load as fallback\r\n    try {\r\n      logger.warn('Fast initial load failed, trying full load as fallback');\r\n      return await this.performLoad(timeout, onProgress, signal);\r\n    } catch (fallbackError) {\r\n      logger.error('Both fast and full load failed:', fallbackError);\r\n      throw lastError || new Error('Failed to load data after all attempts');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load minimal data first for instant user feedback\r\n   * @private\r\n   */\r\n  private async loadFastInitialData(\r\n    timeout: number,\r\n    onProgress?: (progress: number) => void,\r\n    signal?: AbortSignal\r\n  ): Promise<DataLoadResult> {\r\n    const startTime = Date.now();\r\n    let cacheHits = 0;\r\n    let totalRequests = 0;\r\n\r\n    // Create timeout promise\r\n    const timeoutPromise = new Promise<never>((_, reject) => {\r\n      const timeoutId = setTimeout(() => {\r\n        reject(new Error(`Fast data loading timeout after ${timeout}ms`));\r\n      }, timeout);\r\n      \r\n      signal?.addEventListener('abort', () => {\r\n        clearTimeout(timeoutId);\r\n        reject(new Error('Fast data loading aborted'));\r\n      });\r\n    });\r\n\r\n    // Progress tracking\r\n    const updateProgress = (step: number) => {\r\n      const progress = Math.min((step / 3) * 100, 100);\r\n      this.loadingState.progress = progress;\r\n      onProgress?.(progress);\r\n    };\r\n\r\n    try {\r\n      // OPTIMIZED: Load only essential data first\r\n      const dataPromises = this.createFastDataPromises(updateProgress, signal);\r\n      \r\n      const results = await Promise.race([\r\n        Promise.all(dataPromises),\r\n        timeoutPromise\r\n      ]);\r\n\r\n      const [links, folders, settings] = results;\r\n      totalRequests = 3;\r\n\r\n      cacheHits = this.estimateCacheHits(links, folders, settings);\r\n\r\n      const loadingTime = Date.now() - startTime;\r\n\r\n      return {\r\n        links: links || [],\r\n        folders: folders || [],\r\n        settings: settings || DEFAULT_SETTINGS,\r\n        loadingTime,\r\n        cacheHits,\r\n        totalRequests\r\n      };\r\n    } catch (error) {\r\n      if (signal?.aborted) {\r\n        throw new Error('Fast data loading was cancelled');\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create fast data loading promises\r\n   * @private\r\n   */\r\n  private createFastDataPromises(\r\n    updateProgress: (step: number) => void,\r\n    signal?: AbortSignal\r\n  ): Promise<any>[] {\r\n    // OPTIMIZED: Load smaller datasets first for faster initial display\r\n    const settingsPromise = this.loadWithProgress(\r\n      () => supabaseDatabaseService.getSettings(),\r\n      'settings',\r\n      1,\r\n      updateProgress,\r\n      signal\r\n    );\r\n\r\n    const foldersPromise = this.loadWithProgress(\r\n      () => supabaseDatabaseService.getFolders({ limit: 50 }), // LIMIT: Load only first 50 folders\r\n      'folders',\r\n      2,\r\n      updateProgress,\r\n      signal\r\n    );\r\n\r\n    const linksPromise = this.loadWithProgress(\r\n      () => supabaseDatabaseService.getLinks({ limit: 100, offset: 0 }), // LIMIT: Load only first 100 links\r\n      'links',\r\n      3,\r\n      updateProgress,\r\n      signal\r\n    );\r\n\r\n    return [linksPromise, foldersPromise, settingsPromise];\r\n  }\r\n\r\n  /**\r\n   * Perform the actual parallel data loading\r\n   * @private\r\n   */\r\n  private async performLoad(\r\n    timeout: number,\r\n    onProgress?: (progress: number) => void,\r\n    signal?: AbortSignal\r\n  ): Promise<DataLoadResult> {\r\n    const startTime = Date.now();\r\n    let cacheHits = 0;\r\n    let totalRequests = 0;\r\n\r\n    // Create timeout promise\r\n    const timeoutPromise = new Promise<never>((_, reject) => {\r\n      const timeoutId = setTimeout(() => {\r\n        reject(new Error(`Data loading timeout after ${timeout}ms`));\r\n      }, timeout);\r\n\r\n      // Clear timeout if signal is aborted\r\n      signal?.addEventListener('abort', () => {\r\n        clearTimeout(timeoutId);\r\n        reject(new Error('Data loading aborted'));\r\n      });\r\n    });\r\n\r\n    // Progress tracking\r\n    const updateProgress = (step: number) => {\r\n      const progress = Math.min((step / 3) * 100, 100);\r\n      this.loadingState.progress = progress;\r\n      onProgress?.(progress);\r\n    };\r\n\r\n    try {\r\n      // Load data in parallel with intelligent prioritization\r\n      const dataPromises = this.createOptimizedDataPromises(updateProgress, signal);\r\n      \r\n      // Race against timeout\r\n      const results = await Promise.race([\r\n        Promise.all(dataPromises),\r\n        timeoutPromise\r\n      ]);\r\n\r\n      const [links, folders, settings] = results;\r\n      totalRequests = 3;\r\n\r\n      // Calculate cache hits (simplified - would need actual cache hit tracking)\r\n      cacheHits = this.estimateCacheHits(links, folders, settings);\r\n\r\n      const loadingTime = Date.now() - startTime;\r\n\r\n      return {\r\n        links: links || [],\r\n        folders: folders || [],\r\n        settings: settings || DEFAULT_SETTINGS,\r\n        loadingTime,\r\n        cacheHits,\r\n        totalRequests\r\n      };\r\n    } catch (error) {\r\n      if (signal?.aborted) {\r\n        throw new Error('Data loading was cancelled');\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create optimized data loading promises with intelligent prioritization\r\n   * @private\r\n   */\r\n  private createOptimizedDataPromises(\r\n    updateProgress: (step: number) => void,\r\n    signal?: AbortSignal\r\n  ): Promise<any>[] {\r\n    // Priority order: settings (fastest), folders (medium), links (potentially largest)\r\n    const settingsPromise = this.loadWithProgress(\r\n      () => supabaseDatabaseService.getSettings(),\r\n      'settings',\r\n      1,\r\n      updateProgress,\r\n      signal\r\n    );\r\n\r\n    const foldersPromise = this.loadWithProgress(\r\n      () => supabaseDatabaseService.getFolders(),\r\n      'folders',\r\n      2,\r\n      updateProgress,\r\n      signal\r\n    );\r\n\r\n    const linksPromise = this.loadWithProgress(\r\n      () => supabaseDatabaseService.getLinks(),\r\n      'links',\r\n      3,\r\n      updateProgress,\r\n      signal\r\n    );\r\n\r\n    return [linksPromise, foldersPromise, settingsPromise];\r\n  }\r\n\r\n  /**\r\n   * Load data with progress tracking and cancellation support\r\n   * @private\r\n   */\r\n  private async loadWithProgress<T>(\r\n    loadFn: () => Promise<T>,\r\n    dataType: string,\r\n    step: number,\r\n    updateProgress: (step: number) => void,\r\n    signal?: AbortSignal\r\n  ): Promise<T> {\r\n    if (signal?.aborted) {\r\n      throw new Error(`Loading ${dataType} was cancelled`);\r\n    }\r\n\r\n    try {\r\n      const result = await loadFn();\r\n      updateProgress(step);\r\n      return result;\r\n    } catch (error) {\r\n      logger.error(`Error loading ${dataType}:`, error);\r\n      \r\n      // Return fallback data instead of failing completely\r\n      if (dataType === 'settings') {\r\n        return DEFAULT_SETTINGS as T;\r\n      }\r\n      return [] as T;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Estimate cache hits based on data freshness (simplified implementation)\r\n   * @private\r\n   */\r\n  private estimateCacheHits(links: Link[], folders: Folder[], settings: AppSettings): number {\r\n    // This is a simplified estimation - in a real implementation,\r\n    // you'd track actual cache hits from the cache manager\r\n    let hits = 0;\r\n    \r\n    // Assume settings are often cached\r\n    if (settings && Object.keys(settings).length > 0) hits++;\r\n    \r\n    // Assume folders are cached if they exist\r\n    if (folders && folders.length > 0) hits++;\r\n    \r\n    // Links are less likely to be fully cached due to size\r\n    if (links && links.length > 0 && links.length < 50) hits++;\r\n    \r\n    return hits;\r\n  }\r\n\r\n  /**\r\n   * Load data with batch processing for large datasets\r\n   * @param {number} batchSize - Number of items to process per batch\r\n   * @returns {Promise<DataLoadResult>} Batched load result\r\n   */\r\n  async loadUserDataBatched(batchSize: number = 100): Promise<DataLoadResult> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      // Load metadata first (folders and settings)\r\n      const [folders, settings] = await Promise.all([\r\n        supabaseDatabaseService.getFolders(),\r\n        supabaseDatabaseService.getSettings()\r\n      ]);\r\n\r\n      // Load links in batches if there are many\r\n      const links = await this.loadLinksBatched(batchSize);\r\n\r\n      const loadingTime = Date.now() - startTime;\r\n\r\n      return {\r\n        links: links || [],\r\n        folders: folders || [],\r\n        settings: settings || DEFAULT_SETTINGS,\r\n        loadingTime,\r\n        cacheHits: 0, // Would need actual tracking\r\n        totalRequests: Math.ceil((links?.length || 0) / batchSize) + 2\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error in batched data loading:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load links in batches for better performance with large datasets\r\n   * @private\r\n   */\r\n  private async loadLinksBatched(batchSize: number): Promise<Link[]> {\r\n    // For now, use the regular method since Supabase handles pagination internally\r\n    // In a future enhancement, this could implement actual batching\r\n    return supabaseDatabaseService.getLinks();\r\n  }\r\n\r\n  /**\r\n   * Preload critical data in the background\r\n   * @param {string[]} dataTypes - Types of data to preload\r\n   */\r\n  async preloadData(dataTypes: string[] = ['folders', 'settings']): Promise<void> {\r\n    const preloadPromises = dataTypes.map(async (type) => {\r\n      try {\r\n        switch (type) {\r\n          case 'folders':\r\n            await supabaseDatabaseService.getFolders();\r\n            break;\r\n          case 'settings':\r\n            await supabaseDatabaseService.getSettings();\r\n            break;\r\n          case 'links':\r\n            // Only preload a subset of links to avoid performance impact\r\n            await supabaseDatabaseService.getLinks();\r\n            break;\r\n        }\r\n      } catch (error) {\r\n        logger.warn(`Failed to preload ${type}:`, error);\r\n      }\r\n    });\r\n\r\n    await Promise.allSettled(preloadPromises);\r\n  }\r\n\r\n  /**\r\n   * Get current loading state\r\n   * @returns {LoadingState} Current loading state\r\n   */\r\n  getLoadingState(): LoadingState {\r\n    return { ...this.loadingState };\r\n  }\r\n\r\n  /**\r\n   * Cancel current loading operation\r\n   */\r\n  cancelLoading(): void {\r\n    if (this.abortController) {\r\n      this.abortController.abort();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear any cached loading promises\r\n   */\r\n  clearCache(): void {\r\n    this.loadingPromise = null;\r\n    this.loadingState = {\r\n      isLoading: false,\r\n      error: null,\r\n      progress: 0,\r\n      startTime: undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate data size for performance tracking\r\n   * @private\r\n   */\r\n  private calculateDataSize(result: DataLoadResult): number {\r\n    const linksSize = result.links?.length || 0;\r\n    const foldersSize = result.folders?.length || 0;\r\n    const settingsSize = Object.keys(result.settings || {}).length;\r\n    \r\n    return linksSize + foldersSize + settingsSize;\r\n  }\r\n\r\n  /**\r\n   * Generate unique loading ID for tracking\r\n   * @private\r\n   */\r\n  private generateLoadingId(): string {\r\n    return `load_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Update loading state for a specific loading operation\r\n   * @private\r\n   */\r\n  private updateLoadingState(loadingId: string, updates: Partial<LoadingState>): void {\r\n    const currentState = this.loadingStates.get(loadingId);\r\n    if (currentState) {\r\n      this.loadingStates.set(loadingId, { ...currentState, ...updates });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached data if available\r\n   * @private\r\n   */\r\n  private getCachedData(): DataLoadResult | null {\r\n    // This is a simplified cache check - in a real implementation,\r\n    // you'd check actual cache storage with TTL\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Cache successful data result\r\n   * @private\r\n   */\r\n  private cacheData(result: DataLoadResult): void {\r\n    // This is a placeholder for actual cache implementation\r\n    // In a real implementation, you'd store in localStorage, IndexedDB, etc.\r\n    logger.debug('Caching data result:', {\r\n      links: result.links?.length,\r\n      folders: result.folders?.length,\r\n      settings: !!result.settings\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute parallel loading with progress tracking\r\n   * @private\r\n   */\r\n  private async executeParallelLoading(\r\n    loadingId: string,\r\n    onProgress?: (progress: number) => void\r\n  ): Promise<DataLoadResult> {\r\n    const updateProgress = (progress: number) => {\r\n      this.updateLoadingState(loadingId, { progress });\r\n      onProgress?.(progress);\r\n    };\r\n\r\n    updateProgress(10);\r\n\r\n    // Load all data in parallel\r\n    const [links, folders, settings] = await Promise.all([\r\n      this.loadWithProgressTracking('links', () => supabaseDatabaseService.getLinks(), updateProgress, 30),\r\n      this.loadWithProgressTracking('folders', () => supabaseDatabaseService.getFolders(), updateProgress, 60),\r\n      this.loadWithProgressTracking('settings', () => supabaseDatabaseService.getSettings(), updateProgress, 90)\r\n    ]);\r\n\r\n    updateProgress(100);\r\n\r\n    const loadingTime = performance.now() - (this.loadingStates.get(loadingId)?.startTime || 0);\r\n\r\n    return {\r\n      links: links as Link[],\r\n      folders: folders as Folder[],\r\n      settings: (settings as AppSettings) || DEFAULT_SETTINGS,\r\n      loadingTime,\r\n      cacheHits: 0, // Would be calculated from actual cache\r\n      totalRequests: 3, // links, folders, settings\r\n      metadata: {\r\n        loadingTime,\r\n        cacheHits: 0, // Would be calculated from actual cache\r\n        totalItems: (links as Link[]).length + (folders as Folder[]).length\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Load data with progress tracking and error handling\r\n   * @private\r\n   */\r\n  private async loadWithProgressTracking<T>(\r\n    dataType: string,\r\n    loadFn: () => Promise<T>,\r\n    updateProgress: (progress: number) => void,\r\n    targetProgress: number\r\n  ): Promise<T> {\r\n    try {\r\n      const result = await loadFn();\r\n      updateProgress(targetProgress);\r\n      return result;\r\n    } catch (error) {\r\n      performanceMonitor.trackError({\r\n        message: `Failed to load ${dataType}: ${(error as Error).message}`,\r\n        severity: 'medium',\r\n        context: { dataType, targetProgress }\r\n      });\r\n      \r\n      // Return fallback data\r\n      if (dataType === 'settings') {\r\n        return DEFAULT_SETTINGS as T;\r\n      }\r\n      return [] as T;\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const dataLoaderService = new DataLoaderService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\database-debug.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":10,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/database-debug.service.ts\r\n * @description Enhanced database debugging service for query performance analysis\r\n * @created 2025-11-15\r\n */\r\n\r\nimport { debugLogger } from './debug-logger.service';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface QueryDebugSession {\r\n  sessionId: string;\r\n  startTime: number;\r\n  endTime?: number;\r\n  queries: QueryDebugInfo[];\r\n  cacheHits: number;\r\n  cacheMisses: number;\r\n  timeouts: number;\r\n  errors: number;\r\n  totalQueryTime: number;\r\n  averageQueryTime: number;\r\n}\r\n\r\ninterface QueryDebugInfo {\r\n  queryId: string;\r\n  operation: string;\r\n  startTime: number;\r\n  endTime?: number;\r\n  duration?: number;\r\n  success: boolean;\r\n  cacheHit: boolean;\r\n  cacheAge?: number;\r\n  dataSize?: number;\r\n  queryType?: string;\r\n  error?: string;\r\n  retryCount: number;\r\n  memoryUsage?: {\r\n    before: number;\r\n    after: number;\r\n  };\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nclass DatabaseDebugService {\r\n  private currentSession: QueryDebugSession | null = null;\r\n  private isEnabled: boolean;\r\n\r\n  constructor() {\r\n    this.isEnabled = process.env.NODE_ENV === 'development' || process.env.DEBUG_MODE === 'true';\r\n  }\r\n\r\n  /**\r\n   * Start a new database debugging session\r\n   */\r\n  startQuerySession(): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    this.currentSession = {\r\n      sessionId: debugLogger.debugInfo().sessionId,\r\n      startTime: Date.now(),\r\n      queries: [],\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      timeouts: 0,\r\n      errors: 0,\r\n      totalQueryTime: 0,\r\n      averageQueryTime: 0\r\n    };\r\n\r\n    debugLogger.database({\r\n      operation: 'db_session_start',\r\n      success: true,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId\r\n      }\r\n    });\r\n\r\n    logger.debug('Database debugging session started', { \r\n      sessionId: this.currentSession.sessionId \r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log a database query\r\n   */\r\n  logQuery(metric: {\r\n    operation: string;\r\n    queryType?: string;\r\n    cacheHit: boolean;\r\n    cacheAge?: number;\r\n    dataSize?: number;\r\n    retryCount?: number;\r\n    metadata?: Record<string, any>;\r\n  }): string {\r\n    if (!this.isEnabled || !this.currentSession) {\r\n      return '';\r\n    }\r\n\r\n    const queryId = this.generateQueryId();\r\n    const startTime = Date.now();\r\n\r\n    const queryInfo: QueryDebugInfo = {\r\n      queryId,\r\n      operation: metric.operation,\r\n      startTime,\r\n      success: false, // Will be updated when query completes\r\n      cacheHit: metric.cacheHit,\r\n      cacheAge: metric.cacheAge,\r\n      dataSize: metric.dataSize,\r\n      queryType: metric.queryType,\r\n      retryCount: metric.retryCount || 0,\r\n      metadata: metric.metadata\r\n    };\r\n\r\n    this.currentSession.queries.push(queryInfo);\r\n\r\n    // Update cache statistics\r\n    if (metric.cacheHit) {\r\n      this.currentSession.cacheHits++;\r\n    } else {\r\n      this.currentSession.cacheMisses++;\r\n    }\r\n\r\n    debugLogger.database({\r\n      operation: `query_${metric.operation}`,\r\n      success: false,\r\n      duration: 0,\r\n      cacheHit: metric.cacheHit,\r\n      dataSize: metric.dataSize,\r\n      queryType: metric.queryType,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        queryId,\r\n        cacheAge: metric.cacheAge,\r\n        retryCount: metric.retryCount || 0,\r\n        ...metric.metadata\r\n      }\r\n    });\r\n\r\n    logger.debug(`Database query started: ${metric.operation}`, {\r\n      queryId,\r\n      cacheHit: metric.cacheHit,\r\n      queryType: metric.queryType,\r\n      dataSize: metric.dataSize,\r\n      sessionId: this.currentSession.sessionId\r\n    });\r\n\r\n    return queryId;\r\n  }\r\n\r\n  /**\r\n   * Mark a query as completed\r\n   */\r\n  markQueryComplete(queryId: string, success: boolean, error?: string): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    const query = this.currentSession.queries.find(q => q.queryId === queryId);\r\n    if (!query) return;\r\n\r\n    const endTime = Date.now();\r\n    const duration = endTime - query.startTime;\r\n\r\n    query.endTime = endTime;\r\n    query.duration = duration;\r\n    query.success = success;\r\n    query.error = error;\r\n\r\n    // Update session statistics\r\n    this.currentSession.totalQueryTime += duration;\r\n    this.currentSession.averageQueryTime = this.currentSession.totalQueryTime / this.currentSession.queries.length;\r\n\r\n    if (!success) {\r\n      this.currentSession.errors++;\r\n      if (error && error.includes('timeout')) {\r\n        this.currentSession.timeouts++;\r\n      }\r\n    }\r\n\r\n    // Get memory usage if available\r\n    let memoryUsage = null;\r\n    if (typeof window !== 'undefined' && 'performance' in window && 'memory' in (performance as any)) {\r\n      const memory = (performance as any).memory;\r\n      memoryUsage = {\r\n        usedJSHeapSize: memory.usedJSHeapSize,\r\n        totalJSHeapSize: memory.totalJSHeapSize\r\n      };\r\n      query.memoryUsage = {\r\n        before: query.memoryUsage?.before || memoryUsage.usedJSHeapSize,\r\n        after: memoryUsage.usedJSHeapSize\r\n      };\r\n    }\r\n\r\n    debugLogger.database({\r\n      operation: `query_${query.operation}_complete`,\r\n      success,\r\n      duration,\r\n      cacheHit: query.cacheHit,\r\n      dataSize: query.dataSize,\r\n      queryType: query.queryType,\r\n      error,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        queryId,\r\n        retryCount: query.retryCount,\r\n        memoryUsage,\r\n        queryIndex: this.currentSession.queries.findIndex(q => q.queryId === queryId)\r\n      }\r\n    });\r\n\r\n    logger.debug(`Database query completed: ${query.operation}`, {\r\n      queryId,\r\n      success,\r\n      duration,\r\n      cacheHit: query.cacheHit,\r\n      dataSize: query.dataSize,\r\n      error,\r\n      sessionId: this.currentSession.sessionId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log cache operations\r\n   */\r\n  logCacheOperation(operation: string, key: string, hit: boolean, metadata?: Record<string, any>): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    debugLogger.database({\r\n      operation: `cache_${operation}`,\r\n      success: true,\r\n      cacheHit: hit,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        cacheKey: key,\r\n        ...metadata\r\n      }\r\n    });\r\n\r\n    logger.debug(`Cache operation: ${operation}`, {\r\n      key,\r\n      hit,\r\n      sessionId: this.currentSession.sessionId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log data loading operations\r\n   */\r\n  logDataLoading(metric: {\r\n    operation: string;\r\n    totalLinks: number;\r\n    totalFolders: number;\r\n    totalSettings: number;\r\n    loadingStrategy: string;\r\n    parallelOperations: number;\r\n    metadata?: Record<string, any>;\r\n  }): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    const totalItems = metric.totalLinks + metric.totalFolders + metric.totalSettings;\r\n\r\n    debugLogger.database({\r\n      operation: `data_loading_${metric.operation}`,\r\n      success: true,\r\n      duration: 0, // Will be calculated by the caller\r\n      dataSize: totalItems,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        breakdown: {\r\n          links: metric.totalLinks,\r\n          folders: metric.totalFolders,\r\n          settings: metric.totalSettings\r\n        },\r\n        loadingStrategy: metric.loadingStrategy,\r\n        parallelOperations: metric.parallelOperations,\r\n        ...metric.metadata\r\n      }\r\n    });\r\n\r\n    logger.debug(`Data loading: ${metric.operation}`, {\r\n      totalItems,\r\n      breakdown: {\r\n        links: metric.totalLinks,\r\n        folders: metric.totalFolders,\r\n        settings: metric.totalSettings\r\n      },\r\n      loadingStrategy: metric.loadingStrategy,\r\n      sessionId: this.currentSession.sessionId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log pagination performance\r\n   */\r\n  logPagination(metric: {\r\n    operation: string;\r\n    limit: number;\r\n    offset: number;\r\n    actualReturned: number;\r\n    hasMore: boolean;\r\n    duration: number;\r\n    metadata?: Record<string, any>;\r\n  }): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    const efficiency = metric.actualReturned / metric.limit;\r\n\r\n    debugLogger.database({\r\n      operation: `pagination_${metric.operation}`,\r\n      success: true,\r\n      duration: metric.duration,\r\n      dataSize: metric.actualReturned,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        pagination: {\r\n          limit: metric.limit,\r\n          offset: metric.offset,\r\n          returned: metric.actualReturned,\r\n          hasMore: metric.hasMore,\r\n          efficiency\r\n        },\r\n        ...metric.metadata\r\n      }\r\n    });\r\n\r\n    logger.debug(`Pagination: ${metric.operation}`, {\r\n      efficiency: `${(efficiency * 100).toFixed(1)}%`,\r\n      limit: metric.limit,\r\n      returned: metric.actualReturned,\r\n      hasMore: metric.hasMore,\r\n      sessionId: this.currentSession.sessionId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * End the current database debugging session\r\n   */\r\n  endQuerySession(): void {\r\n    if (!this.isEnabled || !this.currentSession) return;\r\n\r\n    this.currentSession.endTime = Date.now();\r\n    const sessionDuration = this.currentSession.endTime - this.currentSession.startTime;\r\n\r\n    debugLogger.database({\r\n      operation: 'db_session_end',\r\n      success: this.currentSession.errors === 0,\r\n      duration: sessionDuration,\r\n      metadata: {\r\n        sessionId: this.currentSession.sessionId,\r\n        summary: {\r\n          totalQueries: this.currentSession.queries.length,\r\n          cacheHits: this.currentSession.cacheHits,\r\n          cacheMisses: this.currentSession.cacheMisses,\r\n          timeouts: this.currentSession.timeouts,\r\n          errors: this.currentSession.errors,\r\n          totalQueryTime: this.currentSession.totalQueryTime,\r\n          averageQueryTime: this.currentSession.averageQueryTime,\r\n          cacheHitRate: this.currentSession.cacheMisses + this.currentSession.cacheHits > 0 \r\n            ? (this.currentSession.cacheHits / (this.currentSession.cacheMisses + this.currentSession.cacheHits)) * 100 \r\n            : 0\r\n        }\r\n      }\r\n    });\r\n\r\n    logger.info('Database debugging session ended', {\r\n      sessionDuration,\r\n      summary: {\r\n        totalQueries: this.currentSession.queries.length,\r\n        cacheHitRate: this.currentSession.cacheMisses + this.currentSession.cacheHits > 0 \r\n          ? (this.currentSession.cacheHits / (this.currentSession.cacheMisses + this.currentSession.cacheHits)) * 100 \r\n          : 0,\r\n        timeouts: this.currentSession.timeouts,\r\n        errors: this.currentSession.errors,\r\n        averageQueryTime: this.currentSession.averageQueryTime\r\n      },\r\n      sessionId: this.currentSession.sessionId\r\n    });\r\n\r\n    // Store session data for analysis\r\n    this.storeSessionData();\r\n    this.currentSession = null;\r\n  }\r\n\r\n  /**\r\n   * Get database performance summary\r\n   */\r\n  getDatabasePerformanceSummary(): {\r\n    totalSessions: number;\r\n    averageQueryTime: number;\r\n    averageSessionTime: number;\r\n    cacheHitRate: number;\r\n    errorRate: number;\r\n    timeoutRate: number;\r\n    operationPerformance: Record<string, {\r\n      count: number;\r\n      averageTime: number;\r\n      successRate: number;\r\n      cacheHitRate: number;\r\n    }>;\r\n    queryTypePerformance: Record<string, {\r\n      count: number;\r\n      averageTime: number;\r\n      successRate: number;\r\n    }>;\r\n  } {\r\n    if (process.env.NODE_ENV !== 'development' || typeof localStorage === 'undefined') {\r\n      return {\r\n        totalSessions: 0,\r\n        averageQueryTime: 0,\r\n        averageSessionTime: 0,\r\n        cacheHitRate: 0,\r\n        errorRate: 0,\r\n        timeoutRate: 0,\r\n        operationPerformance: {},\r\n        queryTypePerformance: {}\r\n      };\r\n    }\r\n\r\n    try {\r\n      const storedData = JSON.parse(localStorage.getItem('database_debug_sessions') || '[]');\r\n      \r\n      if (storedData.length === 0) {\r\n        return {\r\n          totalSessions: 0,\r\n          averageQueryTime: 0,\r\n          averageSessionTime: 0,\r\n          cacheHitRate: 0,\r\n          errorRate: 0,\r\n          timeoutRate: 0,\r\n          operationPerformance: {},\r\n          queryTypePerformance: {}\r\n        };\r\n      }\r\n\r\n      const totalQueries = storedData.reduce((sum: number, session: QueryDebugSession) => \r\n        sum + session.queries.length, 0);\r\n      const totalQueryTime = storedData.reduce((sum: number, session: QueryDebugSession) => \r\n        sum + session.totalQueryTime, 0);\r\n      const totalSessionTime = storedData.reduce((sum: number, session: QueryDebugSession) => \r\n        sum + (session.endTime || session.startTime) - session.startTime, 0);\r\n\r\n      const totalCacheHits = storedData.reduce((sum: number, session: QueryDebugSession) => \r\n        sum + session.cacheHits, 0);\r\n      const totalCacheMisses = storedData.reduce((sum: number, session: QueryDebugSession) => \r\n        sum + session.cacheMisses, 0);\r\n      const totalErrors = storedData.reduce((sum: number, session: QueryDebugSession) => \r\n        sum + session.errors, 0);\r\n      const totalTimeouts = storedData.reduce((sum: number, session: QueryDebugSession) => \r\n        sum + session.timeouts, 0);\r\n\r\n      const cacheHitRate = totalCacheHits + totalCacheMisses > 0 \r\n        ? (totalCacheHits / (totalCacheHits + totalCacheMisses)) * 100 \r\n        : 0;\r\n      const errorRate = totalQueries > 0 ? (totalErrors / totalQueries) * 100 : 0;\r\n      const timeoutRate = totalQueries > 0 ? (totalTimeouts / totalQueries) * 100 : 0;\r\n\r\n      // Operation performance analysis\r\n      const operationPerformance: Record<string, any> = {};\r\n      storedData.forEach((session: QueryDebugSession) => {\r\n        session.queries.forEach(query => {\r\n          if (!operationPerformance[query.operation]) {\r\n            operationPerformance[query.operation] = {\r\n              count: 0,\r\n              totalTime: 0,\r\n              successes: 0,\r\n              cacheHits: 0\r\n            };\r\n          }\r\n          operationPerformance[query.operation].count++;\r\n          if (query.duration) {\r\n            operationPerformance[query.operation].totalTime += query.duration;\r\n          }\r\n          if (query.success) {\r\n            operationPerformance[query.operation].successes++;\r\n          }\r\n          if (query.cacheHit) {\r\n            operationPerformance[query.operation].cacheHits++;\r\n          }\r\n        });\r\n      });\r\n\r\n      // Calculate operation averages\r\n      Object.keys(operationPerformance).forEach(operation => {\r\n        const data = operationPerformance[operation];\r\n        data.averageTime = data.count > 0 ? data.totalTime / data.count : 0;\r\n        data.successRate = data.count > 0 ? (data.successes / data.count) * 100 : 0;\r\n        data.cacheHitRate = data.count > 0 ? (data.cacheHits / data.count) * 100 : 0;\r\n        delete data.totalTime;\r\n        delete data.successes;\r\n        delete data.cacheHits;\r\n      });\r\n\r\n      // Query type performance analysis\r\n      const queryTypePerformance: Record<string, any> = {};\r\n      storedData.forEach((session: QueryDebugSession) => {\r\n        session.queries.forEach(query => {\r\n          const queryType = query.queryType || 'unknown';\r\n          if (!queryTypePerformance[queryType]) {\r\n            queryTypePerformance[queryType] = {\r\n              count: 0,\r\n              totalTime: 0,\r\n              successes: 0\r\n            };\r\n          }\r\n          queryTypePerformance[queryType].count++;\r\n          if (query.duration) {\r\n            queryTypePerformance[queryType].totalTime += query.duration;\r\n          }\r\n          if (query.success) {\r\n            queryTypePerformance[queryType].successes++;\r\n          }\r\n        });\r\n      });\r\n\r\n      // Calculate query type averages\r\n      Object.keys(queryTypePerformance).forEach(queryType => {\r\n        const data = queryTypePerformance[queryType];\r\n        data.averageTime = data.count > 0 ? data.totalTime / data.count : 0;\r\n        data.successRate = data.count > 0 ? (data.successes / data.count) * 100 : 0;\r\n        delete data.totalTime;\r\n        delete data.successes;\r\n      });\r\n\r\n      return {\r\n        totalSessions: storedData.length,\r\n        averageQueryTime: totalQueries > 0 ? totalQueryTime / totalQueries : 0,\r\n        averageSessionTime: storedData.length > 0 ? totalSessionTime / storedData.length : 0,\r\n        cacheHitRate,\r\n        errorRate,\r\n        timeoutRate,\r\n        operationPerformance,\r\n        queryTypePerformance\r\n      };\r\n    } catch (error) {\r\n      logger.error('Failed to analyze database performance data:', error);\r\n      return {\r\n        totalSessions: 0,\r\n        averageQueryTime: 0,\r\n        averageSessionTime: 0,\r\n        cacheHitRate: 0,\r\n        errorRate: 0,\r\n        timeoutRate: 0,\r\n        operationPerformance: {},\r\n        queryTypePerformance: {}\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate unique query ID\r\n   */\r\n  private generateQueryId(): string {\r\n    return `query_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Store session data for analysis\r\n   */\r\n  private storeSessionData(): void {\r\n    if (!this.currentSession) return;\r\n\r\n    // Store in localStorage for persistence (development only)\r\n    if (process.env.NODE_ENV === 'development' && typeof localStorage !== 'undefined') {\r\n      try {\r\n        const storedData = JSON.parse(localStorage.getItem('database_debug_sessions') || '[]');\r\n        storedData.push(this.currentSession);\r\n        \r\n        // Keep only last 20 sessions\r\n        if (storedData.length > 20) {\r\n          storedData.splice(0, storedData.length - 20);\r\n        }\r\n        \r\n        localStorage.setItem('database_debug_sessions', JSON.stringify(storedData));\r\n      } catch (error) {\r\n        logger.error('Failed to store database debug session data:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear stored debug data\r\n   */\r\n  clearDebugData(): void {\r\n    if (process.env.NODE_ENV === 'development' && typeof localStorage !== 'undefined') {\r\n      try {\r\n        localStorage.removeItem('database_debug_sessions');\r\n        logger.info('Database debug data cleared');\r\n      } catch (error) {\r\n        logger.error('Failed to clear database debug data:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Export debug data\r\n   */\r\n  exportDebugData(): string {\r\n    if (process.env.NODE_ENV === 'development' && typeof localStorage !== 'undefined') {\r\n      try {\r\n        const storedData = localStorage.getItem('database_debug_sessions');\r\n        return storedData || '[]';\r\n      } catch (error) {\r\n        logger.error('Failed to export database debug data:', error);\r\n        return '[]';\r\n      }\r\n    }\r\n    return '[]';\r\n  }\r\n\r\n  /**\r\n   * Enable/disable debugging\r\n   */\r\n  setEnabled(enabled: boolean): void {\r\n    this.isEnabled = enabled;\r\n    if (enabled) {\r\n      logger.info('Database debugging enabled');\r\n    } else {\r\n      logger.info('Database debugging disabled');\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const databaseDebugService = new DatabaseDebugService();\r\n\r\n// Export convenience functions\r\nexport const databaseDebug = {\r\n  startSession: () => databaseDebugService.startQuerySession(),\r\n  logQuery: (metric: Parameters<DatabaseDebugService['logQuery']>[0]) => \r\n    databaseDebugService.logQuery(metric),\r\n  markComplete: (queryId: string, success: boolean, error?: string) => \r\n    databaseDebugService.markQueryComplete(queryId, success, error),\r\n  logCache: (operation: string, key: string, hit: boolean, metadata?: Record<string, any>) => \r\n    databaseDebugService.logCacheOperation(operation, key, hit, metadata),\r\n  logDataLoading: (metric: Parameters<DatabaseDebugService['logDataLoading']>[0]) => \r\n    databaseDebugService.logDataLoading(metric),\r\n  logPagination: (metric: Parameters<DatabaseDebugService['logPagination']>[0]) => \r\n    databaseDebugService.logPagination(metric),\r\n  endSession: () => databaseDebugService.endQuerySession(),\r\n  getSummary: () => databaseDebugService.getDatabasePerformanceSummary(),\r\n  clearData: () => databaseDebugService.clearDebugData(),\r\n  exportData: () => databaseDebugService.exportDebugData(),\r\n  enable: () => databaseDebugService.setEnabled(true),\r\n  disable: () => databaseDebugService.setEnabled(false)\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\database\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\debug-logger.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":7,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/debug-logger.service.ts\r\n * @description Comprehensive debug logging service for performance monitoring and issue diagnosis\r\n * @created 2025-11-15\r\n */\r\n\r\ninterface DebugMetric {\r\n  id: string;\r\n  category: 'auth' | 'database' | 'memory' | 'performance' | 'api' | 'ui';\r\n  operation: string;\r\n  duration?: number; // in milliseconds\r\n  success: boolean;\r\n  error?: string;\r\n  metadata?: Record<string, any>;\r\n  timestamp: number;\r\n  userAgent?: string;\r\n  sessionId: string;\r\n}\r\n\r\ninterface MetricSummary {\r\n  category: string;\r\n  operation: string;\r\n  totalOperations: number;\r\n  successRate: number;\r\n  averageDuration: number;\r\n  minDuration: number;\r\n  maxDuration: number;\r\n  totalErrors: number;\r\n}\r\n\r\ninterface PerformanceSnapshot {\r\n  timestamp: number;\r\n  memoryUsage: {\r\n    usedJSHeapSize: number;\r\n    totalJSHeapSize: number;\r\n    jsHeapSizeLimit: number;\r\n  } | null;\r\n  activeConnections: number;\r\n  cacheStats: {\r\n    hitRate: number;\r\n    totalRequests: number;\r\n    cachedItems: number;\r\n  } | null;\r\n}\r\n\r\nclass DebugLoggerService {\r\n  private metrics: DebugMetric[] = [];\r\n  private isEnabled: boolean;\r\n  private maxStoredMetrics: number = 5000; // Limit to prevent memory bloat\r\n  private sessionId: string;\r\n  private activeOperations: Map<string, DebugMetric> = new Map();\r\n  private reportingInterval: NodeJS.Timeout | null = null;\r\n  private connectionCounter: number = 0;\r\n  private performanceSnapshotInterval: NodeJS.Timeout | null = null;\r\n\r\n  constructor() {\r\n    this.isEnabled = process.env.NODE_ENV === 'development' || process.env.DEBUG_MODE === 'true';\r\n    this.sessionId = this.generateSessionId();\r\n    \r\n    if (this.isEnabled) {\r\n      this.startPeriodicReporting();\r\n      this.startPerformanceSnapshot();\r\n      this.setupGlobalErrorHandlers();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate unique session ID for tracking\r\n   */\r\n  private generateSessionId(): string {\r\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Log a debug metric\r\n   */\r\n  logMetric(metric: Omit<DebugMetric, 'id' | 'userAgent' | 'sessionId'>): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    const fullMetric: DebugMetric = {\r\n      id: this.generateId(),\r\n      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,\r\n      sessionId: this.sessionId,\r\n      ...metric\r\n    };\r\n\r\n    // Store the metric\r\n    this.metrics.push(fullMetric);\r\n    this.trimStoredMetrics();\r\n\r\n    // Log to console in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      this.logToConsole(fullMetric);\r\n    }\r\n\r\n    // Track active operations\r\n    if (!metric.success && !metric.duration) {\r\n      this.activeOperations.set(metric.operation, fullMetric);\r\n    } else {\r\n      this.activeOperations.delete(metric.operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start timing an operation\r\n   */\r\n  startOperation(category: DebugMetric['category'], operation: string, metadata?: Record<string, any>): string {\r\n    const operationId = this.generateId();\r\n    const startTime = Date.now();\r\n    \r\n    this.logMetric({\r\n      category,\r\n      operation,\r\n      success: false,\r\n      timestamp: startTime,\r\n      metadata: {\r\n        ...metadata,\r\n        operationId,\r\n        startTime\r\n      }\r\n    });\r\n\r\n    return operationId;\r\n  }\r\n\r\n  /**\r\n   * End timing an operation\r\n   */\r\n  endOperation(operationId: string, success: boolean, metadata?: Record<string, any>): void {\r\n    const activeOp = this.activeOperations.get(operationId);\r\n    if (!activeOp) return;\r\n\r\n    const endTime = Date.now();\r\n    const duration = endTime - (activeOp.metadata?.startTime || endTime);\r\n    \r\n    this.logMetric({\r\n      category: activeOp.category,\r\n      operation: activeOp.operation,\r\n      duration,\r\n      success,\r\n      timestamp: endTime,\r\n      metadata: {\r\n        ...activeOp.metadata,\r\n        ...metadata,\r\n        operationId,\r\n        duration\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log authentication-specific metrics\r\n   */\r\n  logAuth(metric: {\r\n    operation: string;\r\n    success: boolean;\r\n    duration?: number;\r\n    strategy?: string;\r\n    retryCount?: number;\r\n    error?: string;\r\n    metadata?: Record<string, any>;\r\n  }): void {\r\n    this.logMetric({\r\n      category: 'auth',\r\n      operation: metric.operation,\r\n      duration: metric.duration,\r\n      success: metric.success,\r\n      error: metric.error,\r\n      timestamp: Date.now(),\r\n      metadata: {\r\n        ...metric.metadata,\r\n        strategy: metric.strategy,\r\n        retryCount: metric.retryCount\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log database-specific metrics\r\n   */\r\n  logDatabase(metric: {\r\n    operation: string;\r\n    success: boolean;\r\n    duration?: number;\r\n    cacheHit?: boolean;\r\n    dataSize?: number;\r\n    queryType?: string;\r\n    error?: string;\r\n    metadata?: Record<string, any>;\r\n  }): void {\r\n    this.logMetric({\r\n      category: 'database',\r\n      operation: metric.operation,\r\n      duration: metric.duration,\r\n      success: metric.success,\r\n      error: metric.error,\r\n      timestamp: Date.now(),\r\n      metadata: {\r\n        ...metric.metadata,\r\n        cacheHit: metric.cacheHit,\r\n        dataSize: metric.dataSize,\r\n        queryType: metric.queryType\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log memory-specific metrics\r\n   */\r\n  logMemory(metric: {\r\n    operation: string;\r\n    success: boolean;\r\n    connectionType?: string;\r\n    memoryUsage?: any;\r\n    activeConnections?: number;\r\n    metadata?: Record<string, any>;\r\n  }): void {\r\n    this.logMetric({\r\n      category: 'memory',\r\n      operation: metric.operation,\r\n      success: metric.success,\r\n      timestamp: Date.now(),\r\n      metadata: {\r\n        ...metric.metadata,\r\n        connectionType: metric.connectionType,\r\n        memoryUsage: metric.memoryUsage,\r\n        activeConnections: metric.activeConnections\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log API-specific metrics\r\n   */\r\n  logApi(metric: {\r\n    operation: string;\r\n    endpoint: string;\r\n    success: boolean;\r\n    duration?: number;\r\n    statusCode?: number;\r\n    error?: string;\r\n    metadata?: Record<string, any>;\r\n  }): void {\r\n    this.logMetric({\r\n      category: 'api',\r\n      operation: metric.operation,\r\n      duration: metric.duration,\r\n      success: metric.success,\r\n      error: metric.error,\r\n      timestamp: Date.now(),\r\n      metadata: {\r\n        ...metric.metadata,\r\n        endpoint: metric.endpoint,\r\n        statusCode: metric.statusCode\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log UI-specific metrics\r\n   */\r\n  logUI(metric: {\r\n    operation: string;\r\n    success: boolean;\r\n    duration?: number;\r\n    component?: string;\r\n    renderCount?: number;\r\n    metadata?: Record<string, any>;\r\n  }): void {\r\n    this.logMetric({\r\n      category: 'ui',\r\n      operation: metric.operation,\r\n      duration: metric.duration,\r\n      success: metric.success,\r\n      timestamp: Date.now(),\r\n      metadata: {\r\n        ...metric.metadata,\r\n        component: metric.component,\r\n        renderCount: metric.renderCount\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Log to console with formatting\r\n   */\r\n  private logToConsole(metric: DebugMetric): void {\r\n    const timestamp = new Date(metric.timestamp).toISOString();\r\n    const duration = metric.duration ? `${metric.duration}ms` : 'pending';\r\n    const status = metric.success ? 'Γ£à' : duration === 'pending' ? 'ΓÅ│' : 'Γ¥î';\r\n    \r\n    const message = `[${timestamp}] ${status} ${metric.category.toUpperCase()}:${metric.operation} ${duration}`;\r\n    \r\n    if (metric.success) {\r\n      console.log(message, metric.metadata);\r\n    } else if (duration === 'pending') {\r\n      // Handle pending operations as info/warning, not errors\r\n      const pendingMessage = metric.error || 'pending operation';\r\n      console.warn(message, pendingMessage, metric.metadata);\r\n    } else {\r\n      // Handle actual errors\r\n      const errorToLog = metric.error || 'unknown error';\r\n      console.error(message, errorToLog, metric.metadata);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get metrics summary by category\r\n   */\r\n  getMetricsSummary(category?: DebugMetric['category']): MetricSummary[] {\r\n    const filteredMetrics = category \r\n      ? this.metrics.filter(m => m.category === category)\r\n      : this.metrics;\r\n\r\n    const summaryMap = new Map<string, DebugMetric[]>();\r\n\r\n    filteredMetrics.forEach(metric => {\r\n      const key = `${metric.category}:${metric.operation}`;\r\n      if (!summaryMap.has(key)) {\r\n        summaryMap.set(key, []);\r\n      }\r\n      summaryMap.get(key)!.push(metric);\r\n    });\r\n\r\n    return Array.from(summaryMap.entries()).map(([key, metrics]) => {\r\n      const [category, operation] = key.split(':');\r\n      const durations = metrics.filter(m => m.duration).map(m => m.duration!);\r\n      \r\n      return {\r\n        category,\r\n        operation,\r\n        totalOperations: metrics.length,\r\n        successRate: (metrics.filter(m => m.success).length / metrics.length) * 100,\r\n        averageDuration: durations.length > 0 ? durations.reduce((a, b) => a + b, 0) / durations.length : 0,\r\n        minDuration: durations.length > 0 ? Math.min(...durations) : 0,\r\n        maxDuration: durations.length > 0 ? Math.max(...durations) : 0,\r\n        totalErrors: metrics.filter(m => !m.success).length\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get performance snapshot\r\n   */\r\n  getPerformanceSnapshot(): PerformanceSnapshot {\r\n    let memoryUsage = null;\r\n    \r\n    if (typeof window !== 'undefined' && 'performance' in window && 'memory' in (performance as any)) {\r\n      const memory = (performance as any).memory;\r\n      memoryUsage = {\r\n        usedJSHeapSize: memory.usedJSHeapSize,\r\n        totalJSHeapSize: memory.totalJSHeapSize,\r\n        jsHeapSizeLimit: memory.jsHeapSizeLimit\r\n      };\r\n    }\r\n\r\n    return {\r\n      timestamp: Date.now(),\r\n      memoryUsage,\r\n      activeConnections: this.connectionCounter,\r\n      cacheStats: null // Will be populated by cache manager integration\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Export all metrics for analysis\r\n   */\r\n  exportMetrics(): string {\r\n    return JSON.stringify({\r\n      session: {\r\n        id: this.sessionId,\r\n        startTime: this.metrics[0]?.timestamp || Date.now(),\r\n        endTime: Date.now()\r\n      },\r\n      metrics: this.metrics,\r\n      summary: this.getMetricsSummary(),\r\n      performanceSnapshot: this.getPerformanceSnapshot()\r\n    }, null, 2);\r\n  }\r\n\r\n  /**\r\n   * Clear all stored metrics\r\n   */\r\n  clearMetrics(): void {\r\n    this.metrics = [];\r\n    this.activeOperations.clear();\r\n  }\r\n\r\n  /**\r\n   * Get recent metrics (last N minutes)\r\n   */\r\n  getRecentMetrics(minutes: number = 60): DebugMetric[] {\r\n    const cutoff = Date.now() - (minutes * 60 * 1000);\r\n    return this.metrics.filter(m => m.timestamp >= cutoff);\r\n  }\r\n\r\n  /**\r\n   * Get error metrics only\r\n   */\r\n  getErrorMetrics(): DebugMetric[] {\r\n    return this.metrics.filter(m => !m.success);\r\n  }\r\n\r\n  /**\r\n   * Start periodic reporting\r\n   */\r\n  private startPeriodicReporting(): void {\r\n    this.reportingInterval = setInterval(() => {\r\n      if (process.env.NODE_ENV === 'development') {\r\n        console.group('≡ƒöì Debug Logger Report');\r\n        console.table(this.getMetricsSummary());\r\n        console.log('Performance Snapshot:', this.getPerformanceSnapshot());\r\n        console.groupEnd();\r\n      }\r\n    }, 5 * 60 * 1000); // Every 5 minutes\r\n  }\r\n\r\n  /**\r\n   * Start performance snapshot collection\r\n   */\r\n  private startPerformanceSnapshot(): void {\r\n    this.performanceSnapshotInterval = setInterval(() => {\r\n      // Log performance snapshots periodically\r\n      this.logMetric({\r\n        category: 'performance',\r\n        operation: 'snapshot',\r\n        success: true,\r\n        timestamp: Date.now(),\r\n        metadata: this.getPerformanceSnapshot()\r\n      });\r\n    }, 60 * 1000); // Every minute\r\n  }\r\n\r\n  /**\r\n   * Setup global error handlers\r\n   */\r\n  private setupGlobalErrorHandlers(): void {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // Log unhandled errors\r\n    window.addEventListener('error', (event) => {\r\n      this.logMetric({\r\n        category: 'performance',\r\n        operation: 'unhandled_error',\r\n        success: false,\r\n        error: event.message,\r\n        timestamp: Date.now(),\r\n        metadata: {\r\n          filename: event.filename,\r\n          lineno: event.lineno,\r\n          colno: event.colno,\r\n          errorType: 'javascript_error'\r\n        }\r\n      });\r\n    });\r\n\r\n    // Log unhandled promise rejections\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      this.logMetric({\r\n        category: 'performance',\r\n        operation: 'unhandled_promise_rejection',\r\n        success: false,\r\n        error: String(event.reason),\r\n        timestamp: Date.now(),\r\n        metadata: {\r\n          reason: event.reason,\r\n          errorType: 'promise_rejection'\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Trim stored metrics to prevent memory bloat\r\n   */\r\n  private trimStoredMetrics(): void {\r\n    if (this.metrics.length > this.maxStoredMetrics) {\r\n      this.metrics = this.metrics.slice(-this.maxStoredMetrics);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate unique ID\r\n   */\r\n  private generateId(): string {\r\n    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Enable or disable debugging\r\n   */\r\n  setEnabled(enabled: boolean): void {\r\n    this.isEnabled = enabled;\r\n    \r\n    if (!enabled) {\r\n      if (this.reportingInterval) {\r\n        clearInterval(this.reportingInterval);\r\n        this.reportingInterval = null;\r\n      }\r\n      if (this.performanceSnapshotInterval) {\r\n        clearInterval(this.performanceSnapshotInterval);\r\n        this.performanceSnapshotInterval = null;\r\n      }\r\n      this.clearMetrics();\r\n    } else {\r\n      this.startPeriodicReporting();\r\n      this.startPerformanceSnapshot();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get debug information\r\n   */\r\n  getDebugInfo(): {\r\n    enabled: boolean;\r\n    sessionId: string;\r\n    totalMetrics: number;\r\n    activeOperations: number;\r\n    memoryUsage: PerformanceSnapshot['memoryUsage'];\r\n  } {\r\n    return {\r\n      enabled: this.isEnabled,\r\n      sessionId: this.sessionId,\r\n      totalMetrics: this.metrics.length,\r\n      activeOperations: this.activeOperations.size,\r\n      memoryUsage: this.getPerformanceSnapshot().memoryUsage\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const debugLoggerService = new DebugLoggerService();\r\n\r\n// Export convenience functions for easier usage\r\nexport const debugLogger = {\r\n  // Core logging\r\n  metric: (metric: Omit<DebugMetric, 'id' | 'userAgent' | 'sessionId'>) => debugLoggerService.logMetric(metric),\r\n  \r\n  // Authentication logging\r\n  auth: (metric: Parameters<DebugLoggerService['logAuth']>[0]) => debugLoggerService.logAuth(metric),\r\n  \r\n  // Database logging\r\n  database: (metric: Parameters<DebugLoggerService['logDatabase']>[0]) => debugLoggerService.logDatabase(metric),\r\n  \r\n  // Memory logging\r\n  memory: (metric: Parameters<DebugLoggerService['logMemory']>[0]) => debugLoggerService.logMemory(metric),\r\n  \r\n  // API logging\r\n  api: (metric: Parameters<DebugLoggerService['logApi']>[0]) => debugLoggerService.logApi(metric),\r\n  \r\n  // UI logging\r\n  ui: (metric: Parameters<DebugLoggerService['logUI']>[0]) => debugLoggerService.logUI(metric),\r\n  \r\n  // Operation timing\r\n  start: (category: DebugMetric['category'], operation: string, metadata?: Record<string, any>) => \r\n    debugLoggerService.startOperation(category, operation, metadata),\r\n  end: (operationId: string, success: boolean, metadata?: Record<string, any>) => \r\n    debugLoggerService.endOperation(operationId, success, metadata),\r\n  \r\n  // Data export\r\n  export: () => debugLoggerService.exportMetrics(),\r\n  summary: (category?: DebugMetric['category']) => debugLoggerService.getMetricsSummary(category),\r\n  errors: () => debugLoggerService.getErrorMetrics(),\r\n  debugInfo: () => debugLoggerService.getDebugInfo(),\r\n  \r\n  // Control\r\n  enable: () => debugLoggerService.setEnabled(true),\r\n  disable: () => debugLoggerService.setEnabled(false),\r\n  clear: () => debugLoggerService.clearMetrics()\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\folders-database.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token supabase","line":25,"column":11,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/folders-database.service.ts\r\n * @description Database operations specifically for folders\r\n * @created 2025-11-12\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { Folder } from '@/types';\r\nimport { SupabaseClient } from '@supabase/supabase-js';\r\nimport { globalCache, CACHE_CONFIGS } from './cache-manager';\r\nimport { DatabaseFolder, FolderUpdateData } from '@/lib/types/database';\r\nimport { isFolder } from '@/lib/utils/type-guards';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport {\r\n  DatabaseError,\r\n  AuthenticationError,\r\n  NotFoundError,\r\n} from '@/lib/errors/app-error';\r\n\r\n/**\r\n * Folders-specific database operations\r\n * Focused on folder CRUD operations with optimized caching\r\n */\r\nexport class FoldersDatabaseService {\r\n  private supabase: SupabaseClient;\r\n\r\n  constructor() {\r\n    this.supabase = createClient();\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for user-specific data\r\n   */\r\n  private getCacheKey(userId: string, operation: string, params?: string): string {\r\n    return `${userId}:folders:${operation}${params ? `:${params}` : ''}`;\r\n  }\r\n\r\n  /**\r\n   * Invalidate folders-related caches\r\n   */\r\n  private invalidateUserCache(userId: string): void {\r\n    globalCache.invalidateByTags(['folders', `user:${userId}`]);\r\n  }\r\n\r\n  /**\r\n   * Get all folders for current user\r\n   */\r\n  async getFolders(options: { limit?: number } = {}): Promise<Folder[]> {\r\n    const { data: { user } } = await this.supabase.auth.getUser();\r\n    if (!user) {\r\n      throw new AuthenticationError('User not authenticated');\r\n    }\r\n\r\n    const { limit = 500 } = options;\r\n    const cacheKey = this.getCacheKey(user.id, 'get', `limit:${limit}`);\r\n\r\n    // Check cache first\r\n    const cached = globalCache.get<Folder[]>(cacheKey);\r\n    if (cached !== null) {\r\n      return cached;\r\n    }\r\n\r\n    try {\r\n      const queryPromise = this.supabase\r\n        .from('folders')\r\n        .select('*')\r\n        .eq('user_id', user.id)\r\n        .order('created_at', { ascending: true })\r\n        .limit(limit);\r\n\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Folders query timeout')), 10000)\r\n      );\r\n\r\n      const { data, error } = await Promise.race([queryPromise, timeoutPromise]);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to fetch folders', { userId: user.id }, error as Error);\r\n      }\r\n\r\n      if (!data) {\r\n        return [];\r\n      }\r\n\r\n      const folders = data.map((dbFolder: DatabaseFolder) => {\r\n        const folder = this.transformFolderFromDB(dbFolder);\r\n        if (!isFolder(folder)) {\r\n          logger.warn('Invalid folder data received:', dbFolder);\r\n          return null;\r\n        }\r\n        return folder;\r\n      }).filter((folder): folder is Folder => folder !== null);\r\n\r\n      // Cache the result\r\n      globalCache.set(cacheKey, folders, { ...CACHE_CONFIGS.FOLDERS, tags: [...CACHE_CONFIGS.FOLDERS.tags] });\r\n\r\n      return folders;\r\n    } catch (error) {\r\n      logger.error('Error fetching folders:', error);\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to fetch folders', { userId: user.id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a new folder\r\n   */\r\n  async addFolder(folder: Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>): Promise<Folder> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      this.invalidateUserCache(user.id);\r\n\r\n      const folderData = {\r\n        user_id: user.id,\r\n        name: folder.name,\r\n        description: folder.description || null,\r\n        color: folder.color,\r\n        icon: folder.icon,\r\n        parent_id: folder.parentId || null,\r\n        is_platform_folder: folder.isPlatformFolder || false,\r\n        platform: folder.platform || null,\r\n        is_default: false,\r\n      };\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('folders')\r\n        .insert(folderData)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        if (error.code === '23505' || error.message?.includes('duplicate') || error.message?.includes('unique')) {\r\n          throw new DatabaseError('A folder with this name already exists', { folderData }, error as Error);\r\n        }\r\n        throw new DatabaseError('Failed to create folder', { folderData }, error as Error);\r\n      }\r\n      if (!data) {\r\n        throw new DatabaseError('Failed to create folder - no data returned', { folderData });\r\n      }\r\n\r\n      const createdFolder = this.transformFolderFromDB(data);\r\n      if (!isFolder(createdFolder)) {\r\n        throw new DatabaseError('Invalid folder data received from database', { folderId: data.id });\r\n      }\r\n      return createdFolder;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to add folder', { folder }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update an existing folder\r\n   */\r\n  async updateFolder(id: string, updates: Partial<Folder>): Promise<Folder> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      const updateData: FolderUpdateData = {};\r\n      \r\n      if (updates.name !== undefined) updateData.name = updates.name;\r\n      if (updates.description !== undefined) updateData.description = updates.description;\r\n      if (updates.color !== undefined) updateData.color = updates.color;\r\n      if (updates.icon !== undefined) updateData.icon = updates.icon;\r\n      if (updates.parentId !== undefined) updateData.parent_id = updates.parentId;\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('folders')\r\n        .update(updateData)\r\n        .eq('id', id)\r\n        .eq('user_id', user.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to update folder', { folderId: id }, error as Error);\r\n      }\r\n      if (!data) {\r\n        throw new NotFoundError('Folder', id);\r\n      }\r\n\r\n      const folder = this.transformFolderFromDB(data);\r\n      if (!isFolder(folder)) {\r\n        throw new DatabaseError('Invalid folder data received from database', { folderId: data.id });\r\n      }\r\n      return folder;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to update folder', { folderId: id, updates }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a folder\r\n   */\r\n  async deleteFolder(id: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      this.invalidateUserCache(user.id);\r\n\r\n      // First, set folder_id to null for all links in this folder\r\n      const { error: linksError } = await this.supabase\r\n        .from('links')\r\n        .update({ folder_id: null })\r\n        .eq('folder_id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (linksError) {\r\n        throw new DatabaseError('Failed to update links before folder deletion', { folderId: id }, linksError as Error);\r\n      }\r\n\r\n      // Then delete the folder\r\n      const { error } = await this.supabase\r\n        .from('folders')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to delete folder', { folderId: id }, error as Error);\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to delete folder', { folderId: id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enable sharing for a folder\r\n   */\r\n  async enableFolderSharing(folderId: string): Promise<{ shareUrl: string; shareId: string }> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Verify folder exists and belongs to user\r\n      const { data: folder, error: folderError } = await this.supabase\r\n        .from('folders')\r\n        .select('*')\r\n        .eq('id', folderId)\r\n        .eq('user_id', user.id)\r\n        .single();\r\n\r\n      if (folderError || !folder) {\r\n        throw new NotFoundError('Folder', folderId);\r\n      }\r\n\r\n      // Generate share ID\r\n      const shareId = `share_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n      const shareUrl = `${process.env.NEXT_PUBLIC_BASE_URL}/share/folder/${shareId}`;\r\n\r\n      // Update folder with sharing info\r\n      const { error: updateError } = await this.supabase\r\n        .from('folders')\r\n        .update({\r\n          shareable: true,\r\n          share_id: shareId,\r\n          share_created_at: new Date().toISOString()\r\n        })\r\n        .eq('id', folderId)\r\n        .eq('user_id', user.id);\r\n\r\n      if (updateError) {\r\n        throw new DatabaseError('Failed to enable folder sharing', { folderId }, updateError as Error);\r\n      }\r\n\r\n      // Create share record\r\n      const { error: shareError } = await this.supabase\r\n        .from('folder_shares')\r\n        .insert({\r\n          folder_id: folderId,\r\n          share_id: shareId,\r\n          created_by: user.id\r\n        });\r\n\r\n      if (shareError) {\r\n        throw new DatabaseError('Failed to create share record', { folderId }, shareError as Error);\r\n      }\r\n\r\n      this.invalidateUserCache(user.id);\r\n      \r\n      return { shareUrl, shareId };\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError || error instanceof NotFoundError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to enable folder sharing', { folderId }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable sharing for a folder\r\n   */\r\n  async disableFolderSharing(folderId: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Verify folder exists and belongs to user\r\n      const { data: folder, error: folderError } = await this.supabase\r\n        .from('folders')\r\n        .select('*')\r\n        .eq('id', folderId)\r\n        .eq('user_id', user.id)\r\n        .single();\r\n\r\n      if (folderError || !folder) {\r\n        throw new NotFoundError('Folder', folderId);\r\n      }\r\n\r\n      if (!folder.share_id) {\r\n        throw new DatabaseError('Folder is not currently shared', { folderId });\r\n      }\r\n\r\n      // Disable sharing\r\n      const { error: updateError } = await this.supabase\r\n        .from('folders')\r\n        .update({\r\n          shareable: false,\r\n          share_id: null,\r\n          share_created_at: null\r\n        })\r\n        .eq('id', folderId)\r\n        .eq('user_id', user.id);\r\n\r\n      if (updateError) {\r\n        throw new DatabaseError('Failed to disable sharing', { folderId }, updateError as Error);\r\n      }\r\n\r\n      // Delete share record and analytics\r\n      await this.supabase\r\n        .from('share_analytics')\r\n        .delete()\r\n        .eq('share_id', folder.share_id);\r\n\r\n      await this.supabase\r\n        .from('folder_shares')\r\n        .delete()\r\n        .eq('share_id', folder.share_id);\r\n\r\n      this.invalidateUserCache(user.id);\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError || error instanceof NotFoundError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to disable folder sharing', { folderId }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get shared folder data\r\n   */\r\n  async getSharedFolder(shareId: string): Promise<any | null> {\r\n    try {\r\n      const { data, error } = await this.supabase\r\n        .from('folders')\r\n        .select(`\r\n          id,\r\n          name,\r\n          description,\r\n          color,\r\n          icon,\r\n          shareable,\r\n          share_id,\r\n          share_created_at,\r\n          links (\r\n            id,\r\n            title,\r\n            description,\r\n            url,\r\n            thumbnail,\r\n            favicon_url,\r\n            platform,\r\n            is_favorite,\r\n            tags,\r\n            created_at\r\n          )\r\n        `)\r\n        .eq('share_id', shareId)\r\n        .eq('shareable', true)\r\n        .single();\r\n\r\n      if (error || !data) {\r\n        return null;\r\n      }\r\n\r\n      return data;\r\n    } catch (error) {\r\n      logger.error('Error fetching shared folder:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform folder from database schema to app schema\r\n   */\r\n  private transformFolderFromDB(dbFolder: DatabaseFolder): Folder {\r\n    return {\r\n      id: dbFolder.id,\r\n      name: dbFolder.name,\r\n      description: dbFolder.description || '',\r\n      color: dbFolder.color,\r\n      icon: dbFolder.icon,\r\n      parentId: dbFolder.parent_id,\r\n      isPlatformFolder: dbFolder.is_platform_folder || false,\r\n      platform: dbFolder.platform as any, // Platform type\r\n      createdAt: dbFolder.created_at,\r\n      updatedAt: dbFolder.updated_at,\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const foldersDatabaseService = new FoldersDatabaseService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\links-database.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token supabase","line":26,"column":11,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/links-database.service.ts\r\n * @description Database operations specifically for links\r\n * @created 2025-11-12\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { Link } from '@/types';\r\nimport { SupabaseClient } from '@supabase/supabase-js';\r\nimport { globalCache, CACHE_CONFIGS } from './cache-manager';\r\nimport { debugLogger } from './debug-logger.service';\r\nimport { DatabaseLink, LinkUpdateData } from '@/lib/types/database';\r\nimport { isLink } from '@/lib/utils/type-guards';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport {\r\n  DatabaseError,\r\n  AuthenticationError,\r\n  NotFoundError,\r\n} from '@/lib/errors/app-error';\r\n\r\n/**\r\n * Links-specific database operations\r\n * Focused on link CRUD operations with optimized caching\r\n */\r\nexport class LinksDatabaseService {\r\n  private supabase: SupabaseClient;\r\n\r\n  constructor() {\r\n    this.supabase = createClient();\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for user-specific data\r\n   * @param userId - User ID\r\n   * @param operation - Operation name\r\n   * @param params - Additional parameters\r\n   */\r\n  private getCacheKey(userId: string, operation: string, params?: string): string {\r\n    return `${userId}:links:${operation}${params ? `:${params}` : ''}`;\r\n  }\r\n\r\n  /**\r\n   * Invalidate links-related caches\r\n   * @param userId - User ID to invalidate caches for\r\n   */\r\n  private invalidateUserCache(userId: string): void {\r\n    globalCache.invalidateByTags(['links', `user:${userId}`]);\r\n  }\r\n\r\n  /**\r\n   * Get all links for current user\r\n   * @param options - Query options\r\n   */\r\n  async getLinks(options: { limit?: number; offset?: number } = {}): Promise<Link[]> {\r\n    const startTime = Date.now();\r\n    const { data: { user } } = await this.supabase.auth.getUser();\r\n    if (!user) {\r\n      throw new AuthenticationError('User not authenticated');\r\n    }\r\n\r\n    const { limit = 1000, offset = 0 } = options;\r\n    const cacheKey = this.getCacheKey(user.id, 'get', `limit:${limit}:offset:${offset}`);\r\n\r\n    // Check cache first with performance tracking\r\n    const cached = globalCache.get<Link[]>(cacheKey);\r\n    if (cached !== null) {\r\n      // Log cache hit performance\r\n      debugLogger.database({\r\n        operation: 'getLinks',\r\n        success: true,\r\n        duration: Date.now() - startTime,\r\n        cacheHit: true,\r\n        dataSize: cached.length\r\n      });\r\n      return cached;\r\n    }\r\n\r\n    try {\r\n      const queryStartTime = Date.now();\r\n\r\n      // Optimized query with better indexing strategy\r\n      const queryPromise = this.supabase\r\n        .from('links')\r\n        .select(`\r\n          id,\r\n          user_id,\r\n          url,\r\n          title,\r\n          description,\r\n          thumbnail,\r\n          platform,\r\n          folder_id,\r\n          is_favorite,\r\n          tags,\r\n          favicon_url,\r\n          created_at,\r\n          updated_at,\r\n          deleted_at\r\n        `, { count: 'exact' })\r\n        .eq('user_id', user.id)\r\n        .is('deleted_at', null) // Only active links\r\n        .order('updated_at', { ascending: false }) // Better for recent updates\r\n        .range(offset, offset + limit - 1);\r\n\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Links query timeout')), 10000) // Reduced timeout\r\n      );\r\n\r\n      const { data, error, count } = await Promise.race([queryPromise, timeoutPromise]);\r\n\r\n      const queryDuration = Date.now() - queryStartTime;\r\n\r\n      if (error) {\r\n        debugLogger.database({\r\n          operation: 'getLinks',\r\n          success: false,\r\n          duration: queryDuration,\r\n          error: error.message\r\n        });\r\n        throw new DatabaseError('Failed to fetch links', { userId: user.id }, error as Error);\r\n      }\r\n\r\n      if (!data) {\r\n        // Log empty result performance\r\n        debugLogger.database({\r\n          operation: 'getLinks',\r\n          success: true,\r\n          duration: Date.now() - startTime,\r\n          cacheHit: false,\r\n          dataSize: 0\r\n        });\r\n        return [];\r\n      }\r\n\r\n      // Transform data efficiently\r\n      const links = data.map((dbLink: DatabaseLink) => {\r\n        const link = this.transformLinkFromDB(dbLink);\r\n        if (!isLink(link)) {\r\n          logger.warn('Invalid link data received:', dbLink);\r\n          return null;\r\n        }\r\n        return link;\r\n      }).filter((link): link is Link => link !== null);\r\n\r\n      const totalDuration = Date.now() - startTime;\r\n\r\n      // Cache the result\r\n      globalCache.set(cacheKey, links, {\r\n        ...CACHE_CONFIGS.LINKS,\r\n        tags: [...CACHE_CONFIGS.LINKS.tags, `user:${user.id}`]\r\n      });\r\n\r\n      // Log successful query performance\r\n      debugLogger.database({\r\n        operation: 'getLinks',\r\n        success: true,\r\n        duration: totalDuration,\r\n        cacheHit: false,\r\n        dataSize: links.length,\r\n        queryType: 'database_query'\r\n      });\r\n\r\n      return links;\r\n    } catch (error) {\r\n      logger.error('Error fetching links:', error);\r\n      debugLogger.database({\r\n        operation: 'getLinks',\r\n        success: false,\r\n        duration: Date.now() - startTime,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to fetch links', { userId: user.id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a new link\r\n   * @param link - Link data\r\n   */\r\n  async addLink(link: Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>): Promise<Link> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache\r\n      // Cache invalidation moved to after success\r\n\r\n      const linkData = {\r\n        user_id: user.id,\r\n        url: link.url,\r\n        title: link.title,\r\n        description: link.description || null,\r\n        thumbnail: link.thumbnail || null,\r\n        platform: link.platform,\r\n        folder_id: link.folderId || null,\r\n        is_favorite: link.isFavorite || false,\r\n        tags: link.tags || [],\r\n        favicon_url: link.faviconUrl || null,\r\n        is_archived: false,\r\n        click_count: 0,\r\n        last_clicked_at: null,\r\n        deleted_at: null,\r\n      };\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('links')\r\n        .insert(linkData)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to create link', { linkData }, error as Error);\r\n      }\r\n      if (!data) {\r\n        throw new DatabaseError('Failed to create link - no data returned', { linkData });\r\n      }\r\n\r\n      const createdLink = this.transformLinkFromDB(data);\r\n      if (!isLink(createdLink)) {\r\n        throw new DatabaseError('Invalid link data received from database', { linkId: data.id });\r\n      }\r\n\r\n      // Invalidate cache after successful creation\r\n      this.invalidateUserCache(user.id);\r\n\r\n      return createdLink;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to add link', { link }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update an existing link\r\n   * @param id - Link ID\r\n   * @param updates - Fields to update\r\n   */\r\n  async updateLink(id: string, updates: Partial<Link>): Promise<Link> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Cache invalidation moved to after success\r\n\r\n      const updateData: LinkUpdateData = {};\r\n\r\n      if (updates.title !== undefined) updateData.title = updates.title;\r\n      if (updates.description !== undefined) updateData.description = updates.description;\r\n      if (updates.url !== undefined) updateData.url = updates.url;\r\n      if (updates.thumbnail !== undefined) updateData.thumbnail = updates.thumbnail;\r\n      if (updates.faviconUrl !== undefined) updateData.favicon_url = updates.faviconUrl;\r\n      if (updates.platform !== undefined) updateData.platform = updates.platform;\r\n      if (updates.folderId !== undefined) updateData.folder_id = updates.folderId;\r\n      if (updates.isFavorite !== undefined) updateData.is_favorite = updates.isFavorite;\r\n      if (updates.tags !== undefined) updateData.tags = updates.tags;\r\n      if (updates.deletedAt !== undefined) updateData.deleted_at = updates.deletedAt;\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('links')\r\n        .update(updateData)\r\n        .eq('id', id)\r\n        .eq('user_id', user.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to update link', { linkId: id }, error as Error);\r\n      }\r\n      if (!data) {\r\n        throw new NotFoundError('Link', id);\r\n      }\r\n\r\n      const link = this.transformLinkFromDB(data);\r\n      if (!isLink(link)) {\r\n        throw new DatabaseError('Invalid link data received from database', { linkId: data.id });\r\n      }\r\n\r\n      // Invalidate cache after successful update\r\n      this.invalidateUserCache(user.id);\r\n\r\n      return link;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to update link', { linkId: id, updates }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a link (soft delete)\r\n   * @param id - Link ID\r\n   */\r\n  async deleteLink(id: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Cache invalidation moved to after success\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .update({ deleted_at: new Date().toISOString() })\r\n        .eq('id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to delete link', { linkId: id }, error as Error);\r\n      }\r\n\r\n      // Invalidate cache after successful deletion\r\n      this.invalidateUserCache(user.id);\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to delete link', { linkId: id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore a link from trash\r\n   * @param id - Link ID\r\n   */\r\n  async restoreLink(id: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Cache invalidation moved to after success\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .update({ deleted_at: null })\r\n        .eq('id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to restore link', { linkId: id }, error as Error);\r\n      }\r\n\r\n      // Invalidate cache after successful restoration\r\n      this.invalidateUserCache(user.id);\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to restore link', { linkId: id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Permanently delete a link\r\n   * @param id - Link ID\r\n   */\r\n  async permanentlyDeleteLink(id: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Cache invalidation moved to after success\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to permanently delete link', { linkId: id }, error as Error);\r\n      }\r\n\r\n      // Invalidate cache after successful deletion\r\n      this.invalidateUserCache(user.id);\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to permanently delete link', { linkId: id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bulk update multiple links with the same updates\r\n   */\r\n  async bulkUpdateLinks(ids: string[], updates: Partial<Link>): Promise<Link[]> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      if (ids.length === 0) return [];\r\n\r\n      const updateData: LinkUpdateData & { updated_at: string } = {\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      if (updates.title !== undefined) updateData.title = updates.title;\r\n      if (updates.description !== undefined) updateData.description = updates.description;\r\n      if (updates.url !== undefined) updateData.url = updates.url;\r\n      if (updates.thumbnail !== undefined) updateData.thumbnail = updates.thumbnail;\r\n      if (updates.faviconUrl !== undefined) updateData.favicon_url = updates.faviconUrl;\r\n      if (updates.platform !== undefined) updateData.platform = updates.platform;\r\n      if (updates.folderId !== undefined) updateData.folder_id = updates.folderId;\r\n      if (updates.isFavorite !== undefined) updateData.is_favorite = updates.isFavorite;\r\n      if (updates.tags !== undefined) updateData.tags = updates.tags;\r\n      if (updates.deletedAt !== undefined) updateData.deleted_at = updates.deletedAt;\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('links')\r\n        .update(updateData)\r\n        .in('id', ids)\r\n        .eq('user_id', user.id)\r\n        .select();\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to bulk update links', { linkIds: ids }, error as Error);\r\n      }\r\n\r\n      if (!data || data.length === 0) {\r\n        logger.warn('Bulk update matched 0 rows', { ids, userId: user.id });\r\n        throw new DatabaseError('No links were updated. Please try again.', { linkIds: ids });\r\n      }\r\n\r\n      // Validate and transform results\r\n      const links = data.map((dbLink: DatabaseLink) => {\r\n        const link = this.transformLinkFromDB(dbLink);\r\n        if (!isLink(link)) {\r\n          logger.warn('Invalid link data received in bulk update:', dbLink);\r\n          return null;\r\n        }\r\n        return link;\r\n      }).filter((link): link is Link => link !== null);\r\n\r\n      // Invalidate cache after successful bulk update\r\n      this.invalidateUserCache(user.id);\r\n\r\n      return links;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to bulk update links', { linkIds: ids }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bulk delete multiple links\r\n   */\r\n  async bulkDeleteLinks(ids: string[]): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      if (ids.length === 0) return;\r\n\r\n      logger.debug('Bulk deleting links:', { userId: user.id, count: ids.length, ids });\r\n\r\n      const { error, data } = await this.supabase\r\n        .from('links')\r\n        .update({\r\n          deleted_at: new Date().toISOString(),\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .in('id', ids)\r\n        .eq('user_id', user.id)\r\n        .select('id');\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to bulk delete links', { linkIds: ids }, error as Error);\r\n      }\r\n\r\n      if (!data || data.length === 0) {\r\n        logger.warn('Bulk delete matched 0 rows', { ids, userId: user.id });\r\n        throw new DatabaseError('No links were deleted. Please try again.', { linkIds: ids });\r\n      }\r\n\r\n      logger.debug('Bulk delete result:', { count: data.length });\r\n\r\n      // Invalidate cache after successful bulk deletion\r\n      this.invalidateUserCache(user.id);\r\n    } catch (error) {\r\n      logger.error('Error bulk deleting links:', error);\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to bulk delete links', { linkIds: ids }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bulk restore multiple links\r\n   */\r\n  async bulkRestoreLinks(ids: string[]): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      if (ids.length === 0) return;\r\n\r\n      const { error, data } = await this.supabase\r\n        .from('links')\r\n        .update({\r\n          deleted_at: null,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .in('id', ids)\r\n        .eq('user_id', user.id)\r\n        .select('id');\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to bulk restore links', { linkIds: ids }, error as Error);\r\n      }\r\n\r\n      if (!data || data.length === 0) {\r\n        logger.warn('Bulk restore matched 0 rows', { ids, userId: user.id });\r\n        throw new DatabaseError('No links were restored. Please try again.', { linkIds: ids });\r\n      }\r\n\r\n      // Invalidate cache after successful bulk restoration\r\n      this.invalidateUserCache(user.id);\r\n    } catch (error) {\r\n      logger.error('Error bulk restoring links:', error);\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to bulk restore links', { linkIds: ids }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bulk move multiple links to a specific folder\r\n   */\r\n  async bulkMoveLinks(ids: string[], folderId: string | null): Promise<Link[]> {\r\n    return this.bulkUpdateLinks(ids, { folderId });\r\n  }\r\n\r\n  /**\r\n   * Bulk toggle favorite status for multiple links\r\n   */\r\n  async bulkToggleFavoriteLinks(ids: string[], isFavorite: boolean): Promise<Link[]> {\r\n    return this.bulkUpdateLinks(ids, { isFavorite });\r\n  }\r\n\r\n  /**\r\n   * Empty trash (permanently delete all trashed links)\r\n   */\r\n  async emptyTrash(): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Cache invalidation moved to after success\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .delete()\r\n        .eq('user_id', user.id)\r\n        .not('deleted_at', 'is', null);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to empty trash', { userId: user.id }, error as Error);\r\n      }\r\n\r\n      // Invalidate cache after successful operation\r\n      this.invalidateUserCache(user.id);\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to empty trash', {}, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore all links from trash\r\n   */\r\n  async restoreAllFromTrash(): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Cache invalidation moved to after success\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .update({ deleted_at: null })\r\n        .eq('user_id', user.id)\r\n        .not('deleted_at', 'is', null);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to restore all from trash', { userId: user.id }, error as Error);\r\n      }\r\n\r\n      // Invalidate cache after successful operation\r\n      this.invalidateUserCache(user.id);\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to restore all from trash', {}, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform link from database schema to app schema\r\n   */\r\n  private transformLinkFromDB(dbLink: DatabaseLink): Link {\r\n    return {\r\n      id: dbLink.id,\r\n      url: dbLink.url,\r\n      title: dbLink.title || '',\r\n      description: dbLink.description || '',\r\n      thumbnail: dbLink.thumbnail || '',\r\n      faviconUrl: dbLink.favicon_url || '',\r\n      platform: dbLink.platform as any,\r\n      folderId: dbLink.folder_id,\r\n      isFavorite: dbLink.is_favorite || false,\r\n      tags: dbLink.tags || [],\r\n      deletedAt: dbLink.deleted_at,\r\n      createdAt: dbLink.created_at,\r\n      updatedAt: dbLink.updated_at,\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const linksDatabaseService = new LinksDatabaseService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\pagination.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":7,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/pagination.service.ts\r\n * @description Pagination utilities for handling large datasets efficiently\r\n * @created 2025-11-11\r\n */\r\n\r\nexport interface PaginationOptions {\r\n  page?: number;\r\n  limit?: number;\r\n  cursor?: string;\r\n  orderBy?: string;\r\n  orderDirection?: 'asc' | 'desc';\r\n}\r\n\r\nexport interface PaginatedResult<T> {\r\n  data: T[];\r\n  meta: {\r\n    total: number;\r\n    page: number;\r\n    limit: number;\r\n    totalPages: number;\r\n    hasNextPage: boolean;\r\n    hasPrevPage: boolean;\r\n    nextCursor?: string;\r\n    prevCursor?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Creates a cursor from an item's ID and sort field\r\n * @param {string} id - Item ID\r\n * @param {string | number} sortValue - Sort field value\r\n * @returns {string} Encoded cursor\r\n */\r\nexport function createCursor(id: string, sortValue: string | number): string {\r\n  const data = `${sortValue}_${id}`;\r\n  return Buffer.from(data).toString('base64');\r\n}\r\n\r\n/**\r\n * Decodes a cursor to get ID and sort value\r\n * @param {string} cursor - Encoded cursor\r\n * @returns {{id: string, sortValue: string} | null} Decoded cursor data\r\n */\r\nexport function decodeCursor(cursor: string): { id: string; sortValue: string } | null {\r\n  try {\r\n    const decoded = Buffer.from(cursor, 'base64').toString('utf-8');\r\n    const [sortValue, id] = decoded.split('_');\r\n    return { id, sortValue };\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Builds pagination query conditions for Supabase\r\n * @param {PaginationOptions} options - Pagination options\r\n * @param {string} sortField - Field to sort by\r\n * @returns {Object} Query conditions\r\n */\r\nexport function buildPaginationQuery(\r\n  options: PaginationOptions,\r\n  sortField: string = 'created_at'\r\n): {\r\n  limit: number;\r\n  orderBy: { column: string; ascending: boolean };\r\n  range?: { from: number; to: number };\r\n  cursorCondition?: { column: string; operator: string; value: any };\r\n} {\r\n  const limit = Math.min(options.limit || 20, 100); // Max 100 items per page\r\n  const orderDirection = options.orderDirection || 'desc';\r\n  const orderBy = {\r\n    column: options.orderBy || sortField,\r\n    ascending: orderDirection === 'asc',\r\n  };\r\n\r\n  // Cursor-based pagination (preferred for infinite scroll)\r\n  if (options.cursor) {\r\n    const cursorData = decodeCursor(options.cursor);\r\n    if (cursorData) {\r\n      const operator = orderDirection === 'desc' ? 'lt' : 'gt';\r\n      return {\r\n        limit,\r\n        orderBy,\r\n        cursorCondition: {\r\n          column: orderBy.column,\r\n          operator,\r\n          value: cursorData.sortValue,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  // Offset-based pagination (fallback)\r\n  const page = Math.max(1, options.page || 1);\r\n  const from = (page - 1) * limit;\r\n  const to = from + limit - 1;\r\n\r\n  return {\r\n    limit,\r\n    orderBy,\r\n    range: { from, to },\r\n  };\r\n}\r\n\r\n/**\r\n * Calculates pagination metadata\r\n * @param {number} total - Total number of items\r\n * @param {number} page - Current page\r\n * @param {number} limit - Items per page\r\n * @param {T[]} data - Current page data\r\n * @returns {PaginatedResult<T>['meta']} Pagination metadata\r\n */\r\nexport function calculatePaginationMeta<T extends { id: string; [key: string]: any }>(\r\n  total: number,\r\n  page: number,\r\n  limit: number,\r\n  data: T[],\r\n  orderBy: string = 'created_at'\r\n): PaginatedResult<T>['meta'] {\r\n  const totalPages = Math.ceil(total / limit);\r\n  const hasNextPage = page < totalPages;\r\n  const hasPrevPage = page > 1;\r\n\r\n  // Generate cursors\r\n  let nextCursor: string | undefined;\r\n  let prevCursor: string | undefined;\r\n\r\n  if (data.length > 0) {\r\n    // Next cursor from last item\r\n    const lastItem = data[data.length - 1];\r\n    const lastSortValue = lastItem[orderBy] || lastItem.id;\r\n    nextCursor = createCursor(lastItem.id, lastSortValue);\r\n\r\n    // Prev cursor from first item\r\n    const firstItem = data[0];\r\n    const firstSortValue = firstItem[orderBy] || firstItem.id;\r\n    prevCursor = createCursor(firstItem.id, firstSortValue);\r\n  }\r\n\r\n  return {\r\n    total,\r\n    page,\r\n    limit,\r\n    totalPages,\r\n    hasNextPage,\r\n    hasPrevPage,\r\n    nextCursor,\r\n    prevCursor,\r\n  };\r\n}\r\n\r\n/**\r\n * Optimized pagination for Supabase with cursor-based navigation\r\n * @param {any} supabase - Supabase client\r\n * @param {string} table - Table name\r\n * @param {PaginationOptions} options - Pagination options\r\n * @param {Object} filters - Additional filters\r\n * @returns {Promise<PaginatedResult<any>>} Paginated result\r\n */\r\nexport async function paginateSupabaseQuery(\r\n  supabase: any,\r\n  table: string,\r\n  options: PaginationOptions = {},\r\n  filters: Record<string, any> = {}\r\n): Promise<PaginatedResult<any>> {\r\n  const { limit, orderBy, range, cursorCondition } = buildPaginationQuery(options);\r\n\r\n  let query = supabase\r\n    .from(table)\r\n    .select('*', { count: 'exact' });\r\n\r\n  // Apply filters\r\n  Object.entries(filters).forEach(([key, value]) => {\r\n    if (value !== undefined && value !== null) {\r\n      query = query.eq(key, value);\r\n    }\r\n  });\r\n\r\n  // Apply cursor condition for cursor-based pagination\r\n  if (cursorCondition) {\r\n    query = query[cursorCondition.operator](cursorCondition.column, cursorCondition.value);\r\n  }\r\n\r\n  // Apply range for offset-based pagination\r\n  if (range) {\r\n    query = query.range(range.from, range.to);\r\n  }\r\n\r\n  // Apply ordering\r\n  query = query.order(orderBy.column, { ascending: orderBy.ascending });\r\n\r\n  // Apply limit\r\n  query = query.limit(limit);\r\n\r\n  const { data, error, count } = await query;\r\n\r\n  if (error) {\r\n    throw error;\r\n  }\r\n\r\n  const page = options.page || 1;\r\n  const meta = calculatePaginationMeta(\r\n    count || 0,\r\n    page,\r\n    limit,\r\n    data || [],\r\n    orderBy.column\r\n  );\r\n\r\n  return {\r\n    data: data || [],\r\n    meta,\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\performance-monitor.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":9,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file performance-monitor.service.ts\r\n * @description Performance monitoring and error tracking service for application optimization\r\n * @created 2024-12-19\r\n */\r\n\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface PerformanceMetric {\r\n  name: string;\r\n  value: number;\r\n  timestamp: number;\r\n  tags?: Record<string, string>;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\ninterface ErrorEvent {\r\n  id: string;\r\n  message: string;\r\n  stack?: string;\r\n  timestamp: number;\r\n  url: string;\r\n  userAgent: string;\r\n  userId?: string;\r\n  context?: Record<string, any>;\r\n  severity: 'low' | 'medium' | 'high' | 'critical';\r\n}\r\n\r\ninterface UserInteraction {\r\n  type: 'click' | 'navigation' | 'search' | 'form_submit' | 'modal_open' | 'modal_close';\r\n  element?: string;\r\n  timestamp: number;\r\n  duration?: number;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\ninterface PerformanceReport {\r\n  metrics: PerformanceMetric[];\r\n  errors: ErrorEvent[];\r\n  interactions: UserInteraction[];\r\n  summary: {\r\n    totalErrors: number;\r\n    avgLoadTime: number;\r\n    totalInteractions: number;\r\n    criticalErrors: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Performance monitoring service for tracking metrics, errors, and user interactions\r\n */\r\nclass PerformanceMonitorService {\r\n  private metrics: PerformanceMetric[] = [];\r\n  private errors: ErrorEvent[] = [];\r\n  private interactions: UserInteraction[] = [];\r\n  private isEnabled: boolean = true;\r\n  private maxStoredItems: number = 1000;\r\n  private reportingInterval: number = 5 * 60 * 1000; // 5 minutes\r\n  private reportingTimer: NodeJS.Timeout | null = null;\r\n  private alertThrottleMap: Map<string, number> = new Map();\r\n  private eventListeners: Array<{ element: Window | Document; event: string; handler: EventListener }> = [];\r\n  private performanceObservers: PerformanceObserver[] = [];\r\n  private throttleMapCleanupTimer: NodeJS.Timeout | null = null;\r\n  private maxThrottleMapSize: number = 100; // Limit throttle map size\r\n\r\n  constructor() {\r\n    this.initializeMonitoring();\r\n  }\r\n\r\n  /**\r\n   * Initialize performance monitoring with browser APIs\r\n   */\r\n  private initializeMonitoring(): void {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // Monitor unhandled errors\r\n    const errorHandler = (event: Event) => {\r\n      const errorEvent = event as unknown as ErrorEvent;\r\n      // Access error property safely - ErrorEvent.error is available but TypeScript types may be outdated\r\n      const error = (errorEvent as unknown as { error?: Error }).error || undefined;\r\n      const filename = (errorEvent as unknown as { filename?: string }).filename;\r\n      const lineno = (errorEvent as unknown as { lineno?: number }).lineno;\r\n      const colno = (errorEvent as unknown as { colno?: number }).colno;\r\n      \r\n      this.trackError({\r\n        message: errorEvent.message || 'Unknown error',\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n        url: filename || window.location.href,\r\n        severity: 'high',\r\n        context: {\r\n          lineno: lineno,\r\n          colno: colno,\r\n          type: 'javascript_error'\r\n        }\r\n      });\r\n    };\r\n    window.addEventListener('error', errorHandler);\r\n    this.eventListeners.push({ element: window, event: 'error', handler: errorHandler as EventListener });\r\n\r\n    // Monitor unhandled promise rejections\r\n    const rejectionHandler = (event: Event) => {\r\n      const rejectionEvent = event as PromiseRejectionEvent;\r\n      const reason = rejectionEvent.reason;\r\n      this.trackError({\r\n        message: `Unhandled Promise Rejection: ${reason}`,\r\n        stack: reason instanceof Error ? reason.stack : undefined,\r\n        url: window.location.href,\r\n        severity: 'high',\r\n        context: {\r\n          type: 'promise_rejection',\r\n          reason: reason\r\n        }\r\n      });\r\n    };\r\n    window.addEventListener('unhandledrejection', rejectionHandler);\r\n    this.eventListeners.push({ element: window, event: 'unhandledrejection', handler: rejectionHandler as EventListener });\r\n\r\n    // Monitor performance entries\r\n    if ('PerformanceObserver' in window) {\r\n      this.initializePerformanceObserver();\r\n    }\r\n\r\n    // Start periodic reporting\r\n    this.startPeriodicReporting();\r\n\r\n    // Start throttle map cleanup timer\r\n    this.startThrottleMapCleanup();\r\n  }\r\n\r\n  /**\r\n   * Initialize Performance Observer for detailed metrics\r\n   */\r\n  private initializePerformanceObserver(): void {\r\n    try {\r\n      // Monitor navigation timing\r\n      const navObserver = new PerformanceObserver((list) => {\r\n        for (const entry of list.getEntries()) {\r\n          if (entry.entryType === 'navigation') {\r\n            const navEntry = entry as PerformanceNavigationTiming;\r\n            this.trackMetric('page_load_time', navEntry.loadEventEnd - navEntry.fetchStart, {\r\n              type: 'navigation',\r\n              url: window.location.pathname\r\n            });\r\n          }\r\n        }\r\n      });\r\n      navObserver.observe({ entryTypes: ['navigation'] });\r\n      this.performanceObservers.push(navObserver);\r\n\r\n      // Monitor resource loading\r\n      const resourceObserver = new PerformanceObserver((list) => {\r\n        for (const entry of list.getEntries()) {\r\n          if (entry.entryType === 'resource') {\r\n            const resourceEntry = entry as PerformanceResourceTiming;\r\n            this.trackMetric('resource_load_time', resourceEntry.responseEnd - resourceEntry.startTime, {\r\n              type: 'resource',\r\n              name: resourceEntry.name,\r\n              size: resourceEntry.transferSize?.toString() || '0'\r\n            });\r\n          }\r\n        }\r\n      });\r\n      resourceObserver.observe({ entryTypes: ['resource'] });\r\n      this.performanceObservers.push(resourceObserver);\r\n\r\n      // Monitor largest contentful paint\r\n      const lcpObserver = new PerformanceObserver((list) => {\r\n        for (const entry of list.getEntries()) {\r\n          this.trackMetric('largest_contentful_paint', entry.startTime, {\r\n            type: 'lcp',\r\n            url: window.location.pathname\r\n          });\r\n        }\r\n      });\r\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\r\n      this.performanceObservers.push(lcpObserver);\r\n\r\n      // Monitor first input delay\r\n      const fidObserver = new PerformanceObserver((list) => {\r\n        for (const entry of list.getEntries()) {\r\n          this.trackMetric('first_input_delay', (entry as any).processingStart - entry.startTime, {\r\n            type: 'fid',\r\n            url: window.location.pathname\r\n          });\r\n        }\r\n      });\r\n      fidObserver.observe({ entryTypes: ['first-input'] });\r\n      this.performanceObservers.push(fidObserver);\r\n\r\n    } catch (error) {\r\n      // Only log in development\r\n      if (process.env.NODE_ENV === 'development') {\r\n        logger.warn('Failed to initialize PerformanceObserver:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track a performance metric\r\n   * @param {string} name - Metric name\r\n   * @param {number} value - Metric value\r\n   * @param {Record<string, string>} tags - Optional tags for categorization\r\n   * @param {Record<string, any>} metadata - Optional metadata\r\n   */\r\n  trackMetric(\r\n    name: string, \r\n    value: number, \r\n    tags?: Record<string, string>,\r\n    metadata?: Record<string, any>\r\n  ): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    const metric: PerformanceMetric = {\r\n      name,\r\n      value,\r\n      timestamp: Date.now(),\r\n      tags,\r\n      metadata\r\n    };\r\n\r\n    this.metrics.push(metric);\r\n    this.trimStoredItems('metrics');\r\n\r\n    // Log critical performance issues (development only)\r\n    if (process.env.NODE_ENV === 'development' && this.isCriticalMetric(name, value)) {\r\n      logger.warn(`Critical performance metric: ${name} = ${value}ms`, { tags, metadata });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track an error event\r\n   * @param {Partial<ErrorEvent>} errorData - Error information\r\n   */\r\n  trackError(errorData: Partial<ErrorEvent>): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    // Validate error data\r\n    if (!errorData || (!errorData.message && !errorData.stack)) {\r\n      // Only log validation errors in development\r\n      if (process.env.NODE_ENV === 'development') {\r\n        logger.warn('Performance Monitor: Invalid error data provided', errorData);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const error: ErrorEvent = {\r\n      id: this.generateId(),\r\n      message: errorData.message || 'Unknown error',\r\n      stack: errorData.stack,\r\n      timestamp: Date.now(),\r\n      url: errorData.url || (typeof window !== 'undefined' ? window.location.href : ''),\r\n      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : '',\r\n      userId: errorData.userId,\r\n      context: errorData.context,\r\n      severity: errorData.severity || 'medium'\r\n    };\r\n\r\n    this.errors.push(error);\r\n    this.trimStoredItems('errors');\r\n\r\n    // Enhanced logging for development with better formatting\r\n    if (process.env.NODE_ENV === 'development') {\r\n      logger.error(`Performance Monitor - ${error.severity.toUpperCase()} Error`, {\r\n        message: error.message,\r\n        context: error.context,\r\n        stack: error.stack,\r\n        timestamp: new Date(error.timestamp).toISOString()\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track user interaction\r\n   * @param {UserInteraction} interaction - Interaction data\r\n   */\r\n  trackInteraction(interaction: UserInteraction): void {\r\n    if (!this.isEnabled) return;\r\n\r\n    this.interactions.push({\r\n      ...interaction,\r\n      timestamp: interaction.timestamp || Date.now()\r\n    });\r\n    this.trimStoredItems('interactions');\r\n  }\r\n\r\n  /**\r\n   * Track API call performance\r\n   * @param {string} endpoint - API endpoint\r\n   * @param {number} duration - Call duration in ms\r\n   * @param {boolean} success - Whether the call was successful\r\n   * @param {any} metadata - Additional metadata\r\n   */\r\n  trackApiCall(endpoint: string, duration: number, success: boolean, metadata?: any): void {\r\n    this.trackMetric('api_call_duration', duration, {\r\n      endpoint,\r\n      success: success.toString(),\r\n      type: 'api_call'\r\n    }, metadata);\r\n\r\n    if (!success) {\r\n      this.trackError({\r\n        message: `API call failed: ${endpoint}`,\r\n        severity: 'medium',\r\n        context: {\r\n          endpoint,\r\n          duration,\r\n          ...metadata\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track component render performance with throttling\r\n   * @param {string} componentName - Name of the component\r\n   * @param {number} renderTime - Render time in milliseconds\r\n   * @param {any} props - Component props for context\r\n   */\r\n  trackComponentRender(componentName: string, renderTime: number, props?: any): void {\r\n    this.trackMetric('component_render_time', renderTime, {\r\n      component: componentName,\r\n      type: 'render'\r\n    }, { props });\r\n\r\n    // Environment-aware thresholds\r\n    const thresholds = this.getEnvironmentThresholds();\r\n    const slowRenderThreshold = thresholds.componentRender;\r\n    \r\n    // Track slow renders with throttling to prevent spam\r\n    if (renderTime > slowRenderThreshold) {\r\n      const throttleKey = `slow_render_${componentName}`;\r\n      const now = Date.now();\r\n      const lastAlert = this.alertThrottleMap.get(throttleKey) || 0;\r\n      \r\n      // Only alert once every 5 seconds for the same component\r\n      if (now - lastAlert > 5000) {\r\n        this.alertThrottleMap.set(throttleKey, now);\r\n        \r\n        this.trackError({\r\n          message: `Slow component render: ${componentName}`,\r\n          severity: renderTime > slowRenderThreshold * 2 ? 'medium' : 'low',\r\n          context: {\r\n            componentName,\r\n            renderTime,\r\n            threshold: slowRenderThreshold,\r\n            environment: process.env.NODE_ENV,\r\n            props: props ? Object.keys(props) : undefined // Only log prop keys, not values\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get performance report\r\n   * @param {number} timeRange - Time range in ms (default: last hour)\r\n   * @returns {PerformanceReport} Performance report\r\n   */\r\n  getPerformanceReport(timeRange: number = 60 * 60 * 1000): PerformanceReport {\r\n    const cutoff = Date.now() - timeRange;\r\n\r\n    const recentMetrics = this.metrics.filter(m => m.timestamp >= cutoff);\r\n    const recentErrors = this.errors.filter(e => e.timestamp >= cutoff);\r\n    const recentInteractions = this.interactions.filter(i => i.timestamp >= cutoff);\r\n\r\n    const loadTimeMetrics = recentMetrics.filter(m => m.name.includes('load_time'));\r\n    const avgLoadTime = loadTimeMetrics.length > 0 \r\n      ? loadTimeMetrics.reduce((sum, m) => sum + m.value, 0) / loadTimeMetrics.length \r\n      : 0;\r\n\r\n    return {\r\n      metrics: recentMetrics,\r\n      errors: recentErrors,\r\n      interactions: recentInteractions,\r\n      summary: {\r\n        totalErrors: recentErrors.length,\r\n        avgLoadTime,\r\n        totalInteractions: recentInteractions.length,\r\n        criticalErrors: recentErrors.filter(e => e.severity === 'critical').length\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get real-time performance metrics\r\n   * @returns {object} Current performance metrics\r\n   */\r\n  getRealTimeMetrics(): object {\r\n    if (typeof window === 'undefined') return {};\r\n\r\n    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\r\n    const paint = performance.getEntriesByType('paint');\r\n\r\n    return {\r\n      // Memory usage (if available)\r\n      memory: (performance as any).memory ? {\r\n        used: (performance as any).memory.usedJSHeapSize,\r\n        total: (performance as any).memory.totalJSHeapSize,\r\n        limit: (performance as any).memory.jsHeapSizeLimit\r\n      } : null,\r\n\r\n      // Navigation timing\r\n      navigation: navigation ? {\r\n        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.fetchStart,\r\n        loadComplete: navigation.loadEventEnd - navigation.fetchStart,\r\n        firstByte: navigation.responseStart - navigation.fetchStart\r\n      } : null,\r\n\r\n      // Paint timing\r\n      paint: paint.reduce((acc, entry) => {\r\n        acc[entry.name.replace('-', '_')] = entry.startTime;\r\n        return acc;\r\n      }, {} as Record<string, number>),\r\n\r\n      // Current metrics summary\r\n      recentErrors: this.errors.slice(-10),\r\n      recentMetrics: this.metrics.slice(-20)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Enable or disable monitoring\r\n   * @param {boolean} enabled - Whether to enable monitoring\r\n   */\r\n  setEnabled(enabled: boolean): void {\r\n    this.isEnabled = enabled;\r\n    \r\n    if (!enabled && this.reportingTimer) {\r\n      clearInterval(this.reportingTimer);\r\n      this.reportingTimer = null;\r\n    } else if (enabled && !this.reportingTimer) {\r\n      this.startPeriodicReporting();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all stored data\r\n   */\r\n  clearData(): void {\r\n    this.metrics = [];\r\n    this.errors = [];\r\n    this.interactions = [];\r\n  }\r\n\r\n  /**\r\n   * Export performance data for analysis\r\n   * @returns {string} JSON string of performance data\r\n   */\r\n  exportData(): string {\r\n    return JSON.stringify({\r\n      metrics: this.metrics,\r\n      errors: this.errors,\r\n      interactions: this.interactions,\r\n      timestamp: Date.now()\r\n    }, null, 2);\r\n  }\r\n\r\n  /**\r\n   * Get environment-aware performance thresholds\r\n   * @private\r\n   */\r\n  private getEnvironmentThresholds(): Record<string, number> {\r\n    const isDevelopment = process.env.NODE_ENV === 'development';\r\n    \r\n    return {\r\n      componentRender: isDevelopment ? 50 : 16, // More lenient in dev\r\n      pageLoad: isDevelopment ? 5000 : 3000,\r\n      apiCall: isDevelopment ? 8000 : 5000,\r\n      // OPTIMIZED: Lower LCP threshold to catch issues earlier (should be < 2500ms)\r\n      largestContentfulPaint: 2500, // Same threshold for dev and prod - LCP should always be fast\r\n      firstInputDelay: isDevelopment ? 200 : 100\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if a metric indicates critical performance issue\r\n   * @private\r\n   */\r\n  private isCriticalMetric(name: string, value: number): boolean {\r\n    const thresholds = this.getEnvironmentThresholds();\r\n    const thresholdMap: Record<string, keyof typeof thresholds> = {\r\n      'page_load_time': 'pageLoad',\r\n      'api_call_duration': 'apiCall',\r\n      'component_render_time': 'componentRender',\r\n      'largest_contentful_paint': 'largestContentfulPaint',\r\n      'first_input_delay': 'firstInputDelay'\r\n    };\r\n\r\n    const thresholdKey = thresholdMap[name];\r\n    return thresholdKey ? value > thresholds[thresholdKey] : false;\r\n  }\r\n\r\n  /**\r\n   * Trim stored items to prevent memory leaks\r\n   * @private\r\n   */\r\n  private trimStoredItems(type: 'metrics' | 'errors' | 'interactions'): void {\r\n    const array = this[type];\r\n    if (array.length > this.maxStoredItems) {\r\n      array.splice(0, array.length - this.maxStoredItems);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate unique ID for errors\r\n   * @private\r\n   */\r\n  private generateId(): string {\r\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Start periodic reporting\r\n   * @private\r\n   */\r\n  private startPeriodicReporting(): void {\r\n    if (this.reportingTimer) return;\r\n\r\n    this.reportingTimer = setInterval(() => {\r\n      const report = this.getPerformanceReport();\r\n      \r\n      // Log summary for development only\r\n      if (process.env.NODE_ENV === 'development' && report.summary.totalErrors > 0) {\r\n        logger.info('Performance Report:', report.summary);\r\n      }\r\n\r\n      // In production, send critical errors to analytics service\r\n      // TODO: Integrate with error tracking service (Sentry, LogRocket, etc.)\r\n      // if (report.summary.criticalErrors > 0) {\r\n      //   this.sendToAnalytics(report);\r\n      // }\r\n      \r\n    }, this.reportingInterval);\r\n  }\r\n\r\n  /**\r\n   * Start throttle map cleanup timer to prevent unbounded growth\r\n   * @private\r\n   */\r\n  private startThrottleMapCleanup(): void {\r\n    if (this.throttleMapCleanupTimer) return;\r\n\r\n    // Clean up throttle map every 10 minutes\r\n    this.throttleMapCleanupTimer = setInterval(() => {\r\n      this.cleanupThrottleMap();\r\n    }, 10 * 60 * 1000);\r\n  }\r\n\r\n  /**\r\n   * Clean up throttle map to prevent memory leaks\r\n   * Removes old entries and limits map size\r\n   * @private\r\n   */\r\n  private cleanupThrottleMap(): void {\r\n    const now = Date.now();\r\n    const maxAge = 30 * 60 * 1000; // 30 minutes\r\n\r\n    // Remove entries older than maxAge\r\n    for (const [key, timestamp] of this.alertThrottleMap.entries()) {\r\n      if (now - timestamp > maxAge) {\r\n        this.alertThrottleMap.delete(key);\r\n      }\r\n    }\r\n\r\n    // If map is still too large, remove oldest entries\r\n    if (this.alertThrottleMap.size > this.maxThrottleMapSize) {\r\n      const entries = Array.from(this.alertThrottleMap.entries())\r\n        .sort((a, b) => a[1] - b[1]); // Sort by timestamp\r\n      \r\n      const toRemove = entries.slice(0, entries.length - this.maxThrottleMapSize);\r\n      for (const [key] of toRemove) {\r\n        this.alertThrottleMap.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up all resources and event listeners\r\n   * Call this when the service is no longer needed (e.g., during app unmount)\r\n   */\r\n  destroy(): void {\r\n    // Clear timers\r\n    if (this.reportingTimer) {\r\n      clearInterval(this.reportingTimer);\r\n      this.reportingTimer = null;\r\n    }\r\n\r\n    if (this.throttleMapCleanupTimer) {\r\n      clearInterval(this.throttleMapCleanupTimer);\r\n      this.throttleMapCleanupTimer = null;\r\n    }\r\n\r\n    // Disconnect all PerformanceObservers\r\n    for (const observer of this.performanceObservers) {\r\n      try {\r\n        observer.disconnect();\r\n      } catch (error) {\r\n        if (process.env.NODE_ENV === 'development') {\r\n          logger.warn('Error disconnecting PerformanceObserver:', error);\r\n        }\r\n      }\r\n    }\r\n    this.performanceObservers = [];\r\n\r\n    // Remove all event listeners\r\n    for (const { element, event, handler } of this.eventListeners) {\r\n      try {\r\n        element.removeEventListener(event, handler);\r\n      } catch (error) {\r\n        if (process.env.NODE_ENV === 'development') {\r\n          logger.warn('Error removing event listener:', error);\r\n        }\r\n      }\r\n    }\r\n    this.eventListeners = [];\r\n\r\n    // Clear stored data\r\n    this.clearData();\r\n    this.alertThrottleMap.clear();\r\n\r\n    // Disable monitoring\r\n    this.isEnabled = false;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const performanceMonitor = new PerformanceMonitorService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\performance.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":8,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/performance.service.ts\r\n * @description Performance monitoring and metrics collection\r\n * @created 2025-11-11\r\n */\r\n\r\n// Define LayoutShift interface for TypeScript\r\ninterface LayoutShift extends PerformanceEntry {\r\n  value: number;\r\n  hadRecentInput: boolean;\r\n}\r\n\r\nexport interface PerformanceMetrics {\r\n  // Database metrics\r\n  dbQueryTime: number;\r\n  dbQueryCount: number;\r\n  cacheHitRate: number;\r\n  \r\n  // Network metrics\r\n  apiResponseTime: number;\r\n  apiErrorRate: number;\r\n  \r\n  // UI metrics\r\n  renderTime: number;\r\n  bundleSize: number;\r\n  \r\n  // User experience\r\n  timeToInteractive: number;\r\n  firstContentfulPaint: number;\r\n}\r\n\r\nexport interface MetricEvent {\r\n  name: string;\r\n  value: number;\r\n  timestamp: number;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nclass PerformanceService {\r\n  private metrics: Map<string, MetricEvent[]> = new Map();\r\n  private startTime: number = Date.now();\r\n  private isMonitoring: boolean = false;\r\n\r\n  /**\r\n   * Start performance monitoring\r\n   */\r\n  startMonitoring(): void {\r\n    if (this.isMonitoring) return;\r\n    \r\n    this.isMonitoring = true;\r\n    this.startTime = Date.now();\r\n    \r\n    // Monitor Core Web Vitals\r\n    this.monitorCoreWebVitals();\r\n    \r\n    // Monitor memory usage\r\n    this.monitorMemoryUsage();\r\n    \r\n    // Monitor network requests\r\n    this.monitorNetworkRequests();\r\n  }\r\n\r\n  /**\r\n   * Stop performance monitoring\r\n   */\r\n  stopMonitoring(): void {\r\n    this.isMonitoring = false;\r\n  }\r\n\r\n  /**\r\n   * Record a performance metric\r\n   * @param {string} name - Metric name\r\n   * @param {number} value - Metric value\r\n   * @param {Record<string, any>} metadata - Additional metadata\r\n   */\r\n  recordMetric(name: string, value: number, metadata?: Record<string, any>): void {\r\n    const event: MetricEvent = {\r\n      name,\r\n      value,\r\n      timestamp: Date.now(),\r\n      metadata,\r\n    };\r\n\r\n    if (!this.metrics.has(name)) {\r\n      this.metrics.set(name, []);\r\n    }\r\n\r\n    this.metrics.get(name)!.push(event);\r\n\r\n    // Keep only last 1000 events per metric\r\n    const events = this.metrics.get(name)!;\r\n    if (events.length > 1000) {\r\n      events.splice(0, events.length - 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record database query time\r\n   * @param {string} query - Query name\r\n   * @param {number} duration - Query duration in ms\r\n   */\r\n  recordDbQuery(query: string, duration: number): void {\r\n    this.recordMetric('db_query_time', duration, { query });\r\n  }\r\n\r\n  /**\r\n   * Record cache hit/miss\r\n   * @param {string} key - Cache key\r\n   * @param {boolean} hit - Whether it was a cache hit\r\n   */\r\n  recordCacheHit(key: string, hit: boolean): void {\r\n    this.recordMetric('cache_operation', hit ? 1 : 0, { key, hit });\r\n  }\r\n\r\n  /**\r\n   * Record API response time\r\n   * @param {string} endpoint - API endpoint\r\n   * @param {number} duration - Response duration in ms\r\n   * @param {number} status - HTTP status code\r\n   */\r\n  recordApiResponse(endpoint: string, duration: number, status: number): void {\r\n    this.recordMetric('api_response_time', duration, { endpoint, status });\r\n    \r\n    if (status >= 400) {\r\n      this.recordMetric('api_error', 1, { endpoint, status });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get performance summary\r\n   * @returns {PerformanceMetrics} Performance metrics summary\r\n   */\r\n  getMetricsSummary(): PerformanceMetrics {\r\n    const now = Date.now();\r\n    const summary: PerformanceMetrics = {\r\n      dbQueryTime: this.getAverageMetric('db_query_time'),\r\n      dbQueryCount: this.getMetricCount('db_query_time'),\r\n      cacheHitRate: this.getCacheHitRate(),\r\n      apiResponseTime: this.getAverageMetric('api_response_time'),\r\n      apiErrorRate: this.getErrorRate(),\r\n      renderTime: this.getAverageMetric('render_time'),\r\n      bundleSize: this.getBundleSize(),\r\n      timeToInteractive: this.getAverageMetric('tti'),\r\n      firstContentfulPaint: this.getAverageMetric('fcp'),\r\n    };\r\n\r\n    return summary;\r\n  }\r\n\r\n  /**\r\n   * Get average value for a metric\r\n   * @param {string} name - Metric name\r\n   * @returns {number} Average value\r\n   */\r\n  private getAverageMetric(name: string): number {\r\n    const events = this.metrics.get(name) || [];\r\n    if (events.length === 0) return 0;\r\n\r\n    const sum = events.reduce((acc, event) => acc + event.value, 0);\r\n    return sum / events.length;\r\n  }\r\n\r\n  /**\r\n   * Get count of metric events\r\n   * @param {string} name - Metric name\r\n   * @returns {number} Event count\r\n   */\r\n  private getMetricCount(name: string): number {\r\n    return this.metrics.get(name)?.length || 0;\r\n  }\r\n\r\n  /**\r\n   * Get cache hit rate\r\n   * @returns {number} Cache hit rate (0-1)\r\n   */\r\n  private getCacheHitRate(): number {\r\n    const cacheEvents = this.metrics.get('cache_operation') || [];\r\n    if (cacheEvents.length === 0) return 0;\r\n\r\n    const hits = cacheEvents.filter(event => event.metadata?.hit).length;\r\n    return hits / cacheEvents.length;\r\n  }\r\n\r\n  /**\r\n   * Get API error rate\r\n   * @returns {number} Error rate (0-1)\r\n   */\r\n  private getErrorRate(): number {\r\n    const totalRequests = this.getMetricCount('api_response_time');\r\n    const errors = this.getMetricCount('api_error');\r\n    \r\n    if (totalRequests === 0) return 0;\r\n    return errors / totalRequests;\r\n  }\r\n\r\n  /**\r\n   * Get bundle size (estimated)\r\n   * @returns {number} Bundle size in KB\r\n   */\r\n  private getBundleSize(): number {\r\n    if (typeof window === 'undefined') return 0;\r\n    \r\n    const resources = performance.getEntriesByType('resource');\r\n    const jsResources = resources.filter((r: PerformanceEntry) =>\r\n      r.name && r.name.toString().endsWith('.js')\r\n    );\r\n    \r\n    return jsResources.reduce((acc: number, r: PerformanceEntry) => {\r\n      const resource = r as PerformanceResourceTiming;\r\n      return acc + (resource.transferSize || 0);\r\n    }, 0) / 1024;\r\n  }\r\n\r\n  /**\r\n   * Monitor Core Web Vitals\r\n   */\r\n  private monitorCoreWebVitals(): void {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // First Contentful Paint\r\n    const fcpObserver = new PerformanceObserver((list) => {\r\n      for (const entry of list.getEntries()) {\r\n        this.recordMetric('fcp', entry.startTime);\r\n      }\r\n    });\r\n    fcpObserver.observe({ entryTypes: ['paint'] });\r\n\r\n    // Largest Contentful Paint\r\n    const lcpObserver = new PerformanceObserver((list) => {\r\n      for (const entry of list.getEntries()) {\r\n        this.recordMetric('lcp', entry.startTime);\r\n      }\r\n    });\r\n    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\r\n\r\n    // First Input Delay\r\n    const fidObserver = new PerformanceObserver((list) => {\r\n      for (const entry of list.getEntries()) {\r\n        const fidEntry = entry as PerformanceEventTiming;\r\n        if (fidEntry.processingStart && fidEntry.startTime) {\r\n          this.recordMetric('fid', fidEntry.processingStart - fidEntry.startTime);\r\n        }\r\n      }\r\n    });\r\n    fidObserver.observe({ entryTypes: ['first-input'] });\r\n\r\n    // Cumulative Layout Shift\r\n    const clsObserver = new PerformanceObserver((list) => {\r\n      for (const entry of list.getEntries()) {\r\n        const clsEntry = entry as LayoutShift;\r\n        if (!clsEntry.hadRecentInput && clsEntry.value) {\r\n          this.recordMetric('cls', clsEntry.value);\r\n        }\r\n      }\r\n    });\r\n    clsObserver.observe({ entryTypes: ['layout-shift'] });\r\n\r\n    // Time to Interactive\r\n    window.addEventListener('load', () => {\r\n      const tti = performance.timing.loadEventEnd - performance.timing.navigationStart;\r\n      this.recordMetric('tti', tti);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Monitor memory usage\r\n   */\r\n  private monitorMemoryUsage(): void {\r\n    if (typeof window === 'undefined') return;\r\n    \r\n    const memory = (performance as any).memory;\r\n    if (!memory) return;\r\n\r\n    setInterval(() => {\r\n      this.recordMetric('memory_used', memory.usedJSHeapSize / 1024 / 1024); // MB\r\n      this.recordMetric('memory_total', memory.totalJSHeapSize / 1024 / 1024); // MB\r\n    }, 5000); // Check every 5 seconds\r\n  }\r\n\r\n  /**\r\n   * Monitor network requests\r\n   */\r\n  private monitorNetworkRequests(): void {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    const originalFetch = window.fetch;\r\n    window.fetch = async (...args) => {\r\n      const startTime = performance.now();\r\n      const url = (args[0] instanceof Request ? args[0].url : args[0]).toString();\r\n      \r\n      try {\r\n        const response = await originalFetch(...args);\r\n        const duration = performance.now() - startTime;\r\n        \r\n        this.recordApiResponse(url, duration, response.status);\r\n        \r\n        return response;\r\n      } catch (error) {\r\n        const duration = performance.now() - startTime;\r\n        this.recordApiResponse(url, duration, 0);\r\n        throw error;\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear old metrics\r\n   * @param {number} maxAge - Maximum age in milliseconds\r\n   */\r\n  clearOldMetrics(maxAge: number = 24 * 60 * 60 * 1000): void {\r\n    const cutoff = Date.now() - maxAge;\r\n    \r\n    for (const [name, events] of this.metrics.entries()) {\r\n      const filtered = events.filter(event => event.timestamp > cutoff);\r\n      this.metrics.set(name, filtered);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Export metrics for analysis\r\n   * @returns {Record<string, MetricEvent[]>} All metrics\r\n   */\r\n  exportMetrics(): Record<string, MetricEvent[]> {\r\n    const result: Record<string, MetricEvent[]> = {};\r\n    \r\n    for (const [name, events] of this.metrics.entries()) {\r\n      result[name] = [...events];\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const performanceService = new PerformanceService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\realtime-database.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token supabase","line":18,"column":11,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/realtime-database.service.ts\r\n * @description Real-time subscription management for database changes\r\n * @created 2025-11-12\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { Link, Folder } from '@/types';\r\nimport { SupabaseClient } from '@supabase/supabase-js';\r\nimport { performanceMonitor } from './performance-monitor.service';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\n/**\r\n * Real-time database subscription service\r\n * Manages WebSocket connections for live data updates\r\n */\r\nexport class RealtimeDatabaseService {\r\n  private supabase: SupabaseClient;\r\n  private activeChannels: Map<string, ReturnType<SupabaseClient['channel']>>;\r\n\r\n  constructor() {\r\n    this.supabase = createClient();\r\n    this.activeChannels = new Map();\r\n  }\r\n\r\n  /**\r\n   * Subscribe to link changes\r\n   * @param callback - Callback function for changes\r\n   * @returns Unsubscribe function\r\n   */\r\n  subscribeToLinks(callback: (links: Link[]) => void): () => void {\r\n    const channelName = 'links_changes';\r\n    \r\n    // Remove existing channel if it exists\r\n    this.removeChannel(channelName);\r\n\r\n    let retryCount = 0;\r\n    const maxRetries = 3;\r\n    const retryDelay = 2000;\r\n    let unsubscribeRequested = false;\r\n\r\n    const createSubscription = () => {\r\n      if (unsubscribeRequested) return;\r\n      \r\n      const channel = this.supabase\r\n        .channel(channelName, {\r\n          config: {\r\n            presence: {\r\n              key: 'user_id',\r\n            },\r\n          },\r\n        })\r\n        .on(\r\n          'postgres_changes',\r\n          {\r\n            event: '*',\r\n            schema: 'public',\r\n            table: 'links',\r\n          },\r\n          async (payload) => {\r\n            try {\r\n              // Import links service dynamically to avoid circular dependencies\r\n              const { linksDatabaseService } = await import('./links-database.service');\r\n              \r\n              // Refetch all links when any change occurs\r\n              const links = await linksDatabaseService.getLinks();\r\n              \r\n              // Add small delay to prevent overwhelming the UI\r\n              setTimeout(() => {\r\n                callback(links);\r\n              }, 50);\r\n\r\n            } catch (error) {\r\n              logger.error('Error handling realtime link changes:', {\r\n                error: error instanceof Error ? error.message : 'Unknown error',\r\n                eventType: payload.eventType,\r\n                table: payload.table,\r\n                timestamp: new Date().toISOString()\r\n              });\r\n              performanceMonitor.trackError({\r\n                message: `Realtime link change error: ${(error as Error).message}`,\r\n                severity: 'medium',\r\n                context: { event: payload.eventType, table: 'links' }\r\n              });\r\n            }\r\n          }\r\n        )\r\n        .on('system', {}, (payload) => {\r\n          if (payload.status === 'CHANNEL_ERROR') {\r\n            logger.error('Realtime channel error for links:', payload);\r\n            performanceMonitor.trackError({\r\n              message: 'Realtime channel error',\r\n              severity: 'high',\r\n              context: { channel: 'links', payload }\r\n            });\r\n          }\r\n        })\r\n        .subscribe((status) => {\r\n          if (status === 'SUBSCRIBED') {\r\n            logger.debug('Successfully subscribed to links changes');\r\n            retryCount = 0;\r\n          } else if (status === 'CHANNEL_ERROR') {\r\n            logger.error('Failed to subscribe to links changes');\r\n            \r\n            // Retry connection with exponential backoff\r\n            if (retryCount < maxRetries && !unsubscribeRequested) {\r\n              retryCount++;\r\n              const delay = retryDelay * Math.pow(2, retryCount - 1);\r\n              logger.debug(`Retrying links subscription in ${delay}ms (attempt ${retryCount}/${maxRetries})`);\r\n              \r\n              setTimeout(() => {\r\n                if (this.activeChannels.has(channelName) && !unsubscribeRequested) {\r\n                  this.removeChannel(channelName);\r\n                  createSubscription();\r\n                }\r\n              }, delay);\r\n            } else {\r\n              logger.error('Max retries reached for links subscription');\r\n              performanceMonitor.trackError({\r\n                message: 'Links subscription failed after max retries',\r\n                severity: 'high',\r\n                context: { maxRetries, channelName }\r\n              });\r\n            }\r\n          } else if (status === 'CLOSED') {\r\n            logger.debug('Links subscription closed');\r\n          }\r\n        });\r\n\r\n      this.activeChannels.set(channelName, channel);\r\n    };\r\n\r\n    createSubscription();\r\n\r\n    return () => {\r\n      unsubscribeRequested = true;\r\n      this.removeChannel(channelName);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Subscribe to folder changes\r\n   * @param callback - Callback function for changes\r\n   * @returns Unsubscribe function\r\n   */\r\n  subscribeToFolders(callback: (folders: Folder[]) => void): () => void {\r\n    const channelName = 'folders_changes';\r\n\r\n    // Remove existing channel if it exists\r\n    this.removeChannel(channelName);\r\n\r\n    let retryCount = 0;\r\n    const maxRetries = 3;\r\n    const retryDelay = 2000;\r\n    let unsubscribeRequested = false;\r\n\r\n    const createSubscription = () => {\r\n      if (unsubscribeRequested) return;\r\n      \r\n      const channel = this.supabase\r\n        .channel(channelName, {\r\n          config: {\r\n            presence: {\r\n              key: 'user_id',\r\n            },\r\n          },\r\n        })\r\n        .on(\r\n          'postgres_changes',\r\n          {\r\n            event: '*',\r\n            schema: 'public',\r\n            table: 'folders',\r\n          },\r\n          async (payload) => {\r\n            try {\r\n              // Import folders service dynamically to avoid circular dependencies\r\n              const { foldersDatabaseService } = await import('./folders-database.service');\r\n              \r\n              // Refetch all folders when any change occurs\r\n              const folders = await foldersDatabaseService.getFolders();\r\n              callback(folders);\r\n            } catch (error) {\r\n              logger.error('Error handling realtime folder changes:', error);\r\n              performanceMonitor.trackError({\r\n                message: `Realtime folder change error: ${(error as Error).message}`,\r\n                severity: 'medium',\r\n                context: { event: payload.eventType, table: 'folders' }\r\n              });\r\n            }\r\n          }\r\n        )\r\n        .on('system', {}, (payload) => {\r\n          if (payload.status === 'CHANNEL_ERROR') {\r\n            logger.error('Realtime channel error for folders:', payload);\r\n            performanceMonitor.trackError({\r\n              message: 'Realtime channel error',\r\n              severity: 'high',\r\n              context: { channel: 'folders', payload }\r\n            });\r\n          }\r\n        })\r\n        .subscribe((status) => {\r\n          if (status === 'SUBSCRIBED') {\r\n            logger.debug('Successfully subscribed to folders changes');\r\n            retryCount = 0;\r\n          } else if (status === 'CHANNEL_ERROR') {\r\n            logger.error('Failed to subscribe to folders changes');\r\n            \r\n            // Retry connection with exponential backoff\r\n            if (retryCount < maxRetries && !unsubscribeRequested) {\r\n              retryCount++;\r\n              const delay = retryDelay * Math.pow(2, retryCount - 1);\r\n              logger.debug(`Retrying folders subscription in ${delay}ms (attempt ${retryCount}/${maxRetries})`);\r\n              \r\n              setTimeout(() => {\r\n                if (this.activeChannels.has(channelName) && !unsubscribeRequested) {\r\n                  this.removeChannel(channelName);\r\n                  createSubscription();\r\n                }\r\n              }, delay);\r\n            } else {\r\n              logger.error('Max retries reached for folders subscription');\r\n              performanceMonitor.trackError({\r\n                message: 'Folders subscription failed after max retries',\r\n                severity: 'high',\r\n                context: { maxRetries, channelName }\r\n              });\r\n            }\r\n          } else if (status === 'CLOSED') {\r\n            logger.debug('Folders subscription closed');\r\n          }\r\n        });\r\n\r\n      this.activeChannels.set(channelName, channel);\r\n    };\r\n\r\n    createSubscription();\r\n\r\n    return () => {\r\n      unsubscribeRequested = true;\r\n      this.removeChannel(channelName);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Remove a specific channel\r\n   * @param channelName - Name of the channel to remove\r\n   */\r\n  private removeChannel(channelName: string): void {\r\n    if (this.activeChannels.has(channelName)) {\r\n      const channel = this.activeChannels.get(channelName);\r\n      try {\r\n        if (channel) {\r\n          this.supabase.removeChannel(channel);\r\n        }\r\n      } catch (error) {\r\n        logger.warn(`Error removing channel ${channelName}:`, error);\r\n      }\r\n      this.activeChannels.delete(channelName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from all active channels\r\n   */\r\n  unsubscribeAll(): void {\r\n    try {\r\n      logger.debug(`Unsubscribing from ${this.activeChannels.size} active channels`);\r\n      \r\n      for (const [channelName, channel] of this.activeChannels.entries()) {\r\n        try {\r\n          this.supabase.removeChannel(channel);\r\n          logger.debug(`Removed channel: ${channelName}`);\r\n        } catch (error) {\r\n          logger.warn(`Error removing channel ${channelName}:`, error);\r\n        }\r\n      }\r\n      \r\n      this.activeChannels.clear();\r\n    } catch (error) {\r\n      logger.error('Error unsubscribing from all channels:', error);\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const realtimeDatabaseService = new RealtimeDatabaseService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\session-recovery.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":18,"column":39,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/session-recovery.service.ts\r\n * @description Simplified session recovery logic for authentication\r\n * @created 2025-01-21\r\n */\r\n\r\nimport { authService } from '@/lib/services/auth';\r\nimport { AuthUser } from '@/lib/types/auth';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport { AUTH_CONSTANTS } from '@/constants/auth.constants';\r\n\r\n/**\r\n * Attempts to recover an existing user session\r\n * Uses a simplified 1 primary + 1 fallback strategy instead of the previous 3 strategies\r\n * \r\n * @returns {Promise<AuthUser | null>} The authenticated user or null if no session exists\r\n */\r\nexport async function recoverSession(): Promise<AuthUser | null> {\r\n    try {\r\n        // OPTIMIZATION: Skip session recovery on login page - no session expected\r\n        if (typeof window !== 'undefined' && window.location.pathname.startsWith('/login')) {\r\n            logger.debug('Skipping session recovery on login page');\r\n            return null;\r\n        }\r\n\r\n        // OPTIMIZATION: Skip if user recently logged out\r\n        if (typeof window !== 'undefined') {\r\n            const logoutMarker = localStorage.getItem('user_logged_out') || sessionStorage.getItem('user_logged_out');\r\n            if (logoutMarker) {\r\n                const logoutTime = parseInt(logoutMarker);\r\n                const now = Date.now();\r\n\r\n                if (now - logoutTime < AUTH_CONSTANTS.POST_LOGOUT_COOLDOWN) {\r\n                    logger.debug('Skipping session recovery - user recently logged out');\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n\r\n        // PRIMARY STRATEGY: Get session from Supabase with retry\r\n        const maxRetries = AUTH_CONSTANTS.MAX_RETRIES;\r\n        let lastError: any = null;\r\n\r\n        for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n            try {\r\n                const { data: { session }, error } = await authService.getSupabaseClient().auth.getSession();\r\n\r\n                if (!error && session?.user) {\r\n                    logger.debug(`Session recovered successfully (attempt ${attempt + 1})`);\r\n                    const user = await authService.getCurrentUser();\r\n                    return user;\r\n                }\r\n\r\n                lastError = error;\r\n\r\n                // Wait before retry\r\n                if (attempt < maxRetries - 1) {\r\n                    await new Promise(resolve => setTimeout(resolve, AUTH_CONSTANTS.RETRY_DELAY));\r\n                }\r\n            } catch (err) {\r\n                lastError = err;\r\n                logger.warn(`Session recovery attempt ${attempt + 1} failed:`, err);\r\n\r\n                if (attempt < maxRetries - 1) {\r\n                    await new Promise(resolve => setTimeout(resolve, AUTH_CONSTANTS.RETRY_DELAY));\r\n                }\r\n            }\r\n        }\r\n\r\n        // FALLBACK STRATEGY: Try getUser() as last resort\r\n        if (lastError) {\r\n            logger.debug('Primary session recovery failed, trying fallback');\r\n            try {\r\n                const { data: { user }, error } = await authService.getSupabaseClient().auth.getUser();\r\n\r\n                if (!error && user) {\r\n                    logger.debug('Session recovered via fallback strategy');\r\n                    return user;\r\n                }\r\n            } catch (fallbackError) {\r\n                logger.debug('Fallback session recovery also failed:', fallbackError);\r\n            }\r\n        }\r\n\r\n        // No session found - this is expected after logout or on login page\r\n        logger.debug('No session to recover - user needs to sign in');\r\n        return null;\r\n\r\n    } catch (error) {\r\n        logger.error('Session recovery error:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Validates if a session is still active\r\n * @returns {Promise<boolean>} True if session is valid\r\n */\r\nexport async function validateSession(): Promise<boolean> {\r\n    try {\r\n        const { data: { session }, error } = await authService.getSupabaseClient().auth.getSession();\r\n        return !error && !!session;\r\n    } catch (error) {\r\n        logger.error('Session validation error:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Mark that user has logged out to prevent automatic session recovery\r\n */\r\nexport function markUserLoggedOut(): void {\r\n    if (typeof window !== 'undefined') {\r\n        const timestamp = Date.now().toString();\r\n        localStorage.setItem('user_logged_out', timestamp);\r\n        sessionStorage.setItem('user_logged_out', timestamp);\r\n        logger.debug('User marked as logged out');\r\n    }\r\n}\r\n\r\n/**\r\n * Clear the logout marker (called on successful login)\r\n */\r\nexport function clearLogoutMarker(): void {\r\n    if (typeof window !== 'undefined') {\r\n        localStorage.removeItem('user_logged_out');\r\n        sessionStorage.removeItem('user_logged_out');\r\n        logger.debug('Logout marker cleared');\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\settings-database.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token supabase","line":23,"column":11,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/settings-database.service.ts\r\n * @description Database operations specifically for user settings\r\n * @created 2025-11-12\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { AppSettings } from '@/types';\r\nimport { SupabaseClient } from '@supabase/supabase-js';\r\nimport { globalCache, CACHE_CONFIGS } from './cache-manager';\r\nimport { isAppSettings } from '@/lib/utils/type-guards';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport {\r\n  DatabaseError,\r\n  AuthenticationError,\r\n} from '@/lib/errors/app-error';\r\n\r\n/**\r\n * Settings-specific database operations\r\n * Focused on user settings management with caching\r\n */\r\nexport class SettingsDatabaseService {\r\n  private supabase: SupabaseClient;\r\n\r\n  constructor() {\r\n    this.supabase = createClient();\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for user-specific data\r\n   */\r\n  private getCacheKey(userId: string): string {\r\n    return `${userId}:settings:get`;\r\n  }\r\n\r\n  /**\r\n   * Invalidate settings-related caches\r\n   */\r\n  private invalidateUserCache(userId: string): void {\r\n    globalCache.invalidateByTags(['settings', `user:${userId}`]);\r\n  }\r\n\r\n  /**\r\n   * Get user settings\r\n   */\r\n  async getSettings(): Promise<AppSettings | null> {\r\n    const { data: { user } } = await this.supabase.auth.getUser();\r\n    if (!user) {\r\n      throw new AuthenticationError('User not authenticated');\r\n    }\r\n\r\n    const cacheKey = this.getCacheKey(user.id);\r\n\r\n    // Check cache first\r\n    const cached = globalCache.get<AppSettings | null>(cacheKey);\r\n    if (cached !== null) {\r\n      return cached;\r\n    }\r\n\r\n    try {\r\n      const queryPromise = this.supabase\r\n        .from('user_settings')\r\n        .select('*')\r\n        .eq('user_id', user.id)\r\n        .single();\r\n\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Settings query timeout')), 5000)\r\n      );\r\n\r\n      const { data, error } = await Promise.race([queryPromise, timeoutPromise]);\r\n\r\n      if (error) {\r\n        if (error.code === 'PGRST116') return null; // Settings don't exist yet\r\n        throw error;\r\n      }\r\n\r\n      if (!data) {\r\n        return null;\r\n      }\r\n\r\n      const settings: AppSettings = {\r\n        theme: data.theme as 'light' | 'dark' | 'system',\r\n      };\r\n\r\n      if (!isAppSettings(settings)) {\r\n        logger.warn('Invalid settings data received:', data);\r\n        return null;\r\n      }\r\n\r\n      // Cache the result\r\n      globalCache.set(cacheKey, settings, { ...CACHE_CONFIGS.USER_SETTINGS, tags: [...CACHE_CONFIGS.USER_SETTINGS.tags] });\r\n\r\n      return settings;\r\n    } catch (error) {\r\n      logger.error('Error fetching settings:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update user settings\r\n   */\r\n  async updateSettings(settings: Partial<AppSettings>): Promise<AppSettings> {\r\n    let userId = 'unknown';\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n      userId = user.id;\r\n\r\n      this.invalidateUserCache(user.id);\r\n\r\n      const updateData: {\r\n        user_id: string;\r\n        theme?: string;\r\n      } = {\r\n        user_id: user.id,\r\n      };\r\n\r\n      if (settings.theme !== undefined) updateData.theme = settings.theme;\r\n\r\n      // Use proper upsert with conflict resolution\r\n      const { data, error } = await this.supabase\r\n        .from('user_settings')\r\n        .upsert(updateData, {\r\n          onConflict: 'user_id',\r\n          ignoreDuplicates: false\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        // If still getting constraint error, try update instead\r\n        if (error.code === '23505') {\r\n          const { data: updateDataResult, error: updateError } = await this.supabase\r\n            .from('user_settings')\r\n            .update({\r\n              theme: settings.theme,\r\n            })\r\n            .eq('user_id', user.id)\r\n            .select()\r\n            .single();\r\n\r\n          if (updateError) {\r\n            throw new DatabaseError('Failed to update settings', { userId: user.id }, updateError as Error);\r\n          }\r\n          if (!updateDataResult) {\r\n            throw new DatabaseError('Failed to update settings - no data returned', { userId: user.id });\r\n          }\r\n\r\n          const result: AppSettings = {\r\n            theme: updateDataResult.theme as 'light' | 'dark' | 'system',\r\n          };\r\n\r\n          if (!isAppSettings(result)) {\r\n            throw new DatabaseError('Invalid settings data received', { userId: user.id });\r\n          }\r\n\r\n          return result;\r\n        }\r\n        throw new DatabaseError('Failed to update settings', { userId: user.id }, error as Error);\r\n      }\r\n\r\n      if (!data) {\r\n        throw new DatabaseError('Failed to update settings - no data returned', { userId: user.id });\r\n      }\r\n\r\n      const result: AppSettings = {\r\n        theme: data.theme as 'light' | 'dark' | 'system',\r\n      };\r\n\r\n      if (!isAppSettings(result)) {\r\n        throw new DatabaseError('Invalid settings data received', { userId: user.id });\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to update settings', { userId }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete user settings\r\n   */\r\n  async deleteUserSettings(): Promise<void> {\r\n    const { data: { user }, error: authError } = await this.supabase.auth.getUser();\r\n    if (authError || !user) throw new Error('User not authenticated');\r\n\r\n    const { error } = await this.supabase\r\n      .from('user_settings')\r\n      .delete()\r\n      .eq('user_id', user.id);\r\n\r\n    if (error) throw error;\r\n\r\n    // Clear cache after mutation\r\n    this.invalidateUserCache(user.id);\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const settingsDatabaseService = new SettingsDatabaseService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\services\\supabase-database.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token supabase","line":42,"column":11,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/services/supabase-database.service.ts\r\n * @description Enhanced Supabase database service with smart caching and performance optimizations\r\n * @created 2025-11-02\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { Link, Folder, AppSettings, Platform } from '@/types';\r\nimport { SupabaseClient } from '@supabase/supabase-js';\r\nimport { globalCache, CACHE_CONFIGS, CacheOptions } from './cache-manager';\r\nimport { performanceMonitor } from './performance-monitor.service';\r\nimport {\r\n  DatabaseError,\r\n  AuthenticationError,\r\n  NotFoundError,\r\n  ValidationError,\r\n} from '@/lib/errors/app-error';\r\nimport {\r\n  DatabaseLink,\r\n  DatabaseFolder,\r\n  LinkUpdateData,\r\n  FolderUpdateData,\r\n  BatchRequest,\r\n  RequestQueueEntry,\r\n} from '@/lib/types/database';\r\nimport {\r\n  isLink,\r\n  isFolder,\r\n  isLinkArray,\r\n  isFolderArray,\r\n  isAppSettings,\r\n} from '@/lib/utils/type-guards';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport { debounce } from 'lodash';\r\nimport { databaseDebug } from '@/lib/services/database-debug.service';\r\n\r\n/**\r\n * Enhanced Supabase Database Service\r\n * Provides CRUD operations with smart caching, request deduplication, and performance optimizations\r\n */\r\nexport class SupabaseDatabaseService {\r\n  private supabase: SupabaseClient;\r\n  private pendingRequests: Map<string, Promise<unknown>>;\r\n  private activeChannels: Map<string, ReturnType<SupabaseClient['channel']>>;\r\n  private requestQueue: Map<string, RequestQueueEntry<unknown>[]>;\r\n\r\n  constructor() {\r\n    this.supabase = createClient();\r\n    this.pendingRequests = new Map();\r\n    this.activeChannels = new Map();\r\n    this.requestQueue = new Map();\r\n  }\r\n\r\n  /**\r\n   * Enhanced request deduplication with smart caching\r\n   * @param {string} key - Unique key for the request\r\n   * @param {Function} fn - Function to execute\r\n   * @param {CacheOptions} cacheOptions - Cache configuration\r\n   * @returns {Promise<T>} - Result of the function\r\n   */\r\n  private async dedupeRequest<T>(\r\n    key: string,\r\n    fn: () => Promise<T>,\r\n    cacheOptions?: CacheOptions\r\n  ): Promise<T> {\r\n    // Check cache first\r\n    const cached = globalCache.get<T>(key);\r\n    if (cached !== null) {\r\n      return cached;\r\n    }\r\n\r\n    // Check if request is already pending\r\n    if (this.pendingRequests.has(key)) {\r\n      return this.pendingRequests.get(key) as Promise<T>;\r\n    }\r\n\r\n    // Execute new request\r\n    const promise = fn()\r\n      .then((result) => {\r\n        // Cache the result with smart configuration\r\n        if (cacheOptions) {\r\n          globalCache.set(key, result, cacheOptions);\r\n        }\r\n        return result;\r\n      })\r\n      .catch((error) => {\r\n        // Don't cache errors, but log them\r\n        logger.error(`Request failed for key ${key}:`, error);\r\n        throw error;\r\n      })\r\n      .finally(() => {\r\n        // Clean up pending request\r\n        this.pendingRequests.delete(key);\r\n      });\r\n\r\n    this.pendingRequests.set(key, promise);\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * Batch multiple requests for parallel execution\r\n   * @param {Array} requests - Array of request configurations\r\n   * @returns {Promise<T[]>} - Results of all requests\r\n   */\r\n  private async batchRequests<T>(requests: BatchRequest<T>[]): Promise<T[]> {\r\n    const promises = requests.map(({ key, fn, cacheOptions }) =>\r\n      this.dedupeRequest<T>(key, fn, cacheOptions)\r\n    );\r\n\r\n    return Promise.all(promises);\r\n  }\r\n\r\n  /**\r\n   * Invalidate related caches when data changes\r\n   * @param {string[]} tags - Cache tags to invalidate\r\n   */\r\n  private invalidateCache(tags: string[]): void {\r\n    globalCache.invalidateByTags(tags);\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for user-specific data\r\n   * @param {string} userId - User ID\r\n   * @param {string} operation - Operation name\r\n   * @param {string} params - Additional parameters\r\n   * @returns {string} Cache key\r\n   */\r\n  private getCacheKey(userId: string, operation: string, params?: string): string {\r\n    return `${userId}:${operation}${params ? `:${params}` : ''}`;\r\n  }\r\n\r\n  // ============================================\r\n  // LINK OPERATIONS\r\n  // ============================================\r\n\r\n  /**\r\n   * Get all links for current user (including deleted ones for trash functionality)\r\n   * OPTIMIZED: Uses composite index (user_id, deleted_at, created_at DESC)\r\n   * @param {Object} options - Query options\r\n   * @param {number} options.limit - Maximum number of links to fetch (default: 1000)\r\n   * @param {number} options.offset - Offset for pagination (default: 0)\r\n   * @returns {Promise<Link[]>} Array of links\r\n   */\r\n  async getLinks(options: { limit?: number; offset?: number } = {}): Promise<Link[]> {\r\n    const { data: { user } } = await this.supabase.auth.getUser();\r\n    if (!user) {\r\n      throw new AuthenticationError('User not authenticated');\r\n    }\r\n\r\n    const { limit = 1000, offset = 0 } = options;\r\n    const cacheKey = this.getCacheKey(user.id, 'links', `limit:${limit}:offset:${offset}`);\r\n\r\n    const queryId = databaseDebug.logQuery({\r\n      operation: 'getLinks',\r\n      queryType: 'select',\r\n      cacheHit: false, // Will be updated if cache is used\r\n      dataSize: limit,\r\n      metadata: { userId: user.id, limit, offset }\r\n    });\r\n\r\n    return this.dedupeRequest(cacheKey, async () => {\r\n      try {\r\n        // ENHANCED: Add timeout protection to prevent hanging queries\r\n        const queryPromise = this.supabase\r\n          .from('links')\r\n          .select('*')\r\n          .eq('user_id', user.id)\r\n          .order('created_at', { ascending: false })\r\n          .range(offset, offset + limit - 1);\r\n\r\n        // Race against timeout\r\n        const timeoutPromise = new Promise<never>((_, reject) =>\r\n          setTimeout(() => reject(new Error('Links query timeout')), 15000)\r\n        );\r\n\r\n        const { data, error } = await Promise.race([queryPromise, timeoutPromise]);\r\n\r\n        if (error) {\r\n          databaseDebug.markComplete(queryId, false, error.message);\r\n          throw new DatabaseError('Failed to fetch links', { userId: user.id }, error as Error);\r\n        }\r\n\r\n        if (!data) {\r\n          databaseDebug.markComplete(queryId, true);\r\n          return [];\r\n        }\r\n\r\n        // Validate and transform database schema to app schema\r\n        const links = data.map((dbLink: DatabaseLink) => {\r\n          const link = this.transformLinkFromDB(dbLink);\r\n          if (!isLink(link)) {\r\n            logger.warn('Invalid link data received:', dbLink);\r\n            return null;\r\n          }\r\n          return link;\r\n        }).filter((link): link is Link => link !== null);\r\n\r\n        databaseDebug.markComplete(queryId, true);\r\n        return links;\r\n      } catch (error) {\r\n        logger.error('Error fetching links:', error);\r\n        databaseDebug.markComplete(queryId, false, error instanceof Error ? error.message : 'Unknown error');\r\n        if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n          throw error;\r\n        }\r\n        throw new DatabaseError('Failed to fetch links', { userId: user.id }, error as Error);\r\n      }\r\n    }, { ...CACHE_CONFIGS.LINKS, tags: [...CACHE_CONFIGS.LINKS.tags] });\r\n  }\r\n\r\n  /**\r\n   * Add a new link\r\n   * @param {Omit<Link, 'id' | 'createdAt' | 'updatedAt'>} link - Link data\r\n   * @returns {Promise<Link>} Created link\r\n   */\r\n  async addLink(link: Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>): Promise<Link> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n\r\n      const linkData = {\r\n        user_id: user.id,\r\n        url: link.url,\r\n        title: link.title,\r\n        description: link.description || null,\r\n        thumbnail: link.thumbnail || null,\r\n        platform: link.platform,\r\n        folder_id: link.folderId || null,\r\n        is_favorite: link.isFavorite || false,\r\n        tags: link.tags || [],\r\n        favicon_url: link.faviconUrl || null,\r\n        is_archived: false,\r\n        click_count: 0,\r\n        last_clicked_at: null,\r\n        deleted_at: null,\r\n      };\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('links')\r\n        .insert(linkData)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to create link', { linkData }, error as Error);\r\n      }\r\n      if (!data) {\r\n        throw new DatabaseError('Failed to create link - no data returned', { linkData });\r\n      }\r\n\r\n      const createdLink = this.transformLinkFromDB(data);\r\n      if (!isLink(createdLink)) {\r\n        throw new DatabaseError('Invalid link data received from database', { linkId: data.id });\r\n      }\r\n      return createdLink;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError || error instanceof NotFoundError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to add link', { link }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update an existing link\r\n   * @param {string} id - Link ID\r\n   * @param {Partial<Link>} updates - Fields to update\r\n   * @returns {Promise<Link>} Updated link\r\n   */\r\n  async updateLink(id: string, updates: Partial<Link>): Promise<Link> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n\r\n      const updateData: LinkUpdateData = {};\r\n\r\n      if (updates.title !== undefined) updateData.title = updates.title;\r\n      if (updates.description !== undefined) updateData.description = updates.description;\r\n      if (updates.url !== undefined) updateData.url = updates.url;\r\n      if (updates.thumbnail !== undefined) updateData.thumbnail = updates.thumbnail;\r\n      if (updates.faviconUrl !== undefined) updateData.favicon_url = updates.faviconUrl;\r\n      if (updates.platform !== undefined) updateData.platform = updates.platform;\r\n      if (updates.folderId !== undefined) updateData.folder_id = updates.folderId;\r\n      if (updates.isFavorite !== undefined) updateData.is_favorite = updates.isFavorite;\r\n      if (updates.tags !== undefined) updateData.tags = updates.tags;\r\n      if (updates.deletedAt !== undefined) updateData.deleted_at = updates.deletedAt;\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('links')\r\n        .update(updateData)\r\n        .eq('id', id)\r\n        .eq('user_id', user.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to update link', { linkId: id }, error as Error);\r\n      }\r\n      if (!data) {\r\n        throw new NotFoundError('Link', id);\r\n      }\r\n\r\n      const link = this.transformLinkFromDB(data);\r\n      if (!isLink(link)) {\r\n        throw new DatabaseError('Invalid link data received from database', { linkId: data.id });\r\n      }\r\n      return link;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError || error instanceof NotFoundError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to update link', { linkId: id, updates }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Soft delete a link (move to trash)\r\n   * @param {string} id - Link ID\r\n   */\r\n  async deleteLink(id: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .update({ deleted_at: new Date().toISOString() })\r\n        .eq('id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to delete link', { linkId: id }, error as Error);\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to delete link', { linkId: id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore a link from trash\r\n   * @param {string} id - Link ID\r\n   */\r\n  async restoreLink(id: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .update({ deleted_at: null })\r\n        .eq('id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to restore link', { linkId: id }, error as Error);\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to restore link', { linkId: id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Permanently delete a link\r\n   * @param {string} id - Link ID\r\n   */\r\n  async permanentlyDeleteLink(id: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to permanently delete link', { linkId: id }, error as Error);\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to permanently delete link', { linkId: id }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Empty trash (permanently delete all trashed links)\r\n   */\r\n  async emptyTrash(): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .delete()\r\n        .eq('user_id', user.id)\r\n        .not('deleted_at', 'is', null);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to empty trash', { userId: user.id }, error as Error);\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to empty trash', {}, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore all links from trash\r\n   */\r\n  async restoreAllFromTrash(): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .update({ deleted_at: null })\r\n        .eq('user_id', user.id)\r\n        .not('deleted_at', 'is', null);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to restore all from trash', { userId: user.id }, error as Error);\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to restore all from trash', {}, error as Error);\r\n    }\r\n  }\r\n\r\n  // ============================================\r\n  // FOLDER OPERATIONS\r\n  // ============================================\r\n\r\n  /**\r\n   * Get all folders for current user\r\n   * OPTIMIZED: Uses composite index (user_id, parent_id, deleted_at)\r\n   * @param {Object} options - Query options\r\n   * @param {number} options.limit - Maximum number of folders to fetch (default: 500)\r\n   * @returns {Promise<Folder[]>} Array of folders\r\n   */\r\n  async getFolders(options: { limit?: number } = {}): Promise<Folder[]> {\r\n    const { data: { user } } = await this.supabase.auth.getUser();\r\n    if (!user) {\r\n      throw new AuthenticationError('User not authenticated');\r\n    }\r\n\r\n    const { limit = 500 } = options;\r\n    const cacheKey = this.getCacheKey(user.id, 'folders', `limit:${limit}`);\r\n\r\n    return this.dedupeRequest(cacheKey, async () => {\r\n      try {\r\n        // ENHANCED: Add timeout protection to prevent hanging queries\r\n        const queryPromise = this.supabase\r\n          .from('folders')\r\n          .select('*')\r\n          .eq('user_id', user.id)\r\n          .order('created_at', { ascending: true })\r\n          .limit(limit);\r\n\r\n        // Race against timeout\r\n        const timeoutPromise = new Promise<never>((_, reject) =>\r\n          setTimeout(() => reject(new Error('Folders query timeout')), 10000)\r\n        );\r\n\r\n        const { data, error } = await Promise.race([queryPromise, timeoutPromise]);\r\n\r\n        if (error) {\r\n          throw new DatabaseError('Failed to fetch folders', { userId: user.id }, error as Error);\r\n        }\r\n\r\n        if (!data) {\r\n          return [];\r\n        }\r\n\r\n        // Validate and transform database schema to app schema\r\n        const folders = data.map((dbFolder: DatabaseFolder) => {\r\n          const folder = this.transformFolderFromDB(dbFolder);\r\n          if (!isFolder(folder)) {\r\n            logger.warn('Invalid folder data received:', dbFolder);\r\n            return null;\r\n          }\r\n          return folder;\r\n        }).filter((folder): folder is Folder => folder !== null);\r\n\r\n        return folders;\r\n      } catch (error) {\r\n        logger.error('Error fetching folders:', error);\r\n        if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n          throw error;\r\n        }\r\n        throw new DatabaseError('Failed to fetch folders', { userId: user.id }, error as Error);\r\n      }\r\n    }, { ...CACHE_CONFIGS.FOLDERS, tags: [...CACHE_CONFIGS.FOLDERS.tags] });\r\n  }\r\n\r\n  /**\r\n   * Add a new folder\r\n   * @param {Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>} folder - Folder data\r\n   * @returns {Promise<Folder>} Created folder\r\n   */\r\n  async addFolder(folder: Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>): Promise<Folder> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['folders', `user:${user.id}`]);\r\n\r\n      const folderData = {\r\n        user_id: user.id,\r\n        name: folder.name,\r\n        description: folder.description || null,\r\n        color: folder.color,\r\n        icon: folder.icon,\r\n        parent_id: folder.parentId || null,\r\n        is_platform_folder: folder.isPlatformFolder || false,\r\n        platform: folder.platform || null,\r\n        is_default: false,\r\n      };\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('folders')\r\n        .insert(folderData)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        // OPTIMIZED: Handle duplicate folder name error (409 Conflict)\r\n        if (error.code === '23505' || error.message?.includes('duplicate') || error.message?.includes('unique')) {\r\n          throw new DatabaseError('A folder with this name already exists', { folderData }, error as Error);\r\n        }\r\n        throw new DatabaseError('Failed to create folder', { folderData }, error as Error);\r\n      }\r\n      if (!data) {\r\n        throw new DatabaseError('Failed to create folder - no data returned', { folderData });\r\n      }\r\n\r\n      const createdFolder = this.transformFolderFromDB(data);\r\n      if (!isFolder(createdFolder)) {\r\n        throw new DatabaseError('Invalid folder data received from database', { folderId: data.id });\r\n      }\r\n      return createdFolder;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError || error instanceof NotFoundError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to add folder', { folderData: folder }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update an existing folder\r\n   * @param {string} id - Folder ID\r\n   * @param {Partial<Folder>} updates - Fields to update\r\n   * @returns {Promise<Folder>} Updated folder\r\n   */\r\n  async updateFolder(id: string, updates: Partial<Folder>): Promise<Folder> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      const updateData: FolderUpdateData = {};\r\n\r\n      if (updates.name !== undefined) updateData.name = updates.name;\r\n      if (updates.description !== undefined) updateData.description = updates.description;\r\n      if (updates.color !== undefined) updateData.color = updates.color;\r\n      if (updates.icon !== undefined) updateData.icon = updates.icon;\r\n      if (updates.parentId !== undefined) updateData.parent_id = updates.parentId;\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('folders')\r\n        .update(updateData)\r\n        .eq('id', id)\r\n        .eq('user_id', user.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to update folder', { folderId: id }, error as Error);\r\n      }\r\n      if (!data) {\r\n        throw new NotFoundError('Folder', id);\r\n      }\r\n\r\n      const folder = this.transformFolderFromDB(data);\r\n      if (!isFolder(folder)) {\r\n        throw new DatabaseError('Invalid folder data received from database', { folderId: data.id });\r\n      }\r\n      return folder;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError || error instanceof NotFoundError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to update folder', { folderId: id, updates }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a folder\r\n   * @param {string} id - Folder ID\r\n   */\r\n  async deleteFolder(id: string): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['folders', `user:${user.id}`]);\r\n\r\n      // First, set folder_id to null for all links in this folder\r\n      const { error: linksError } = await this.supabase\r\n        .from('links')\r\n        .update({ folder_id: null })\r\n        .eq('folder_id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (linksError) {\r\n        throw new DatabaseError('Failed to update links before folder deletion', { folderId: id }, linksError as Error);\r\n      }\r\n\r\n      // Then delete the folder\r\n      const { error } = await this.supabase\r\n        .from('folders')\r\n        .delete()\r\n        .eq('id', id)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to delete folder', { folderId: id }, error as Error);\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to delete folder', { folderId: id }, error as Error);\r\n    }\r\n  }\r\n\r\n  // ============================================\r\n  // SETTINGS OPERATIONS\r\n  // ============================================\r\n\r\n  /**\r\n   * Get user settings\r\n   * @returns {Promise<AppSettings | null>} User settings\r\n   */\r\n  async getSettings(): Promise<AppSettings | null> {\r\n    const { data: { user } } = await this.supabase.auth.getUser();\r\n    if (!user) {\r\n      throw new AuthenticationError('User not authenticated');\r\n    }\r\n\r\n    const cacheKey = this.getCacheKey(user.id, 'settings');\r\n\r\n    return this.dedupeRequest(cacheKey, async () => {\r\n      try {\r\n        // ENHANCED: Add timeout protection to prevent hanging queries\r\n        const queryPromise = this.supabase\r\n          .from('user_settings')\r\n          .select('*')\r\n          .eq('user_id', user.id)\r\n          .single();\r\n\r\n        // Race against timeout\r\n        const timeoutPromise = new Promise<never>((_, reject) =>\r\n          setTimeout(() => reject(new Error('Settings query timeout')), 5000)\r\n        );\r\n\r\n        const { data, error } = await Promise.race([queryPromise, timeoutPromise]);\r\n\r\n        if (error) {\r\n          // If settings don't exist, return null (will be created)\r\n          if (error.code === 'PGRST116') return null;\r\n          throw error;\r\n        }\r\n\r\n        if (!data) return null;\r\n\r\n        return {\r\n          theme: data.theme as 'light' | 'dark' | 'system',\r\n        };\r\n      } catch (error) {\r\n        logger.error('Error fetching settings:', error);\r\n        return null;\r\n      }\r\n    }, { ...CACHE_CONFIGS.USER_SETTINGS, tags: [...CACHE_CONFIGS.USER_SETTINGS.tags] });\r\n  }\r\n\r\n  /**\r\n   * Update user settings\r\n   * @param {Partial<AppSettings>} settings - Settings to update\r\n   * @returns {Promise<AppSettings>} Updated settings\r\n   */\r\n  async updateSettings(settings: Partial<AppSettings>): Promise<AppSettings> {\r\n    let userId: string | undefined;\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n      userId = user.id;\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['settings', `user:${user.id}`]);\r\n\r\n      const updateData: {\r\n        user_id: string;\r\n        theme?: string;\r\n      } = {\r\n        user_id: user.id,\r\n      };\r\n\r\n      if (settings.theme !== undefined) updateData.theme = settings.theme;\r\n\r\n      // Use proper upsert with conflict resolution\r\n      const { data, error } = await this.supabase\r\n        .from('user_settings')\r\n        .upsert(updateData, {\r\n          onConflict: 'user_id',\r\n          ignoreDuplicates: false\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        // If still getting constraint error, try update instead\r\n        if (error.code === '23505') {\r\n          const { data: updateDataResult, error: updateError } = await this.supabase\r\n            .from('user_settings')\r\n            .update({\r\n              theme: settings.theme,\r\n            })\r\n            .eq('user_id', user.id)\r\n            .select()\r\n            .single();\r\n\r\n          if (updateError) {\r\n            throw new DatabaseError('Failed to update settings', { userId: user.id }, updateError as Error);\r\n          }\r\n          if (!updateDataResult) {\r\n            throw new DatabaseError('Failed to update settings - no data returned', { userId: user.id });\r\n          }\r\n\r\n          const result = {\r\n            theme: updateDataResult.theme as 'light' | 'dark' | 'system',\r\n          };\r\n\r\n          if (!isAppSettings(result)) {\r\n            throw new DatabaseError('Invalid settings data received', { userId: user.id });\r\n          }\r\n\r\n          return result;\r\n        }\r\n        throw new DatabaseError('Failed to update settings', { userId: user.id }, error as Error);\r\n      }\r\n\r\n      if (!data) {\r\n        throw new DatabaseError('Failed to update settings - no data returned', { userId: user.id });\r\n      }\r\n\r\n      const result = {\r\n        theme: data.theme as 'light' | 'dark' | 'system',\r\n        viewMode: data.view_mode as 'grid' | 'list',\r\n      };\r\n\r\n      if (!isAppSettings(result)) {\r\n        throw new DatabaseError('Invalid settings data received', { userId: user.id });\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to update settings', { userId: userId || 'unknown' }, error as Error);\r\n    }\r\n  }\r\n\r\n  // ============================================\r\n  // REALTIME SUBSCRIPTIONS\r\n  // ============================================\r\n\r\n  /**\r\n   * Subscribe to link changes with improved error handling and race condition protection\r\n   * @param {Function} callback - Callback function for changes\r\n   * @returns {Function} Unsubscribe function\r\n   */\r\n  subscribeToLinks(callback: (links: Link[]) => void): () => void {\r\n    const channelName = 'links_changes';\r\n\r\n    // Remove existing channel if it exists to prevent duplicates\r\n    if (this.activeChannels.has(channelName)) {\r\n      const existingChannel = this.activeChannels.get(channelName);\r\n      try {\r\n        if (existingChannel) {\r\n          this.supabase.removeChannel(existingChannel);\r\n        }\r\n      } catch (error) {\r\n        logger.warn('Error removing existing channel:', error);\r\n      }\r\n      this.activeChannels.delete(channelName);\r\n    }\r\n\r\n    let retryCount = 0;\r\n    const maxRetries = 3;\r\n    const retryDelay = 2000; // 2 seconds\r\n    let unsubscribeRequested = false;\r\n\r\n    const createSubscription = () => {\r\n      if (unsubscribeRequested) return;\r\n\r\n      const channel = this.supabase\r\n        .channel(channelName, {\r\n          config: {\r\n            presence: {\r\n              key: 'user_id',\r\n            },\r\n          },\r\n        })\r\n        .on(\r\n          'postgres_changes',\r\n          {\r\n            event: '*',\r\n            schema: 'public',\r\n            table: 'links',\r\n          },\r\n          async (payload) => {\r\n            try {\r\n              // Enhanced cache invalidation with race condition protection\r\n              const { data: { user } } = await this.supabase.auth.getUser();\r\n              if (user) {\r\n                // Only invalidate cache for actual data changes, not metadata changes\r\n                if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE' || payload.eventType === 'DELETE') {\r\n                  this.invalidateCache(['links', `user:${user.id}`]);\r\n                }\r\n              }\r\n\r\n              // Refetch all links when any change occurs with deduplication\r\n              const links = await this.getLinks();\r\n\r\n              // Add small delay to prevent overwhelming the UI with rapid updates\r\n              setTimeout(() => {\r\n                callback(links);\r\n              }, 50);\r\n\r\n            } catch (error) {\r\n              logger.error('Error handling realtime link changes:', {\r\n                error: error instanceof Error ? error.message : 'Unknown error',\r\n                eventType: payload.eventType,\r\n                table: payload.table,\r\n                timestamp: new Date().toISOString()\r\n              });\r\n              performanceMonitor.trackError({\r\n                message: `Realtime link change error: ${(error as Error).message}`,\r\n                severity: 'medium',\r\n                context: { event: payload.eventType, table: 'links' }\r\n              });\r\n            }\r\n          }\r\n        )\r\n        .on('system', {}, (payload) => {\r\n          if (payload.status === 'CHANNEL_ERROR') {\r\n            logger.error('Realtime channel error for links:', payload);\r\n            performanceMonitor.trackError({\r\n              message: 'Realtime channel error',\r\n              severity: 'high',\r\n              context: { channel: 'links', payload }\r\n            });\r\n          }\r\n        })\r\n        .subscribe((status) => {\r\n          if (status === 'SUBSCRIBED') {\r\n            logger.debug('Successfully subscribed to links changes');\r\n            retryCount = 0; // Reset retry count on successful connection\r\n          } else if (status === 'CHANNEL_ERROR') {\r\n            logger.error('Failed to subscribe to links changes');\r\n\r\n            // Retry connection with exponential backoff\r\n            if (retryCount < maxRetries && !unsubscribeRequested) {\r\n              retryCount++;\r\n              const delay = retryDelay * Math.pow(2, retryCount - 1);\r\n              logger.debug(`Retrying links subscription in ${delay}ms (attempt ${retryCount}/${maxRetries})`);\r\n\r\n              setTimeout(() => {\r\n                if (this.activeChannels.has(channelName) && !unsubscribeRequested) {\r\n                  const ch = this.activeChannels.get(channelName);\r\n                  try {\r\n                    if (ch) {\r\n                      this.supabase.removeChannel(ch);\r\n                    }\r\n                  } catch (error) {\r\n                    logger.warn('Error removing channel during retry:', error);\r\n                  }\r\n                  this.activeChannels.delete(channelName);\r\n                  createSubscription();\r\n                }\r\n              }, delay);\r\n            } else {\r\n              logger.error('Max retries reached for links subscription');\r\n              performanceMonitor.trackError({\r\n                message: 'Links subscription failed after max retries',\r\n                severity: 'high',\r\n                context: { maxRetries, channelName }\r\n              });\r\n            }\r\n          } else if (status === 'CLOSED') {\r\n            logger.debug('Links subscription closed');\r\n          }\r\n        });\r\n\r\n      this.activeChannels.set(channelName, channel);\r\n    };\r\n\r\n    createSubscription();\r\n\r\n    return () => {\r\n      unsubscribeRequested = true;\r\n      // Safely unsubscribe\r\n      if (this.activeChannels.has(channelName)) {\r\n        const ch = this.activeChannels.get(channelName);\r\n        try {\r\n          if (ch) {\r\n            this.supabase.removeChannel(ch);\r\n          }\r\n        } catch (error) {\r\n          logger.warn('Error removing channel during unsubscribe:', error);\r\n        }\r\n        this.activeChannels.delete(channelName);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Subscribe to folder changes with improved error handling\r\n   * @param {Function} callback - Callback function\r\n   * @returns {Function} Unsubscribe function\r\n   */\r\n  subscribeToFolders(callback: (folders: Folder[]) => void): () => void {\r\n    const channelName = 'folders-changes';\r\n\r\n    // Remove existing channel if it exists to prevent duplicates\r\n    if (this.activeChannels.has(channelName)) {\r\n      const existingChannel = this.activeChannels.get(channelName);\r\n      try {\r\n        if (existingChannel) {\r\n          this.supabase.removeChannel(existingChannel);\r\n        }\r\n      } catch (error) {\r\n        logger.warn('Error removing existing channel:', error);\r\n      }\r\n      this.activeChannels.delete(channelName);\r\n    }\r\n\r\n    let retryCount = 0;\r\n    const maxRetries = 3;\r\n    const retryDelay = 2000; // 2 seconds\r\n    let unsubscribeRequested = false;\r\n\r\n    const createSubscription = () => {\r\n      if (unsubscribeRequested) return;\r\n\r\n      const channel = this.supabase\r\n        .channel(channelName, {\r\n          config: {\r\n            presence: {\r\n              key: 'user_id',\r\n            },\r\n          },\r\n        })\r\n        .on(\r\n          'postgres_changes',\r\n          {\r\n            event: '*',\r\n            schema: 'public',\r\n            table: 'folders',\r\n          },\r\n          async (payload) => {\r\n            try {\r\n              // Clear cache to force fresh fetch\r\n              const { data: { user } } = await this.supabase.auth.getUser();\r\n              if (user) {\r\n                this.invalidateCache(['folders', `user:${user.id}`]);\r\n              }\r\n              // Refetch all folders when any change occurs\r\n              const folders = await this.getFolders();\r\n              callback(folders);\r\n            } catch (error) {\r\n              logger.error('Error handling realtime folder changes:', error);\r\n              performanceMonitor.trackError({\r\n                message: `Realtime folder change error: ${(error as Error).message}`,\r\n                severity: 'medium',\r\n                context: { event: payload.eventType, table: 'folders' }\r\n              });\r\n            }\r\n          }\r\n        )\r\n        .on('system', {}, (payload) => {\r\n          if (payload.status === 'CHANNEL_ERROR') {\r\n            logger.error('Realtime channel error for folders:', payload);\r\n            performanceMonitor.trackError({\r\n              message: 'Realtime channel error',\r\n              severity: 'high',\r\n              context: { channel: 'folders', payload }\r\n            });\r\n          }\r\n        })\r\n        .subscribe((status) => {\r\n          if (status === 'SUBSCRIBED') {\r\n            logger.debug('Successfully subscribed to folders changes');\r\n            retryCount = 0; // Reset retry count on successful connection\r\n          } else if (status === 'CHANNEL_ERROR') {\r\n            logger.error('Failed to subscribe to folders changes');\r\n\r\n            // Retry connection with exponential backoff\r\n            if (retryCount < maxRetries && !unsubscribeRequested) {\r\n              retryCount++;\r\n              const delay = retryDelay * Math.pow(2, retryCount - 1);\r\n              logger.debug(`Retrying folders subscription in ${delay}ms (attempt ${retryCount}/${maxRetries})`);\r\n\r\n              setTimeout(() => {\r\n                if (this.activeChannels.has(channelName) && !unsubscribeRequested) {\r\n                  const ch = this.activeChannels.get(channelName);\r\n                  try {\r\n                    if (ch) {\r\n                      this.supabase.removeChannel(ch);\r\n                    }\r\n                  } catch (error) {\r\n                    logger.warn('Error removing channel during retry:', error);\r\n                  }\r\n                  this.activeChannels.delete(channelName);\r\n                  createSubscription();\r\n                }\r\n              }, delay);\r\n            } else {\r\n              logger.error('Max retries reached for folders subscription');\r\n              performanceMonitor.trackError({\r\n                message: 'Folders subscription failed after max retries',\r\n                severity: 'high',\r\n                context: { maxRetries, channelName }\r\n              });\r\n            }\r\n          } else if (status === 'CLOSED') {\r\n            logger.debug('Folders subscription closed');\r\n          }\r\n        });\r\n\r\n      this.activeChannels.set(channelName, channel);\r\n    };\r\n\r\n    createSubscription();\r\n\r\n    return () => {\r\n      unsubscribeRequested = true;\r\n      // Safely unsubscribe\r\n      if (this.activeChannels.has(channelName)) {\r\n        const ch = this.activeChannels.get(channelName);\r\n        try {\r\n          if (ch) {\r\n            this.supabase.removeChannel(ch);\r\n          }\r\n        } catch (error) {\r\n          logger.warn('Error removing channel during unsubscribe:', error);\r\n        }\r\n        this.activeChannels.delete(channelName);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Delete all links for current user\r\n   */\r\n  async deleteAllLinks(): Promise<void> {\r\n    const { data: { user }, error: authError } = await this.supabase.auth.getUser();\r\n    if (authError || !user) throw new Error('User not authenticated');\r\n\r\n    const { error } = await this.supabase\r\n      .from('links')\r\n      .delete()\r\n      .eq('user_id', user.id);\r\n\r\n    if (error) throw error;\r\n\r\n    // Clear cache after mutation\r\n    this.invalidateCache(['links', `user:${user.id}`]);\r\n  }\r\n\r\n  /**\r\n   * Delete all folders for current user\r\n   */\r\n  async deleteAllFolders(): Promise<void> {\r\n    const { data: { user }, error: authError } = await this.supabase.auth.getUser();\r\n    if (authError || !user) throw new Error('User not authenticated');\r\n\r\n    const { error } = await this.supabase\r\n      .from('folders')\r\n      .delete()\r\n      .eq('user_id', user.id);\r\n\r\n    if (error) throw error;\r\n\r\n    // Clear cache after mutation\r\n    this.invalidateCache(['folders', `user:${user.id}`]);\r\n  }\r\n\r\n  /**\r\n   * Delete user settings\r\n   */\r\n  async deleteUserSettings(): Promise<void> {\r\n    const { data: { user }, error: authError } = await this.supabase.auth.getUser();\r\n    if (authError || !user) throw new Error('User not authenticated');\r\n\r\n    const { error } = await this.supabase\r\n      .from('user_settings')\r\n      .delete()\r\n      .eq('user_id', user.id);\r\n\r\n    if (error) throw error;\r\n\r\n    // Clear cache after mutation\r\n    this.invalidateCache(['settings', `user:${user.id}`]);\r\n  }\r\n\r\n  // ============================================\r\n  // BULK OPERATIONS\r\n  // ============================================\r\n\r\n  /**\r\n   * Bulk update multiple links with the same updates\r\n   * @param {string[]} ids - Array of link IDs to update\r\n   * @param {Partial<Link>} updates - Updates to apply to all links\r\n   * @returns {Promise<Link[]>} Updated links\r\n   */\r\n  async bulkUpdateLinks(ids: string[], updates: Partial<Link>): Promise<Link[]> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      if (ids.length === 0) return [];\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n\r\n      const updateData: LinkUpdateData & { updated_at: string } = {\r\n        updated_at: new Date().toISOString(),\r\n      };\r\n\r\n      if (updates.title !== undefined) updateData.title = updates.title;\r\n      if (updates.description !== undefined) updateData.description = updates.description;\r\n      if (updates.url !== undefined) updateData.url = updates.url;\r\n      if (updates.thumbnail !== undefined) updateData.thumbnail = updates.thumbnail;\r\n      if (updates.faviconUrl !== undefined) updateData.favicon_url = updates.faviconUrl;\r\n      if (updates.platform !== undefined) updateData.platform = updates.platform;\r\n      if (updates.folderId !== undefined) updateData.folder_id = updates.folderId;\r\n      if (updates.isFavorite !== undefined) updateData.is_favorite = updates.isFavorite;\r\n      if (updates.tags !== undefined) updateData.tags = updates.tags;\r\n      if (updates.deletedAt !== undefined) updateData.deleted_at = updates.deletedAt;\r\n\r\n      const { data, error } = await this.supabase\r\n        .from('links')\r\n        .update(updateData)\r\n        .in('id', ids)\r\n        .eq('user_id', user.id)\r\n        .select();\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to bulk update links', { linkIds: ids }, error as Error);\r\n      }\r\n      if (!data || data.length === 0) {\r\n        throw new DatabaseError('Failed to bulk update links - no data returned', { linkIds: ids });\r\n      }\r\n\r\n      // Validate and transform results\r\n      const links = data.map((dbLink: DatabaseLink) => {\r\n        const link = this.transformLinkFromDB(dbLink);\r\n        if (!isLink(link)) {\r\n          logger.warn('Invalid link data received in bulk update:', dbLink);\r\n          return null;\r\n        }\r\n        return link;\r\n      }).filter((link): link is Link => link !== null);\r\n\r\n      return links;\r\n    } catch (error) {\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to bulk update links', { linkIds: ids }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bulk soft delete multiple links (move to trash)\r\n   * @param {string[]} ids - Array of link IDs to delete\r\n   * @returns {Promise<void>}\r\n   */\r\n  async bulkDeleteLinks(ids: string[]): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      if (ids.length === 0) return;\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .update({\r\n          deleted_at: new Date().toISOString(),\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .in('id', ids)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to bulk delete links', { linkIds: ids }, error as Error);\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n    } catch (error) {\r\n      logger.error('Error bulk deleting links:', error);\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to bulk delete links', { linkIds: ids }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bulk restore multiple links from trash\r\n   * @param {string[]} ids - Array of link IDs to restore\r\n   * @returns {Promise<void>}\r\n   */\r\n  async bulkRestoreLinks(ids: string[]): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      if (ids.length === 0) return;\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .update({\r\n          deleted_at: null,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .in('id', ids)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to bulk restore links', { linkIds: ids }, error as Error);\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n    } catch (error) {\r\n      logger.error('Error bulk restoring links:', error);\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to bulk restore links', { linkIds: ids }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bulk permanently delete multiple links\r\n   * @param {string[]} ids - Array of link IDs to permanently delete\r\n   * @returns {Promise<void>}\r\n   */\r\n  async bulkPermanentlyDeleteLinks(ids: string[]): Promise<void> {\r\n    try {\r\n      const { data: { user } } = await this.supabase.auth.getUser();\r\n      if (!user) {\r\n        throw new AuthenticationError('User not authenticated');\r\n      }\r\n\r\n      if (ids.length === 0) return;\r\n\r\n      const { error } = await this.supabase\r\n        .from('links')\r\n        .delete()\r\n        .in('id', ids)\r\n        .eq('user_id', user.id);\r\n\r\n      if (error) {\r\n        throw new DatabaseError('Failed to bulk permanently delete links', { linkIds: ids }, error as Error);\r\n      }\r\n\r\n      // Invalidate cache BEFORE operation to prevent race conditions\r\n      this.invalidateCache(['links', `user:${user.id}`]);\r\n    } catch (error) {\r\n      logger.error('Error bulk permanently deleting links:', error);\r\n      if (error instanceof DatabaseError || error instanceof AuthenticationError) {\r\n        throw error;\r\n      }\r\n      throw new DatabaseError('Failed to bulk permanently delete links', { linkIds: ids }, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bulk move multiple links to a specific folder\r\n   * @param {string[]} ids - Array of link IDs to move\r\n   * @param {string | null} folderId - Target folder ID (null for root)\r\n   * @returns {Promise<Link[]>} Updated links\r\n   */\r\n  async bulkMoveLinks(ids: string[], folderId: string | null): Promise<Link[]> {\r\n    return this.bulkUpdateLinks(ids, { folderId });\r\n  }\r\n\r\n  /**\r\n   * Bulk toggle favorite status for multiple links\r\n   * @param {string[]} ids - Array of link IDs to toggle\r\n   * @param {boolean} isFavorite - New favorite status\r\n   * @returns {Promise<Link[]>} Updated links\r\n   */\r\n  async bulkToggleFavoriteLinks(ids: string[], isFavorite: boolean): Promise<Link[]> {\r\n    return this.bulkUpdateLinks(ids, { isFavorite });\r\n  }\r\n\r\n  // ============================================\r\n  // HELPER METHODS\r\n  // ============================================\r\n\r\n  /**\r\n   * Transform link from database schema to app schema\r\n   * @param {DatabaseLink} dbLink - Link from database\r\n   * @returns {Link} Transformed link\r\n   */\r\n  private transformLinkFromDB(dbLink: DatabaseLink): Link {\r\n    return {\r\n      id: dbLink.id,\r\n      url: dbLink.url,\r\n      title: dbLink.title || '',\r\n      description: dbLink.description || '',\r\n      thumbnail: dbLink.thumbnail || '',\r\n      faviconUrl: dbLink.favicon_url || '',\r\n      platform: dbLink.platform as Platform,\r\n      folderId: dbLink.folder_id,\r\n      isFavorite: dbLink.is_favorite || false,\r\n      tags: dbLink.tags || [],\r\n      deletedAt: dbLink.deleted_at,\r\n      createdAt: dbLink.created_at,\r\n      updatedAt: dbLink.updated_at,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Transform folder from database schema to app schema\r\n   * @param {DatabaseFolder} dbFolder - Folder from database\r\n   * @returns {Folder} Transformed folder\r\n   */\r\n  private transformFolderFromDB(dbFolder: DatabaseFolder): Folder {\r\n    return {\r\n      id: dbFolder.id,\r\n      name: dbFolder.name,\r\n      description: dbFolder.description || '',\r\n      color: dbFolder.color,\r\n      icon: dbFolder.icon,\r\n      parentId: dbFolder.parent_id,\r\n      isPlatformFolder: dbFolder.is_platform_folder || false,\r\n      platform: dbFolder.platform as Platform | undefined,\r\n      createdAt: dbFolder.created_at,\r\n      updatedAt: dbFolder.updated_at,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from all active realtime subscriptions\r\n   * Useful for cleanup on logout\r\n   */\r\n  unsubscribeAll(): void {\r\n    try {\r\n      logger.debug(`Unsubscribing from ${this.activeChannels.size} active channels`);\r\n\r\n      // Remove all channels\r\n      for (const [channelName, channel] of this.activeChannels.entries()) {\r\n        try {\r\n          this.supabase.removeChannel(channel);\r\n          logger.debug(`Removed channel: ${channelName}`);\r\n        } catch (error) {\r\n          logger.warn(`Error removing channel ${channelName}:`, error);\r\n        }\r\n      }\r\n\r\n      // Clear the map\r\n      this.activeChannels.clear();\r\n    } catch (error) {\r\n      logger.error('Error unsubscribing from all channels:', error);\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const supabaseDatabaseService = new SupabaseDatabaseService();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\supabase\\admin.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token !","line":16,"column":61,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/supabase/admin.ts\r\n * @description Supabase admin client for bypassing RLS in specific server-side contexts\r\n * @created 2025-11-21\r\n */\r\n\r\nimport { createClient } from '@supabase/supabase-js';\r\n\r\n/**\r\n * Creates a Supabase client with the Service Role Key.\r\n * ΓÜá∩╕Å WARNING: This client bypasses Row Level Security (RLS).\r\n * Use only for specific server-side operations that require admin privileges,\r\n * such as fetching public shared data that might be otherwise restricted.\r\n */\r\nexport function createAdminClient() {\r\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\r\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;\r\n\r\n    if (!supabaseServiceKey) {\r\n        throw new Error('SUPABASE_SERVICE_ROLE_KEY is not defined');\r\n    }\r\n\r\n    return createClient(supabaseUrl, supabaseServiceKey, {\r\n        auth: {\r\n            autoRefreshToken: false,\r\n            persistSession: false,\r\n        },\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\supabase\\client.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":13,"column":21,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/supabase/client.ts\r\n * @description Supabase client configuration for browser usage with optimized settings\r\n * @created 2025-01-01\r\n * @modified 2025-01-21\r\n */\r\n\r\nimport { createBrowserClient as createClientCore } from '@supabase/ssr';\r\nimport { AUTH_CONSTANTS } from '@/constants/auth.constants';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\n// Singleton instance to prevent multiple connections\r\nlet supabaseInstance: any = null;\r\n\r\n/**\r\n * Creates or returns existing Supabase client instance\r\n * @returns Supabase client instance\r\n */\r\nexport function createClient() {\r\n  // Return existing instance if available\r\n  if (supabaseInstance) {\r\n    return supabaseInstance;\r\n  }\r\n\r\n  // Validate environment variables\r\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\n  const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\r\n\r\n  if (!supabaseUrl || !supabaseKey) {\r\n    const error = 'Missing Supabase environment variables';\r\n    logger.error(error);\r\n    throw new Error(error);\r\n  }\r\n\r\n  try {\r\n    // Create optimized client with sensible defaults\r\n    supabaseInstance = createClientCore(\r\n      supabaseUrl,\r\n      supabaseKey,\r\n      {\r\n        auth: {\r\n          persistSession: true,\r\n          autoRefreshToken: true,\r\n          detectSessionInUrl: true,\r\n          flowType: 'pkce',\r\n          // Use Supabase default storage (more reliable than custom implementation)\r\n        },\r\n        // Optimized realtime config - minimal overhead\r\n        realtime: {\r\n          params: {\r\n            eventsPerSecond: 3,\r\n          },\r\n          heartbeatIntervalMs: 90000, // 90s\r\n          timeout: 5000,\r\n        },\r\n        global: {\r\n          headers: {\r\n            'X-Client-Info': 'linkvault-web-optimized',\r\n          },\r\n          // Improved fetch with longer timeout for slow networks\r\n          fetch: (input: any, init: any = {}) => {\r\n            return fetch(input, {\r\n              ...init,\r\n              // Increased from 5s to 15s for better reliability on slow networks\r\n              signal: AbortSignal.timeout(AUTH_CONSTANTS.FETCH_TIMEOUT),\r\n            }).catch((error) => {\r\n              // Log timeout errors for debugging\r\n              if (error.name === 'AbortError' || error.name === 'TimeoutError') {\r\n                logger.warn('Supabase request timed out:', {\r\n                  url: input,\r\n                  timeout: AUTH_CONSTANTS.FETCH_TIMEOUT,\r\n                });\r\n              }\r\n              throw error;\r\n            });\r\n          },\r\n        },\r\n      }\r\n    );\r\n\r\n    logger.debug('Supabase client initialized successfully');\r\n    return supabaseInstance;\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Supabase client:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Reset the singleton instance (useful for testing)\r\n * @internal\r\n */\r\nexport function resetClient() {\r\n  supabaseInstance = null;\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\supabase\\server.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token !","line":14,"column":41,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/supabase/server.ts\r\n * @description Supabase client configuration for server-side usage\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { createServerClient } from '@supabase/ssr';\r\nimport { cookies } from 'next/headers';\r\n\r\nexport async function createClient() {\r\n  const cookieStore = await cookies();\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return cookieStore.getAll();\r\n        },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            );\r\n          } catch (error) {\r\n            // The `setAll` method was called from a Server Component.\r\n            // This can be ignored if you have middleware refreshing\r\n            // user sessions.\r\n          }\r\n        },\r\n      },\r\n    }\r\n  );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\theme\\index.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ColorPalette","line":19,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/theme/index.ts\r\n * @description Theme system exports for easy importing\r\n * @created 2025-01-27\r\n */\r\n\r\n// Theme configuration\r\nexport {\r\n  ThemeMode,\r\n  lightTheme,\r\n  darkTheme,\r\n  cssVariables,\r\n  generateCSSVariables,\r\n  applyThemeVariables,\r\n  getThemeConfig,\r\n  CONTRAST_REQUIREMENTS,\r\n  calculateContrastRatio,\r\n  validateThemeContrast,\r\n  type ColorPalette,\r\n  type ComponentTheme,\r\n  type ThemeConfig,\r\n} from './theme-config';\r\n\r\n// Theme context and hooks\r\nexport {\r\n  ThemeProvider,\r\n  useTheme,\r\n  useThemeClasses,\r\n  useComponentTheme,\r\n  useColorPalette,\r\n  type ThemeContextType,\r\n} from './theme-context';\r\n\r\n// Theme utilities\r\nexport {\r\n  cn,\r\n  ThemeClassGenerator,\r\n  themeClasses,\r\n  generateResponsiveClasses,\r\n  generateInteractiveStates,\r\n  validateClasses,\r\n  extractThemeClasses,\r\n  hexToRgb,\r\n  getLuminance,\r\n  getContrastRatio,\r\n  meetsContrastRequirement,\r\n} from './theme-utils';\r\n\r\n// Re-export common types for convenience\r\nexport type { ClassValue } from 'clsx';","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\theme\\theme-config.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token enum","line":10,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/theme/theme-config.ts\r\n * @description Centralized theme configuration system with type-safe definitions\r\n * @created 2025-01-27\r\n */\r\n\r\n/**\r\n * Theme mode enumeration\r\n */\r\nexport enum ThemeMode {\r\n  LIGHT = 'light',\r\n  DARK = 'dark',\r\n  SYSTEM = 'system'\r\n}\r\n\r\n/**\r\n * Color palette interface for type safety\r\n */\r\nexport interface ColorPalette {\r\n  // Background colors\r\n  background: {\r\n    primary: string;\r\n    secondary: string;\r\n    tertiary: string;\r\n    surface: string;\r\n    overlay: string;\r\n  };\r\n  \r\n  // Text colors\r\n  text: {\r\n    primary: string;\r\n    secondary: string;\r\n    tertiary: string;\r\n    inverse: string;\r\n    muted: string;\r\n  };\r\n  \r\n  // Interactive colors\r\n  interactive: {\r\n    primary: string;\r\n    secondary: string;\r\n    hover: string;\r\n    active: string;\r\n    disabled: string;\r\n  };\r\n  \r\n  // Semantic colors\r\n  semantic: {\r\n    success: string;\r\n    warning: string;\r\n    error: string;\r\n    info: string;\r\n  };\r\n  \r\n  // Border colors\r\n  border: {\r\n    primary: string;\r\n    secondary: string;\r\n    focus: string;\r\n    error: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Component-specific theme configurations\r\n */\r\nexport interface ComponentTheme {\r\n  bulkActionBar: {\r\n    background: string;\r\n    text: string;\r\n    border: string;\r\n    button: {\r\n      text: string;\r\n      hover: string;\r\n    };\r\n    divider: string;\r\n  };\r\n  \r\n  toast: {\r\n    background: string;\r\n    text: string;\r\n    border: string;\r\n    action: {\r\n      text: string;\r\n      background: string;\r\n      hover: string;\r\n    };\r\n  };\r\n  \r\n  card: {\r\n    background: string;\r\n    border: string;\r\n    hover: string;\r\n    selected: string;\r\n  };\r\n  \r\n  button: {\r\n    primary: {\r\n      background: string;\r\n      text: string;\r\n      hover: string;\r\n    };\r\n    secondary: {\r\n      background: string;\r\n      text: string;\r\n      hover: string;\r\n    };\r\n    ghost: {\r\n      text: string;\r\n      hover: string;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Complete theme configuration\r\n */\r\nexport interface ThemeConfig {\r\n  mode: ThemeMode;\r\n  colors: ColorPalette;\r\n  components: ComponentTheme;\r\n}\r\n\r\n/**\r\n * Light theme configuration\r\n */\r\nexport const lightTheme: ThemeConfig = {\r\n  mode: ThemeMode.LIGHT,\r\n  colors: {\r\n    background: {\r\n      primary: '#ffffff',\r\n      secondary: '#f8fafc',\r\n      tertiary: '#f1f5f9',\r\n      surface: '#ffffff',\r\n      overlay: 'rgba(0, 0, 0, 0.5)',\r\n    },\r\n    text: {\r\n      primary: '#0f172a',\r\n      secondary: '#475569',\r\n      tertiary: '#64748b',\r\n      inverse: '#ffffff',\r\n      muted: '#94a3b8',\r\n    },\r\n    interactive: {\r\n      primary: '#3b82f6',\r\n      secondary: '#64748b',\r\n      hover: '#2563eb',\r\n      active: '#1d4ed8',\r\n      disabled: '#cbd5e1',\r\n    },\r\n    semantic: {\r\n      success: '#10b981',\r\n      warning: '#f59e0b',\r\n      error: '#ef4444',\r\n      info: '#3b82f6',\r\n    },\r\n    border: {\r\n      primary: '#e2e8f0',\r\n      secondary: '#cbd5e1',\r\n      focus: '#3b82f6',\r\n      error: '#ef4444',\r\n    },\r\n  },\r\n  components: {\r\n    bulkActionBar: {\r\n      background: '#000000',\r\n      text: '#ffffff',\r\n      border: 'rgba(255, 255, 255, 0.3)',\r\n      button: {\r\n        text: '#ffffff',\r\n        hover: 'rgba(255, 255, 255, 0.1)',\r\n      },\r\n      divider: 'rgba(255, 255, 255, 0.3)',\r\n    },\r\n    toast: {\r\n      background: '#ffffff',\r\n      text: '#0f172a',\r\n      border: '#e2e8f0',\r\n      action: {\r\n        text: '#000000',\r\n        background: 'transparent',\r\n        hover: '#f1f5f9',\r\n      },\r\n    },\r\n    card: {\r\n      background: '#ffffff',\r\n      border: '#e2e8f0',\r\n      hover: '#f8fafc',\r\n      selected: '#eff6ff',\r\n    },\r\n    button: {\r\n      primary: {\r\n        background: '#3b82f6',\r\n        text: '#ffffff',\r\n        hover: '#2563eb',\r\n      },\r\n      secondary: {\r\n        background: '#f1f5f9',\r\n        text: '#475569',\r\n        hover: '#e2e8f0',\r\n      },\r\n      ghost: {\r\n        text: '#475569',\r\n        hover: '#f1f5f9',\r\n      },\r\n    },\r\n  },\r\n};\r\n\r\n/**\r\n * Dark theme configuration\r\n */\r\nexport const darkTheme: ThemeConfig = {\r\n  mode: ThemeMode.DARK,\r\n  colors: {\r\n    background: {\r\n      primary: '#0f172a',\r\n      secondary: '#1e293b',\r\n      tertiary: '#334155',\r\n      surface: '#1e293b',\r\n      overlay: 'rgba(0, 0, 0, 0.7)',\r\n    },\r\n    text: {\r\n      primary: '#f8fafc',\r\n      secondary: '#cbd5e1',\r\n      tertiary: '#94a3b8',\r\n      inverse: '#0f172a',\r\n      muted: '#64748b',\r\n    },\r\n    interactive: {\r\n      primary: '#60a5fa',\r\n      secondary: '#94a3b8',\r\n      hover: '#3b82f6',\r\n      active: '#2563eb',\r\n      disabled: '#475569',\r\n    },\r\n    semantic: {\r\n      success: '#34d399',\r\n      warning: '#fbbf24',\r\n      error: '#f87171',\r\n      info: '#60a5fa',\r\n    },\r\n    border: {\r\n      primary: '#334155',\r\n      secondary: '#475569',\r\n      focus: '#60a5fa',\r\n      error: '#f87171',\r\n    },\r\n  },\r\n  components: {\r\n    bulkActionBar: {\r\n      background: '#ffffff',\r\n      text: '#000000',\r\n      border: 'rgba(0, 0, 0, 0.3)',\r\n      button: {\r\n        text: '#000000',\r\n        hover: 'rgba(0, 0, 0, 0.1)',\r\n      },\r\n      divider: 'rgba(0, 0, 0, 0.3)',\r\n    },\r\n    toast: {\r\n      background: '#1e293b',\r\n      text: '#f8fafc',\r\n      border: '#334155',\r\n      action: {\r\n        text: '#ffffff',\r\n        background: 'transparent',\r\n        hover: '#334155',\r\n      },\r\n    },\r\n    card: {\r\n      background: '#1e293b',\r\n      border: '#334155',\r\n      hover: '#334155',\r\n      selected: '#1e40af',\r\n    },\r\n    button: {\r\n      primary: {\r\n        background: '#60a5fa',\r\n        text: '#0f172a',\r\n        hover: '#3b82f6',\r\n      },\r\n      secondary: {\r\n        background: '#334155',\r\n        text: '#cbd5e1',\r\n        hover: '#475569',\r\n      },\r\n      ghost: {\r\n        text: '#cbd5e1',\r\n        hover: '#334155',\r\n      },\r\n    },\r\n  },\r\n};\r\n\r\n/**\r\n * CSS variable mappings for theme values\r\n */\r\nexport const cssVariables = {\r\n  // Background variables\r\n  '--bg-primary': 'background.primary',\r\n  '--bg-secondary': 'background.secondary',\r\n  '--bg-tertiary': 'background.tertiary',\r\n  '--bg-surface': 'background.surface',\r\n  '--bg-overlay': 'background.overlay',\r\n  \r\n  // Text variables\r\n  '--text-primary': 'text.primary',\r\n  '--text-secondary': 'text.secondary',\r\n  '--text-tertiary': 'text.tertiary',\r\n  '--text-inverse': 'text.inverse',\r\n  '--text-muted': 'text.muted',\r\n  \r\n  // Interactive variables\r\n  '--interactive-primary': 'interactive.primary',\r\n  '--interactive-secondary': 'interactive.secondary',\r\n  '--interactive-hover': 'interactive.hover',\r\n  '--interactive-active': 'interactive.active',\r\n  '--interactive-disabled': 'interactive.disabled',\r\n  \r\n  // Semantic variables\r\n  '--semantic-success': 'semantic.success',\r\n  '--semantic-warning': 'semantic.warning',\r\n  '--semantic-error': 'semantic.error',\r\n  '--semantic-info': 'semantic.info',\r\n  \r\n  // Border variables\r\n  '--border-primary': 'border.primary',\r\n  '--border-secondary': 'border.secondary',\r\n  '--border-focus': 'border.focus',\r\n  '--border-error': 'border.error',\r\n  \r\n  // Component-specific variables\r\n  '--bulk-action-bar-bg': 'components.bulkActionBar.background',\r\n  '--bulk-action-bar-text': 'components.bulkActionBar.text',\r\n  '--bulk-action-bar-border': 'components.bulkActionBar.border',\r\n  '--bulk-action-bar-button-text': 'components.bulkActionBar.button.text',\r\n  '--bulk-action-bar-button-hover': 'components.bulkActionBar.button.hover',\r\n  '--bulk-action-bar-divider': 'components.bulkActionBar.divider',\r\n  \r\n  '--toast-bg': 'components.toast.background',\r\n  '--toast-text': 'components.toast.text',\r\n  '--toast-border': 'components.toast.border',\r\n  '--toast-action-text': 'components.toast.action.text',\r\n  '--toast-action-bg': 'components.toast.action.background',\r\n  '--toast-action-hover': 'components.toast.action.hover',\r\n} as const;\r\n\r\n/**\r\n * Utility function to get nested object value by path\r\n */\r\nfunction getNestedValue(obj: any, path: string): string {\r\n  return path.split('.').reduce((current, key) => current?.[key], obj) || '';\r\n}\r\n\r\n/**\r\n * Generate CSS variables from theme configuration\r\n */\r\nexport function generateCSSVariables(theme: ThemeConfig): Record<string, string> {\r\n  const variables: Record<string, string> = {};\r\n  \r\n  Object.entries(cssVariables).forEach(([cssVar, path]) => {\r\n    variables[cssVar] = getNestedValue(theme, path);\r\n  });\r\n  \r\n  return variables;\r\n}\r\n\r\n/**\r\n * Apply theme CSS variables to document root\r\n */\r\nexport function applyThemeVariables(theme: ThemeConfig): void {\r\n  const variables = generateCSSVariables(theme);\r\n  const root = document.documentElement;\r\n  \r\n  Object.entries(variables).forEach(([variable, value]) => {\r\n    root.style.setProperty(variable, value);\r\n  });\r\n}\r\n\r\n/**\r\n * Get current theme configuration based on mode\r\n */\r\nexport function getThemeConfig(mode: ThemeMode): ThemeConfig {\r\n  switch (mode) {\r\n    case ThemeMode.LIGHT:\r\n      return lightTheme;\r\n    case ThemeMode.DARK:\r\n      return darkTheme;\r\n    case ThemeMode.SYSTEM:\r\n      // Detect system preference\r\n      if (typeof window !== 'undefined') {\r\n        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n        return prefersDark ? darkTheme : lightTheme;\r\n      }\r\n      return lightTheme;\r\n    default:\r\n      return lightTheme;\r\n  }\r\n}\r\n\r\n/**\r\n * WCAG AA contrast ratio requirements\r\n */\r\nexport const CONTRAST_REQUIREMENTS = {\r\n  AA_NORMAL: 4.5,\r\n  AA_LARGE: 3.0,\r\n  AAA_NORMAL: 7.0,\r\n  AAA_LARGE: 4.5,\r\n} as const;\r\n\r\n/**\r\n * Utility function to calculate contrast ratio between two colors\r\n * Note: This is a simplified version. For production, use a proper color library\r\n */\r\nexport function calculateContrastRatio(color1: string, color2: string): number {\r\n  // This is a placeholder implementation\r\n  // In a real application, you would use a proper color library like chroma-js\r\n  // to calculate the actual contrast ratio\r\n  return 4.5; // Placeholder return value\r\n}\r\n\r\n/**\r\n * Validate theme contrast ratios\r\n */\r\nexport function validateThemeContrast(theme: ThemeConfig): {\r\n  isValid: boolean;\r\n  violations: string[];\r\n} {\r\n  const violations: string[] = [];\r\n  \r\n  // Check primary text on primary background\r\n  const primaryContrast = calculateContrastRatio(\r\n    theme.colors.text.primary,\r\n    theme.colors.background.primary\r\n  );\r\n  \r\n  if (primaryContrast < CONTRAST_REQUIREMENTS.AA_NORMAL) {\r\n    violations.push(`Primary text contrast ratio ${primaryContrast} is below AA requirement`);\r\n  }\r\n  \r\n  // Add more contrast checks as needed\r\n  \r\n  return {\r\n    isValid: violations.length === 0,\r\n    violations,\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\theme\\theme-context.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":16,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/theme/theme-context.tsx\r\n * @description Theme context provider for centralized theme management\r\n * @created 2025-01-27\r\n */\r\n\r\n\"use client\";\r\n\r\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\r\nimport { useTheme as useNextTheme } from 'next-themes';\r\nimport { ThemeMode, ThemeConfig, getThemeConfig, applyThemeVariables } from './theme-config';\r\n\r\n/**\r\n * Theme context interface\r\n */\r\nexport interface ThemeContextType {\r\n  /** Current theme mode */\r\n  mode: ThemeMode;\r\n  /** Current theme configuration */\r\n  theme: ThemeConfig;\r\n  /** Set theme mode */\r\n  setTheme: (mode: ThemeMode) => void;\r\n  /** Toggle between light and dark themes */\r\n  toggleTheme: () => void;\r\n  /** Check if theme is currently dark */\r\n  isDark: boolean;\r\n  /** Check if theme is currently light */\r\n  isLight: boolean;\r\n  /** Check if system theme preference is being used */\r\n  isSystem: boolean;\r\n}\r\n\r\n/**\r\n * Theme context\r\n */\r\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\r\n\r\n/**\r\n * Local storage key for theme preference\r\n */\r\nconst THEME_STORAGE_KEY = 'linkvault-theme';\r\n\r\n/**\r\n * Theme provider props\r\n */\r\ninterface ThemeProviderProps {\r\n  children: React.ReactNode;\r\n  /** Default theme mode */\r\n  defaultTheme?: ThemeMode;\r\n  /** Storage key for theme preference */\r\n  storageKey?: string;\r\n  /** Disable system theme detection */\r\n  disableSystemTheme?: boolean;\r\n}\r\n\r\n/**\r\n * Theme provider component\r\n * Manages theme state and applies CSS variables\r\n * Integrates with next-themes for basic theme switching\r\n * \r\n * @param children - Child components\r\n * @param defaultTheme - Default theme mode (defaults to system)\r\n * @param storageKey - Local storage key for theme preference\r\n * @param disableSystemTheme - Disable system theme detection\r\n */\r\nexport function ThemeProvider({\r\n  children,\r\n  defaultTheme = ThemeMode.LIGHT, // Changed from SYSTEM to LIGHT for better UX\r\n  storageKey = THEME_STORAGE_KEY,\r\n  disableSystemTheme = false,\r\n}: ThemeProviderProps) {\r\n  const { theme: nextTheme, setTheme: setNextTheme, resolvedTheme } = useNextTheme();\r\n  const [theme, setThemeConfig] = useState<ThemeConfig>(() => getThemeConfig(defaultTheme));\r\n\r\n  /**\r\n   * Convert next-themes string to ThemeMode enum\r\n   */\r\n  const getThemeModeFromString = useCallback((themeString: string | undefined): ThemeMode => {\r\n    switch (themeString) {\r\n      case 'light':\r\n        return ThemeMode.LIGHT;\r\n      case 'dark':\r\n        return ThemeMode.DARK;\r\n      case 'system':\r\n        return ThemeMode.SYSTEM;\r\n      default:\r\n        return ThemeMode.SYSTEM;\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Convert ThemeMode enum to next-themes string\r\n   */\r\n  const getStringFromThemeMode = useCallback((mode: ThemeMode): string => {\r\n    switch (mode) {\r\n      case ThemeMode.LIGHT:\r\n        return 'light';\r\n      case ThemeMode.DARK:\r\n        return 'dark';\r\n      case ThemeMode.SYSTEM:\r\n        return 'system';\r\n      default:\r\n        return 'system';\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Get current theme mode from next-themes\r\n   */\r\n  const mode = getThemeModeFromString(nextTheme);\r\n\r\n  /**\r\n   * Set theme mode (delegates to next-themes)\r\n   */\r\n  const setTheme = useCallback((newMode: ThemeMode): void => {\r\n    const themeString = getStringFromThemeMode(newMode);\r\n    setNextTheme(themeString);\r\n  }, [setNextTheme, getStringFromThemeMode]);\r\n\r\n  /**\r\n   * Toggle between light and dark themes\r\n   */\r\n  const toggleTheme = useCallback((): void => {\r\n    const currentMode = getThemeModeFromString(resolvedTheme);\r\n    const newMode = currentMode === ThemeMode.DARK ? ThemeMode.LIGHT : ThemeMode.DARK;\r\n    setTheme(newMode);\r\n  }, [resolvedTheme, setTheme, getThemeModeFromString]);\r\n\r\n  /**\r\n   * Sync with next-themes and apply CSS variables\r\n   */\r\n  useEffect(() => {\r\n    if (typeof window === 'undefined') return;\r\n\r\n    // Get the effective theme mode (resolved theme for system preference)\r\n    const effectiveMode = resolvedTheme === 'dark' ? ThemeMode.DARK : ThemeMode.LIGHT;\r\n    const newTheme = getThemeConfig(effectiveMode);\r\n\r\n    setThemeConfig(newTheme);\r\n    applyThemeVariables(newTheme);\r\n  }, [resolvedTheme]);\r\n\r\n  /**\r\n   * Computed theme state\r\n   */\r\n  const isDark = theme.mode === ThemeMode.DARK;\r\n  const isLight = theme.mode === ThemeMode.LIGHT;\r\n  const isSystem = mode === ThemeMode.SYSTEM;\r\n\r\n  const contextValue: ThemeContextType = {\r\n    mode,\r\n    theme,\r\n    setTheme,\r\n    toggleTheme,\r\n    isDark,\r\n    isLight,\r\n    isSystem,\r\n  };\r\n\r\n  return (\r\n    <ThemeContext.Provider value={contextValue}>\r\n      {children}\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n\r\n/**\r\n * Hook to use theme context\r\n * \r\n * @returns Theme context value\r\n * @throws Error if used outside ThemeProvider\r\n */\r\nexport function useTheme(): ThemeContextType {\r\n  const context = useContext(ThemeContext);\r\n\r\n  if (context === undefined) {\r\n    throw new Error('useTheme must be used within a ThemeProvider');\r\n  }\r\n\r\n  return context;\r\n}\r\n\r\n/**\r\n * Hook to get theme-aware CSS classes\r\n * Utility hook for applying theme-specific styles\r\n * \r\n * @param lightClasses - Classes for light theme\r\n * @param darkClasses - Classes for dark theme\r\n * @returns Combined CSS classes based on current theme\r\n */\r\nexport function useThemeClasses(lightClasses: string, darkClasses: string): string {\r\n  const { isDark } = useTheme();\r\n  return isDark ? darkClasses : lightClasses;\r\n}\r\n\r\n/**\r\n * Hook to get component-specific theme values\r\n * \r\n * @param component - Component name from theme config\r\n * @returns Component theme configuration\r\n */\r\nexport function useComponentTheme<T extends keyof ThemeConfig['components']>(\r\n  component: T\r\n): ThemeConfig['components'][T] {\r\n  const { theme } = useTheme();\r\n  return theme.components[component];\r\n}\r\n\r\n/**\r\n * Hook to get color palette\r\n * \r\n * @returns Current theme color palette\r\n */\r\nexport function useColorPalette(): ThemeConfig['colors'] {\r\n  const { theme } = useTheme();\r\n  return theme.colors;\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\theme\\theme-utils.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ClassValue","line":7,"column":15,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/theme/theme-utils.ts\r\n * @description Theme utility functions for easier theme management\r\n * @created 2025-01-27\r\n */\r\n\r\nimport { type ClassValue, clsx } from 'clsx';\r\nimport { twMerge } from 'tailwind-merge';\r\nimport { ThemeConfig, ThemeMode } from './theme-config';\r\n\r\n/**\r\n * Utility function to merge CSS classes with Tailwind CSS\r\n * Enhanced version of cn utility with theme awareness\r\n */\r\nexport function cn(...inputs: ClassValue[]): string {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\n/**\r\n * Theme-aware class name generator\r\n * Generates CSS classes based on current theme mode\r\n */\r\nexport class ThemeClassGenerator {\r\n  private theme: ThemeConfig;\r\n\r\n  constructor(theme: ThemeConfig) {\r\n    this.theme = theme;\r\n  }\r\n\r\n  /**\r\n   * Generate background classes\r\n   */\r\n  background(variant: keyof ThemeConfig['colors']['background'] = 'primary'): string {\r\n    const isDark = this.theme.mode === ThemeMode.DARK;\r\n    \r\n    switch (variant) {\r\n      case 'primary':\r\n        return isDark ? 'bg-slate-900' : 'bg-white';\r\n      case 'secondary':\r\n        return isDark ? 'bg-slate-800' : 'bg-gray-50';\r\n      case 'tertiary':\r\n        return isDark ? 'bg-slate-700' : 'bg-gray-100';\r\n      case 'surface':\r\n        return isDark ? 'bg-slate-800' : 'bg-white';\r\n      default:\r\n        return isDark ? 'bg-slate-900' : 'bg-white';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate text classes\r\n   */\r\n  text(variant: keyof ThemeConfig['colors']['text'] = 'primary'): string {\r\n    const isDark = this.theme.mode === ThemeMode.DARK;\r\n    \r\n    switch (variant) {\r\n      case 'primary':\r\n        return isDark ? 'text-gray-100' : 'text-gray-900';\r\n      case 'secondary':\r\n        return isDark ? 'text-gray-300' : 'text-gray-600';\r\n      case 'tertiary':\r\n        return isDark ? 'text-gray-400' : 'text-gray-500';\r\n      case 'inverse':\r\n        return isDark ? 'text-gray-900' : 'text-gray-100';\r\n      case 'muted':\r\n        return isDark ? 'text-gray-500' : 'text-gray-400';\r\n      default:\r\n        return isDark ? 'text-gray-100' : 'text-gray-900';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate border classes\r\n   */\r\n  border(variant: keyof ThemeConfig['colors']['border'] = 'primary'): string {\r\n    const isDark = this.theme.mode === ThemeMode.DARK;\r\n    \r\n    switch (variant) {\r\n      case 'primary':\r\n        return isDark ? 'border-slate-700' : 'border-gray-200';\r\n      case 'secondary':\r\n        return isDark ? 'border-slate-600' : 'border-gray-300';\r\n      case 'focus':\r\n        return isDark ? 'border-blue-400' : 'border-blue-500';\r\n      case 'error':\r\n        return isDark ? 'border-red-400' : 'border-red-500';\r\n      default:\r\n        return isDark ? 'border-slate-700' : 'border-gray-200';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate component-specific classes\r\n   */\r\n  component(componentName: keyof ThemeConfig['components']): Record<string, string> {\r\n    const component = this.theme.components[componentName];\r\n    \r\n    switch (componentName) {\r\n      case 'bulkActionBar':\r\n        return {\r\n          container: cn(\r\n            'fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50',\r\n            'flex items-center gap-2 px-4 py-2 rounded-lg shadow-lg',\r\n            'border-2',\r\n            this.theme.mode === ThemeMode.DARK \r\n              ? 'bg-white text-black border-black/30' \r\n              : 'bg-black text-white border-white/30'\r\n          ),\r\n          button: cn(\r\n            'gap-1 px-2 h-8',\r\n            this.theme.mode === ThemeMode.DARK\r\n              ? 'text-black hover:bg-black/10'\r\n              : 'text-white hover:bg-white/10'\r\n          ),\r\n          deleteButton: cn(\r\n            'gap-1 px-2 h-8',\r\n            this.theme.mode === ThemeMode.DARK\r\n              ? 'text-red-500 hover:bg-red-50'\r\n              : 'text-red-400 hover:bg-red-950/20'\r\n          ),\r\n          divider: cn(\r\n            'h-6 w-px',\r\n            this.theme.mode === ThemeMode.DARK\r\n              ? 'bg-black/30'\r\n              : 'bg-white/30'\r\n          ),\r\n          text: cn(\r\n            'text-sm font-medium',\r\n            this.theme.mode === ThemeMode.DARK\r\n              ? 'text-black'\r\n              : 'text-white'\r\n          ),\r\n          checkbox: cn(\r\n            this.theme.mode === ThemeMode.DARK\r\n              ? 'border-black data-[state=checked]:bg-black data-[state=checked]:text-white'\r\n              : 'border-white data-[state=checked]:bg-white data-[state=checked]:text-black'\r\n          ),\r\n        };\r\n        \r\n      case 'toast':\r\n        return {\r\n          container: cn(\r\n            'border rounded-lg px-3 py-2.5',\r\n            this.theme.mode === ThemeMode.DARK\r\n              ? 'bg-zinc-900 text-gray-100 border-zinc-700'\r\n              : 'bg-white text-gray-900 border-gray-200'\r\n          ),\r\n          action: cn(\r\n            'h-6 px-2 text-xs border rounded',\r\n            this.theme.mode === ThemeMode.DARK\r\n              ? 'text-white border-zinc-600 hover:bg-zinc-800'\r\n              : 'text-black border-gray-300 hover:bg-gray-50'\r\n          ),\r\n        };\r\n        \r\n      default:\r\n        return {};\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Predefined theme-aware class combinations\r\n */\r\nexport const themeClasses = {\r\n  /**\r\n   * Card component classes\r\n   */\r\n  card: {\r\n    light: 'bg-white border-gray-200 hover:bg-gray-50',\r\n    dark: 'bg-slate-800 border-slate-700 hover:bg-slate-700',\r\n    get base() {\r\n      return 'border rounded-lg transition-colors';\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Button component classes\r\n   */\r\n  button: {\r\n    primary: {\r\n      light: 'bg-blue-600 text-white hover:bg-blue-700',\r\n      dark: 'bg-blue-500 text-white hover:bg-blue-600',\r\n    },\r\n    secondary: {\r\n      light: 'bg-gray-100 text-gray-900 hover:bg-gray-200',\r\n      dark: 'bg-slate-700 text-gray-100 hover:bg-slate-600',\r\n    },\r\n    ghost: {\r\n      light: 'text-gray-600 hover:bg-gray-100',\r\n      dark: 'text-gray-300 hover:bg-slate-700',\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Input component classes\r\n   */\r\n  input: {\r\n    light: 'bg-white border-gray-300 text-gray-900 placeholder-gray-500 focus:border-blue-500',\r\n    dark: 'bg-slate-800 border-slate-600 text-gray-100 placeholder-gray-400 focus:border-blue-400',\r\n    get base() {\r\n      return 'border rounded-md px-3 py-2 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500/20';\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Text component classes\r\n   */\r\n  text: {\r\n    primary: {\r\n      light: 'text-gray-900',\r\n      dark: 'text-gray-100',\r\n    },\r\n    secondary: {\r\n      light: 'text-gray-600',\r\n      dark: 'text-gray-300',\r\n    },\r\n    muted: {\r\n      light: 'text-gray-500',\r\n      dark: 'text-gray-400',\r\n    },\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Generate responsive theme classes\r\n */\r\nexport function generateResponsiveClasses(\r\n  baseClasses: string,\r\n  smClasses?: string,\r\n  mdClasses?: string,\r\n  lgClasses?: string,\r\n  xlClasses?: string\r\n): string {\r\n  return cn(\r\n    baseClasses,\r\n    smClasses && `sm:${smClasses}`,\r\n    mdClasses && `md:${mdClasses}`,\r\n    lgClasses && `lg:${lgClasses}`,\r\n    xlClasses && `xl:${xlClasses}`\r\n  );\r\n}\r\n\r\n/**\r\n * Generate theme-aware hover and focus states\r\n */\r\nexport function generateInteractiveStates(\r\n  baseClasses: string,\r\n  hoverClasses: string,\r\n  focusClasses?: string,\r\n  activeClasses?: string\r\n): string {\r\n  return cn(\r\n    baseClasses,\r\n    `hover:${hoverClasses}`,\r\n    focusClasses && `focus:${focusClasses}`,\r\n    activeClasses && `active:${activeClasses}`,\r\n    'transition-colors duration-200'\r\n  );\r\n}\r\n\r\n/**\r\n * Validate CSS class string\r\n */\r\nexport function validateClasses(classes: string): boolean {\r\n  try {\r\n    // Basic validation - check if string contains valid CSS class patterns\r\n    const classPattern = /^[a-zA-Z0-9\\s\\-_:\\/\\[\\]\\.]+$/;\r\n    return classPattern.test(classes);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Extract theme-specific classes from a class string\r\n */\r\nexport function extractThemeClasses(classes: string): {\r\n  light: string[];\r\n  dark: string[];\r\n  neutral: string[];\r\n} {\r\n  const classArray = classes.split(/\\s+/).filter(Boolean);\r\n  \r\n  const light: string[] = [];\r\n  const dark: string[] = [];\r\n  const neutral: string[] = [];\r\n  \r\n  classArray.forEach(cls => {\r\n    if (cls.startsWith('dark:')) {\r\n      dark.push(cls.replace('dark:', ''));\r\n    } else if (cls.includes('light') || cls.includes('white') || cls.includes('gray-')) {\r\n      light.push(cls);\r\n    } else {\r\n      neutral.push(cls);\r\n    }\r\n  });\r\n  \r\n  return { light, dark, neutral };\r\n}\r\n\r\n/**\r\n * Convert hex color to RGB values\r\n */\r\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\r\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n  return result ? {\r\n    r: parseInt(result[1], 16),\r\n    g: parseInt(result[2], 16),\r\n    b: parseInt(result[3], 16)\r\n  } : null;\r\n}\r\n\r\n/**\r\n * Calculate luminance of a color\r\n */\r\nexport function getLuminance(r: number, g: number, b: number): number {\r\n  const [rs, gs, bs] = [r, g, b].map(c => {\r\n    c = c / 255;\r\n    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\r\n  });\r\n  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;\r\n}\r\n\r\n/**\r\n * Calculate contrast ratio between two colors\r\n */\r\nexport function getContrastRatio(color1: string, color2: string): number {\r\n  const rgb1 = hexToRgb(color1);\r\n  const rgb2 = hexToRgb(color2);\r\n  \r\n  if (!rgb1 || !rgb2) return 1;\r\n  \r\n  const lum1 = getLuminance(rgb1.r, rgb1.g, rgb1.b);\r\n  const lum2 = getLuminance(rgb2.r, rgb2.g, rgb2.b);\r\n  \r\n  const brightest = Math.max(lum1, lum2);\r\n  const darkest = Math.min(lum1, lum2);\r\n  \r\n  return (brightest + 0.05) / (darkest + 0.05);\r\n}\r\n\r\n/**\r\n * Check if color combination meets WCAG contrast requirements\r\n */\r\nexport function meetsContrastRequirement(\r\n  foreground: string,\r\n  background: string,\r\n  level: 'AA' | 'AAA' = 'AA',\r\n  size: 'normal' | 'large' = 'normal'\r\n): boolean {\r\n  const ratio = getContrastRatio(foreground, background);\r\n  \r\n  const requirements = {\r\n    'AA': { normal: 4.5, large: 3.0 },\r\n    'AAA': { normal: 7.0, large: 4.5 }\r\n  };\r\n  \r\n  return ratio >= requirements[level][size];\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\types\\auth.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":9,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/types/auth.ts\r\n * @description TypeScript types for authentication and user management\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { User } from '@supabase/supabase-js';\r\n\r\nexport interface UserProfile {\r\n  id: string;\r\n  email: string | null;\r\n  display_name: string | null;\r\n  avatar_url: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface UserSettings {\r\n  id: string;\r\n  user_id: string;\r\n  theme: 'light' | 'dark' | 'system';\r\n  default_folder_id: string | null;\r\n  links_per_page: number;\r\n  show_thumbnails: boolean;\r\n  show_favicons: boolean;\r\n  auto_archive_days: number | null;\r\n  backup_enabled: boolean;\r\n  backup_frequency: 'daily' | 'weekly' | 'monthly';\r\n  last_backup_at: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\nexport interface Folder {\r\n  id: string;\r\n  user_id: string;\r\n  name: string;\r\n  description: string | null;\r\n  color: string;\r\n  icon: string;\r\n  is_default: boolean;\r\n  created_at: string;\r\n  updated_at: string;\r\n  link_count?: number;\r\n}\r\n\r\nexport interface Link {\r\n  id: string;\r\n  user_id: string;\r\n  folder_id: string | null;\r\n  url: string;\r\n  title: string | null;\r\n  description: string | null;\r\n  favicon_url: string | null;\r\n  thumbnail_url: string | null;\r\n  platform: string | null;\r\n  tags: string[];\r\n  is_favorite: boolean;\r\n  is_archived: boolean;\r\n  click_count: number;\r\n  last_clicked_at: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n  folder_name?: string;\r\n}\r\n\r\nexport interface AuthUser extends User {\r\n  profile?: UserProfile;\r\n  settings?: UserSettings;\r\n}\r\n\r\nexport interface SignUpData {\r\n  email: string;\r\n  password: string;\r\n  displayName?: string;\r\n}\r\n\r\nexport interface SignInData {\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nexport interface AuthError {\r\n  message: string;\r\n  code?: string;\r\n}\r\n\r\nexport interface AuthState {\r\n  user: AuthUser | null;\r\n  loading: boolean;\r\n  error: AuthError | null;\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\types\\database.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":12,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/types/database.ts\r\n * @description Database-specific types for Supabase operations\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { Link, Folder } from '@/types';\r\n\r\n/**\r\n * Database link record (snake_case from Supabase)\r\n */\r\nexport interface DatabaseLink {\r\n  id: string;\r\n  user_id: string;\r\n  url: string;\r\n  title: string;\r\n  description: string;\r\n  thumbnail: string;\r\n  favicon_url: string | null;\r\n  platform: string;\r\n  folder_id: string | null;\r\n  is_favorite: boolean;\r\n  tags: string[] | null;\r\n  deleted_at: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\n/**\r\n * Database folder record (snake_case from Supabase)\r\n */\r\nexport interface DatabaseFolder {\r\n  id: string;\r\n  user_id: string;\r\n  name: string;\r\n  description: string | null;\r\n  color: string;\r\n  icon: string;\r\n  parent_id: string | null;\r\n  is_platform_folder: boolean;\r\n  platform: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n  // Sharing functionality\r\n  shareable?: boolean;\r\n  share_id?: string;\r\n  share_created_at?: string;\r\n}\r\n\r\n/**\r\n * Link update data for database operations\r\n */\r\nexport interface LinkUpdateData {\r\n  title?: string;\r\n  description?: string;\r\n  url?: string;\r\n  thumbnail?: string;\r\n  favicon_url?: string;\r\n  platform?: string;\r\n  folder_id?: string | null;\r\n  is_favorite?: boolean;\r\n  tags?: string[] | null;\r\n  deleted_at?: string | null;\r\n}\r\n\r\n/**\r\n * Folder update data for database operations\r\n */\r\nexport interface FolderUpdateData {\r\n  name?: string;\r\n  description?: string | null;\r\n  color?: string;\r\n  icon?: string;\r\n  parent_id?: string | null;\r\n  is_platform_folder?: boolean;\r\n  platform?: string | null;\r\n  // Sharing functionality\r\n  shareable?: boolean;\r\n  share_id?: string;\r\n  share_created_at?: string;\r\n}\r\n\r\n/**\r\n * Batch request configuration\r\n */\r\nexport interface BatchRequest<T> {\r\n  key: string;\r\n  fn: () => Promise<T>;\r\n  cacheOptions?: {\r\n    ttl?: number;\r\n    tags?: string[];\r\n    priority?: 'low' | 'medium' | 'high';\r\n    persist?: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Request queue entry\r\n */\r\nexport interface RequestQueueEntry<T> {\r\n  resolve: (value: T) => void;\r\n  reject: (reason?: Error) => void;\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\utils.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ClassValue","line":1,"column":21,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { clsx, type ClassValue } from \"clsx\"\r\nimport { twMerge } from \"tailwind-merge\"\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs))\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\utils\\logger.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":14,"column":18,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/utils/logger.ts\r\n * @description Production-safe logging utility\r\n * @created 2025-01-01\r\n */\r\n\r\n/**\r\n * Production-safe logger that only logs in development\r\n */\r\nexport const logger = {\r\n  /**\r\n   * Log debug information (development only)\r\n   */\r\n  debug: (...args: unknown[]): void => {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.debug(...args);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log information (development only)\r\n   */\r\n  info: (...args: unknown[]): void => {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.info(...args);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log warnings (always logged, but throttled in production)\r\n   */\r\n  warn: (...args: unknown[]): void => {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.warn(...args);\r\n    } else {\r\n      // In production, only log critical warnings\r\n      // Could send to error tracking service here\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log errors (always logged, sent to error tracking in production)\r\n   */\r\n  error: (...args: unknown[]): void => {\r\n    // Always log errors, but format differently in production\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.error(...args);\r\n    } else {\r\n      // In production, send to error tracking service\r\n      console.error(...args);\r\n      // TODO: Send to error tracking service (Sentry, LogRocket, etc.)\r\n      // errorTrackingService.captureException(args[0]);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Log group (development only)\r\n   */\r\n  group: (label: string): void => {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.group(label);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * End log group (development only)\r\n   */\r\n  groupEnd: (): void => {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.groupEnd();\r\n    }\r\n  },\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\utils\\platform.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":16,"column":35,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file utils/platform.ts\r\n * @description Platform detection and URL utilities with mobile browser support\r\n * @created 2025-10-18\r\n * @modified 2025-11-08 - Added mobile browser detection and storage capabilities\r\n */\r\n\r\nimport { Platform } from '@/types';\r\nimport { PLATFORM_CONFIG } from '@/constants';\r\n\r\n/**\r\n * Detects the platform from a given URL\r\n * @param url - The URL to analyze\r\n * @returns The detected platform type\r\n */\r\nexport function detectPlatform(url: string): Platform {\r\n  try {\r\n    const urlObj = new URL(url);\r\n    const hostname = urlObj.hostname.toLowerCase().replace('www.', '');\r\n\r\n    for (const [platform, config] of Object.entries(PLATFORM_CONFIG)) {\r\n      if (config.domains.some((domain) => hostname.includes(domain))) {\r\n        return platform as Platform;\r\n      }\r\n    }\r\n\r\n    return 'other';\r\n  } catch (error) {\r\n    return 'other';\r\n  }\r\n}\r\n\r\n/**\r\n * Validates if a string is a valid URL\r\n * @param url - The string to validate\r\n * @returns True if valid URL, false otherwise\r\n */\r\nexport function isValidUrl(url: string): boolean {\r\n  try {\r\n    new URL(url);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets platform configuration\r\n * @param platform - The platform type\r\n * @returns Platform configuration object\r\n */\r\nexport function getPlatformConfig(platform: Platform) {\r\n  return PLATFORM_CONFIG[platform] || PLATFORM_CONFIG['other'];\r\n}\r\n\r\n/**\r\n * Extracts domain from URL\r\n * @param url - The URL to extract domain from\r\n * @returns The domain name or empty string\r\n */\r\nexport function extractDomain(url: string): string {\r\n  try {\r\n    const urlObj = new URL(url);\r\n    return urlObj.hostname.replace('www.', '');\r\n  } catch {\r\n    return '';\r\n  }\r\n}\r\n\r\n/**\r\n * Mobile browser detection utilities\r\n */\r\nexport interface MobileBrowserInfo {\r\n  isMobile: boolean;\r\n  isIOS: boolean;\r\n  isAndroid: boolean;\r\n  isSafari: boolean;\r\n  isChrome: boolean;\r\n  isFirefox: boolean;\r\n  supportsPersistentStorage: boolean;\r\n  supportsBroadcastChannel: boolean;\r\n  userAgent: string;\r\n}\r\n\r\n/**\r\n * Detects mobile browser capabilities and limitations\r\n * @returns Mobile browser information\r\n */\r\nexport function detectMobileBrowser(): MobileBrowserInfo {\r\n  if (typeof window === 'undefined') {\r\n    return {\r\n      isMobile: false,\r\n      isIOS: false,\r\n      isAndroid: false,\r\n      isSafari: false,\r\n      isChrome: false,\r\n      isFirefox: false,\r\n      supportsPersistentStorage: true,\r\n      supportsBroadcastChannel: true,\r\n      userAgent: '',\r\n    };\r\n  }\r\n\r\n  const userAgent = navigator.userAgent.toLowerCase();\r\n  const isIOS = /iphone|ipad|ipod/.test(userAgent);\r\n  const isAndroid = /android/.test(userAgent);\r\n  const isMobile = isIOS || isAndroid || /mobile|tablet/.test(userAgent);\r\n  const isSafari = /safari/.test(userAgent) && !/chrome/.test(userAgent);\r\n  const isChrome = /chrome/.test(userAgent) && !/edg/.test(userAgent);\r\n  const isFirefox = /firefox/.test(userAgent);\r\n\r\n  // Determine storage capabilities based on browser and platform\r\n  let supportsPersistentStorage = true;\r\n\r\n  if (isIOS && isSafari) {\r\n    // Safari on iOS has very aggressive storage policies\r\n    supportsPersistentStorage = false;\r\n  } else if (isMobile && isChrome) {\r\n    // Chrome mobile has some limitations but better than Safari\r\n    supportsPersistentStorage = true;\r\n  } else if (isAndroid && isFirefox) {\r\n    // Firefox on Android is generally reliable\r\n    supportsPersistentStorage = true;\r\n  }\r\n\r\n  // Check for BroadcastChannel support (needed for cross-tab communication)\r\n  const supportsBroadcastChannel = typeof BroadcastChannel !== 'undefined';\r\n\r\n  return {\r\n    isMobile,\r\n    isIOS,\r\n    isAndroid,\r\n    isSafari,\r\n    isChrome,\r\n    isFirefox,\r\n    supportsPersistentStorage,\r\n    supportsBroadcastChannel,\r\n    userAgent,\r\n  };\r\n}\r\n\r\n/**\r\n * Checks if the current environment has reliable storage capabilities\r\n * @returns True if storage is reliable, false if it may be cleared\r\n */\r\nexport function hasReliableStorage(): boolean {\r\n  const browserInfo = detectMobileBrowser();\r\n\r\n  // Desktop browsers generally have reliable storage\r\n  if (!browserInfo.isMobile) {\r\n    return true;\r\n  }\r\n\r\n  // Mobile browsers with known storage issues\r\n  if (browserInfo.isIOS && browserInfo.isSafari) {\r\n    return false;\r\n  }\r\n\r\n  // Chrome mobile is generally reliable for foreground tabs\r\n  if (browserInfo.isAndroid && browserInfo.isChrome) {\r\n    return true;\r\n  }\r\n\r\n  // Default to cautious approach for unknown mobile browsers\r\n  return false;\r\n}\r\n\r\n/**\r\n * Safely checks if localStorage is available and functional\r\n * @returns True if localStorage is available and working\r\n */\r\nexport function isLocalStorageAvailable(): boolean {\r\n  if (typeof window === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const testKey = '__storage_test__';\r\n    localStorage.setItem(testKey, 'test');\r\n    localStorage.removeItem(testKey);\r\n    return true;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Safely checks if sessionStorage is available and functional\r\n * @returns True if sessionStorage is available and working\r\n */\r\nexport function isSessionStorageAvailable(): boolean {\r\n  if (typeof window === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const testKey = '__session_test__';\r\n    sessionStorage.setItem(testKey, 'test');\r\n    sessionStorage.removeItem(testKey);\r\n    return true;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the best available storage mechanism for the current browser\r\n * @returns 'localStorage', 'sessionStorage', or 'memory'\r\n */\r\nexport function getBestStorageMechanism(): 'localStorage' | 'sessionStorage' | 'memory' {\r\n  if (isLocalStorageAvailable()) {\r\n    return 'localStorage';\r\n  }\r\n\r\n  if (isSessionStorageAvailable()) {\r\n    return 'sessionStorage';\r\n  }\r\n\r\n  return 'memory';\r\n}\r\n\r\n/**\r\n * Determines if the current browser needs special session handling\r\n * @returns True if special mobile handling is needed\r\n */\r\nexport function needsMobileSessionHandling(): boolean {\r\n  const browserInfo = detectMobileBrowser();\r\n  return browserInfo.isMobile && (!browserInfo.supportsPersistentStorage || browserInfo.isIOS);\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\utils\\sanitization.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":14,"column":37,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/utils/sanitization.ts\r\n * @description Input sanitization utilities to prevent XSS and other injection attacks\r\n * @created 2025-11-11\r\n */\r\n\r\n// Simple sanitization without external dependencies\r\n\r\n/**\r\n * Sanitizes a string to prevent XSS attacks\r\n * @param {string} input - The string to sanitize\r\n * @returns {string} Sanitized string\r\n */\r\nexport function sanitizeString(input: string): string {\r\n  if (typeof input !== 'string') {\r\n    return '';\r\n  }\r\n\r\n  // Simple but effective sanitization without external dependencies\r\n  return input\r\n    .replace(/[<>]/g, '') // Remove angle brackets to prevent HTML injection\r\n    .replace(/&/g, '&') // Escape ampersands\r\n    .replace(/\\\"/g, '\"') // Escape quotes\r\n    .replace(/\\'/g, '&#x27;') // Escape single quotes\r\n    .replace(/\\//g, '&#x2F;') // Escape forward slashes\r\n    .trim();\r\n}\r\n\r\n/**\r\n * Sanitizes link data to prevent XSS and injection attacks\r\n * @param {Partial<Link> | Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>} data - Link data to sanitize\r\n * @returns {Partial<Link> | Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>} Sanitized link data\r\n */\r\nexport function sanitizeLinkData(\r\n  data: Partial<any> | Omit<any, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>\r\n): any {\r\n  const sanitized: any = {};\r\n\r\n  if (data.url !== undefined) {\r\n    // URL should be validated, not just sanitized\r\n    sanitized.url = validateAndSanitizeUrl(data.url);\r\n  }\r\n\r\n  if (data.title !== undefined) {\r\n    sanitized.title = sanitizeString(String(data.title)).substring(0, 200);\r\n  }\r\n\r\n  if (data.description !== undefined) {\r\n    sanitized.description = sanitizeString(String(data.description)).substring(0, 500);\r\n  }\r\n\r\n  if (data.thumbnail !== undefined) {\r\n    sanitized.thumbnail = validateAndSanitizeUrl(data.thumbnail);\r\n  }\r\n\r\n  if (data.faviconUrl !== undefined) {\r\n    sanitized.faviconUrl = validateAndSanitizeUrl(data.faviconUrl);\r\n  }\r\n\r\n  if (data.platform !== undefined) {\r\n    sanitized.platform = sanitizeString(String(data.platform)).substring(0, 50);\r\n  }\r\n\r\n  if (data.folderId !== undefined) {\r\n    sanitized.folderId = data.folderId; // UUID, validate format\r\n    if (data.folderId && !isValidUuid(data.folderId)) {\r\n      throw new Error('Invalid folder ID format');\r\n    }\r\n  }\r\n\r\n  if (data.isFavorite !== undefined) {\r\n    sanitized.isFavorite = Boolean(data.isFavorite);\r\n  }\r\n\r\n  if (data.tags !== undefined) {\r\n    sanitized.tags = Array.isArray(data.tags)\r\n      ? data.tags\r\n          .map((tag: any) => sanitizeString(String(tag)).substring(0, 50))\r\n          .filter((tag: string) => tag.length > 0)\r\n      : [];\r\n  }\r\n\r\n  if (data.deletedAt !== undefined) {\r\n    sanitized.deletedAt = data.deletedAt; // Should be ISO date string or null\r\n  }\r\n\r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Sanitizes folder data to prevent XSS and injection attacks\r\n * @param {Partial<Folder> | Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>} data - Folder data to sanitize\r\n * @returns {Partial<Folder> | Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>} Sanitized folder data\r\n */\r\nexport function sanitizeFolderData(\r\n  data: Partial<any> | Omit<any, 'id' | 'createdAt' | 'updatedAt'>\r\n): any {\r\n  const sanitized: any = {};\r\n\r\n  if (data.name !== undefined) {\r\n    sanitized.name = sanitizeString(String(data.name)).substring(0, 100);\r\n    if (!sanitized.name || sanitized.name.length === 0) {\r\n      throw new Error('Folder name cannot be empty');\r\n    }\r\n  }\r\n\r\n  if (data.description !== undefined) {\r\n    sanitized.description = data.description \r\n      ? sanitizeString(String(data.description)).substring(0, 500)\r\n      : null;\r\n  }\r\n\r\n  if (data.color !== undefined) {\r\n    sanitized.color = validateAndSanitizeColor(data.color);\r\n  }\r\n\r\n  if (data.icon !== undefined) {\r\n    sanitized.icon = sanitizeString(String(data.icon)).substring(0, 50);\r\n  }\r\n\r\n  if (data.parentId !== undefined) {\r\n    sanitized.parentId = data.parentId; // UUID or null\r\n    if (data.parentId && !isValidUuid(data.parentId)) {\r\n      throw new Error('Invalid parent folder ID format');\r\n    }\r\n  }\r\n\r\n  if (data.isPlatformFolder !== undefined) {\r\n    sanitized.isPlatformFolder = Boolean(data.isPlatformFolder);\r\n  }\r\n\r\n  if (data.platform !== undefined) {\r\n    sanitized.platform = data.platform \r\n      ? sanitizeString(String(data.platform)).substring(0, 50)\r\n      : null;\r\n  }\r\n\r\n  return sanitized;\r\n}\r\n\r\n/**\r\n * Validates and sanitizes a URL\r\n * @param {string} url - URL to validate and sanitize\r\n * @returns {string} Sanitized URL or empty string if invalid\r\n */\r\nfunction validateAndSanitizeUrl(url: any): string {\r\n  if (!url || typeof url !== 'string') {\r\n    return '';\r\n  }\r\n\r\n  try {\r\n    // Parse URL to validate structure\r\n    const parsedUrl = new URL(url);\r\n    \r\n    // Only allow http and https protocols\r\n    if (!['http:', 'https:'].includes(parsedUrl.protocol)) {\r\n      return '';\r\n    }\r\n\r\n    // Block private IP ranges and localhost in production\r\n    if (process.env.NODE_ENV === 'production') {\r\n      const hostname = parsedUrl.hostname.toLowerCase();\r\n      const blockedPatterns = [\r\n        /^localhost$/i,\r\n        /^127\\./,\r\n        /^10\\./,\r\n        /^172\\.(1[6-9]|2[0-9]|3[0-1])\\./,\r\n        /^192\\.168\\./,\r\n        /^169\\.254\\./,\r\n        /^::1$/,\r\n        /^fc00:/,\r\n        /^fe80:/,\r\n        /\\.local$/i,\r\n        /\\.internal$/i,\r\n      ];\r\n\r\n      if (blockedPatterns.some(pattern => pattern.test(hostname))) {\r\n        throw new Error('Private IP addresses and localhost are not allowed');\r\n      }\r\n    }\r\n\r\n    // Return the validated URL\r\n    return parsedUrl.toString();\r\n  } catch (error) {\r\n    // If URL parsing fails, return empty string\r\n    return '';\r\n  }\r\n}\r\n\r\n/**\r\n * Validates and sanitizes a color hex code\r\n * @param {string} color - Color hex code to validate\r\n * @returns {string} Validated color hex code or default blue\r\n */\r\nfunction validateAndSanitizeColor(color: any): string {\r\n  if (!color || typeof color !== 'string') {\r\n    return '#3B82F6'; // Default blue\r\n  }\r\n\r\n  // Match hex color pattern (#RRGGBB)\r\n  const hexColorRegex = /^#[0-9A-Fa-f]{6}$/;\r\n  const sanitized = color.trim();\r\n\r\n  return hexColorRegex.test(sanitized) ? sanitized : '#3B82F6';\r\n}\r\n\r\n/**\r\n * Validates UUID format\r\n * @param {string} uuid - UUID to validate\r\n * @returns {boolean} Whether the string is a valid UUID\r\n */\r\nfunction isValidUuid(uuid: string): boolean {\r\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n  return uuidRegex.test(uuid);\r\n}\r\n\r\n/**\r\n * Sanitizes search query to prevent injection attacks\r\n * @param {string} query - Search query to sanitize\r\n * @returns {string} Sanitized search query\r\n */\r\nexport function sanitizeSearchQuery(query: string): string {\r\n  if (typeof query !== 'string') {\r\n    return '';\r\n  }\r\n\r\n  // Remove special characters that could be used for injection\r\n  return query\r\n    .replace(/[<>\\\"';&]/g, '') // Remove dangerous characters\r\n    .trim()\r\n    .substring(0, 200); // Limit length\r\n}\r\n\r\n/**\r\n * Sanitizes user settings data\r\n * @param {any} settings - Settings data to sanitize\r\n * @returns {any} Sanitized settings\r\n */\r\nexport function sanitizeSettingsData(settings: any): any {\r\n  const sanitized: any = {};\r\n\r\n  if (settings.theme !== undefined) {\r\n    const validThemes = ['light', 'dark', 'system'];\r\n    sanitized.theme = validThemes.includes(settings.theme) ? settings.theme : 'system';\r\n  }\r\n\r\n  if (settings.viewMode !== undefined) {\r\n    const validViewModes = ['grid', 'list'];\r\n    sanitized.viewMode = validViewModes.includes(settings.viewMode) ? settings.viewMode : 'grid';\r\n  }\r\n\r\n  return sanitized;\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\utils\\session-manager.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token {","line":12,"column":13,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/utils/session-manager.ts\r\n * @description Enhanced session management for cross-browser compatibility\r\n * @created 2025-11-12\r\n * \r\n * Handles session persistence across all browsers including Safari iOS/desktop,\r\n * Chrome mobile, and other browsers with aggressive storage clearing policies.\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { logger } from './logger';\r\nimport type { Session, User } from '@supabase/supabase-js';\r\n\r\ninterface SessionBackup {\r\n  accessToken: string;\r\n  refreshToken: string;\r\n  user: User;\r\n  expiresAt: number;\r\n  lastValidated: number;\r\n}\r\n\r\n/**\r\n * Enhanced Session Manager with multi-strategy persistence\r\n * \r\n * Strategies:\r\n * 1. Supabase native session (primary)\r\n * 2. localStorage backup (secondary)\r\n * 3. sessionStorage backup (tertiary - for Safari private mode)\r\n * 4. IndexedDB backup (quaternary - for Safari storage limits)\r\n * 5. In-memory cache (fallback)\r\n */\r\nexport class SessionManager {\r\n  private static instance: SessionManager | null = null;\r\n  private supabase = createClient();\r\n  private refreshInterval: NodeJS.Timeout | null = null;\r\n  private inMemorySession: Session | null = null;\r\n  private isMobile: boolean = false;\r\n  private isSafari: boolean = false;\r\n  private isPrivateMode: boolean = false;\r\n\r\n  private constructor() {\r\n    if (typeof window !== 'undefined') {\r\n      // Detect browser type\r\n      this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n      this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n\r\n      // Detect private/incognito mode\r\n      this.detectPrivateMode();\r\n\r\n      // Setup auto-refresh\r\n      this.setupAutoRefresh();\r\n\r\n      // Setup visibility change listener (for mobile)\r\n      this.setupVisibilityListener();\r\n\r\n      // Setup storage listener (for multi-tab sync)\r\n      this.setupStorageListener();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get singleton instance\r\n   */\r\n  static getInstance(): SessionManager {\r\n    if (!SessionManager.instance) {\r\n      SessionManager.instance = new SessionManager();\r\n    }\r\n    return SessionManager.instance;\r\n  }\r\n\r\n  /**\r\n   * Detect if browser is in private/incognito mode\r\n   */\r\n  private async detectPrivateMode(): Promise<void> {\r\n    try {\r\n      // Try to use localStorage\r\n      localStorage.setItem('__test__', 'test');\r\n      localStorage.removeItem('__test__');\r\n      this.isPrivateMode = false;\r\n    } catch (e) {\r\n      this.isPrivateMode = true;\r\n      logger.warn('Private/Incognito mode detected, using alternative storage');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enhanced session validation with multiple fallback strategies\r\n   */\r\n  async validateSession(): Promise<Session | null> {\r\n    try {\r\n      // Strategy 1: Try Supabase native session\r\n      const { data: { session }, error } = await this.supabase.auth.getSession();\r\n\r\n      if (!error && session) {\r\n        // Valid session found\r\n        await this.backupSession(session);\r\n        this.inMemorySession = session;\r\n        return session;\r\n      }\r\n\r\n      // Strategy 2: Try to recover from backups\r\n      if (this.isMobile || this.isSafari) {\r\n        logger.debug('Primary session failed, attempting recovery...');\r\n        return await this.recoverSession();\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      logger.error('Session validation error:', error);\r\n\r\n      // Try recovery as last resort\r\n      return await this.recoverSession();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Backup session to multiple storage locations\r\n   */\r\n  private async backupSession(session: Session): Promise<void> {\r\n    const backup: SessionBackup = {\r\n      accessToken: session.access_token,\r\n      refreshToken: session.refresh_token,\r\n      user: session.user,\r\n      expiresAt: session.expires_at || 0,\r\n      lastValidated: Date.now(),\r\n    };\r\n\r\n    const backupString = JSON.stringify(backup);\r\n\r\n    try {\r\n      // Backup to localStorage (if available)\r\n      if (!this.isPrivateMode) {\r\n        localStorage.setItem('linkvault_session_backup', backupString);\r\n      }\r\n\r\n      // Backup to sessionStorage (works in private mode)\r\n      sessionStorage.setItem('linkvault_session_backup', backupString);\r\n\r\n      // Backup to IndexedDB (for Safari)\r\n      if (this.isSafari) {\r\n        await this.saveToIndexedDB('session_backup', backup);\r\n      }\r\n    } catch (error) {\r\n      logger.warn('Failed to backup session:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recover session from backup storage\r\n   */\r\n  private async recoverSession(): Promise<Session | null> {\r\n    try {\r\n      let backup: SessionBackup | null = null;\r\n\r\n      // Try in-memory cache first (fastest)\r\n      if (this.inMemorySession) {\r\n        const now = Date.now();\r\n        const expiresAt = this.inMemorySession.expires_at ? this.inMemorySession.expires_at * 1000 : 0;\r\n\r\n        if (now < expiresAt) {\r\n          logger.debug('Session recovered from memory cache');\r\n          return this.inMemorySession;\r\n        }\r\n      }\r\n\r\n      // Try localStorage\r\n      if (!this.isPrivateMode) {\r\n        const stored = localStorage.getItem('linkvault_session_backup');\r\n        if (stored) {\r\n          backup = JSON.parse(stored);\r\n          logger.debug('Session recovered from localStorage');\r\n        }\r\n      }\r\n\r\n      // Try sessionStorage\r\n      if (!backup) {\r\n        const stored = sessionStorage.getItem('linkvault_session_backup');\r\n        if (stored) {\r\n          backup = JSON.parse(stored);\r\n          logger.debug('Session recovered from sessionStorage');\r\n        }\r\n      }\r\n\r\n      // Try IndexedDB (Safari)\r\n      if (!backup && this.isSafari) {\r\n        backup = await this.getFromIndexedDB('session_backup');\r\n        if (backup) {\r\n          logger.debug('Session recovered from IndexedDB');\r\n        }\r\n      }\r\n\r\n      // Validate and restore backup\r\n      if (backup) {\r\n        const now = Date.now();\r\n        const backupAge = now - backup.lastValidated;\r\n\r\n        // Backup must be less than 7 days old\r\n        if (backupAge < 7 * 24 * 60 * 60 * 1000) {\r\n          // Try to restore session\r\n          const { data, error } = await this.supabase.auth.setSession({\r\n            access_token: backup.accessToken,\r\n            refresh_token: backup.refreshToken,\r\n          });\r\n\r\n          if (!error && data.session) {\r\n            logger.info('Session successfully recovered and restored');\r\n            this.inMemorySession = data.session;\r\n            return data.session;\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      logger.error('Session recovery failed:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Refresh session if needed\r\n   */\r\n  async refreshIfNeeded(): Promise<Session | null> {\r\n    try {\r\n      const { data: { session }, error } = await this.supabase.auth.refreshSession();\r\n\r\n      if (!error && session) {\r\n        await this.backupSession(session);\r\n        this.inMemorySession = session;\r\n        logger.debug('Session refreshed successfully');\r\n        return session;\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      logger.error('Session refresh failed:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup automatic session refresh\r\n   * Refreshes every 5 minutes or 30 minutes before expiry (whichever is shorter)\r\n   */\r\n  private setupAutoRefresh(): void {\r\n    // Clear existing interval\r\n    if (this.refreshInterval) {\r\n      clearInterval(this.refreshInterval);\r\n    }\r\n\r\n    // Refresh every 5 minutes\r\n    this.refreshInterval = setInterval(async () => {\r\n      await this.refreshIfNeeded();\r\n    }, 5 * 60 * 1000);\r\n  }\r\n\r\n  /**\r\n   * Setup visibility change listener (mobile-specific)\r\n   * Revalidates session when app comes to foreground\r\n   */\r\n  private setupVisibilityListener(): void {\r\n    document.addEventListener('visibilitychange', async () => {\r\n      if (document.visibilityState === 'visible') {\r\n        logger.debug('App visible, revalidating session...');\r\n        await this.validateSession();\r\n      }\r\n    });\r\n\r\n    // Also listen for focus events\r\n    window.addEventListener('focus', async () => {\r\n      logger.debug('Window focused, revalidating session...');\r\n      await this.validateSession();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if user has explicitly logged out to prevent session recovery\r\n   */\r\n  private hasUserLoggedOut(): boolean {\r\n    if (typeof window === 'undefined') return false;\r\n\r\n    try {\r\n      const localStorageLogout = localStorage.getItem('user_logged_out');\r\n      const sessionStorageLogout = sessionStorage.getItem('user_logged_out');\r\n\r\n      // Check if logout marker exists and is recent (within last 10 minutes)\r\n      const now = Date.now();\r\n      const tenMinutes = 10 * 60 * 1000;\r\n\r\n      if (localStorageLogout && (now - parseInt(localStorageLogout)) < tenMinutes) {\r\n        return true;\r\n      }\r\n\r\n      if (sessionStorageLogout && (now - parseInt(sessionStorageLogout)) < tenMinutes) {\r\n        return true;\r\n      }\r\n\r\n      // Clean up old logout markers to prevent indefinite blocking\r\n      if (localStorageLogout && (now - parseInt(localStorageLogout)) >= tenMinutes) {\r\n        localStorage.removeItem('user_logged_out');\r\n      }\r\n\r\n      if (sessionStorageLogout && (now - parseInt(sessionStorageLogout)) >= tenMinutes) {\r\n        sessionStorage.removeItem('user_logged_out');\r\n      }\r\n\r\n      return false;\r\n    } catch (error) {\r\n      logger.warn('Error checking logout status:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup storage listener for multi-tab sync\r\n   */\r\n  private setupStorageListener(): void {\r\n    window.addEventListener('storage', (event) => {\r\n      if (event.key === 'linkvault_session_backup' && event.newValue) {\r\n        // Don't sync session if user has explicitly logged out\r\n        if (this.hasUserLoggedOut()) {\r\n          logger.debug('Session sync blocked - user explicitly logged out');\r\n          return;\r\n        }\r\n\r\n        logger.debug('Session updated in another tab');\r\n        try {\r\n          const backup: SessionBackup = JSON.parse(event.newValue);\r\n          // Update in-memory cache\r\n          if (backup.accessToken) {\r\n            this.supabase.auth.setSession({\r\n              access_token: backup.accessToken,\r\n              refresh_token: backup.refreshToken,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          logger.warn('Failed to sync session from another tab:', error);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save data to IndexedDB (for Safari)\r\n   */\r\n  private async saveToIndexedDB(key: string, value: any): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const request = indexedDB.open('LinkVaultDB', 1);\r\n\r\n        request.onerror = () => reject(request.error);\r\n\r\n        request.onupgradeneeded = (event) => {\r\n          const db = (event.target as IDBOpenDBRequest).result;\r\n          if (!db.objectStoreNames.contains('sessions')) {\r\n            db.createObjectStore('sessions');\r\n          }\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n          const db = request.result;\r\n          const transaction = db.transaction(['sessions'], 'readwrite');\r\n          const store = transaction.objectStore('sessions');\r\n          store.put(value, key);\r\n\r\n          transaction.oncomplete = () => {\r\n            db.close();\r\n            resolve();\r\n          };\r\n\r\n          transaction.onerror = () => reject(transaction.error);\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get data from IndexedDB (for Safari)\r\n   */\r\n  private async getFromIndexedDB(key: string): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const request = indexedDB.open('LinkVaultDB', 1);\r\n\r\n        request.onerror = () => reject(request.error);\r\n\r\n        request.onsuccess = () => {\r\n          const db = request.result;\r\n\r\n          if (!db.objectStoreNames.contains('sessions')) {\r\n            db.close();\r\n            resolve(null);\r\n            return;\r\n          }\r\n\r\n          const transaction = db.transaction(['sessions'], 'readonly');\r\n          const store = transaction.objectStore('sessions');\r\n          const getRequest = store.get(key);\r\n\r\n          getRequest.onsuccess = () => {\r\n            db.close();\r\n            resolve(getRequest.result);\r\n          };\r\n\r\n          getRequest.onerror = () => {\r\n            db.close();\r\n            reject(getRequest.error);\r\n          };\r\n        };\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear all session data with enhanced cleanup\r\n   */\r\n  async clearSession(): Promise<void> {\r\n    try {\r\n      // Mark session as explicitly logged out to prevent recovery\r\n      if (typeof window !== 'undefined') {\r\n        localStorage.setItem('user_logged_out', Date.now().toString());\r\n        sessionStorage.setItem('user_logged_out', Date.now().toString());\r\n      }\r\n\r\n      // Clear Supabase session\r\n      await this.supabase.auth.signOut();\r\n\r\n      // Clear all auth-related storage\r\n      const storageKeys = [\r\n        'linkvault_session_backup',\r\n        'supabase.auth.token',\r\n        'sb-' + (process.env.NEXT_PUBLIC_SUPABASE_URL?.split('//')[1]?.split('.')[0] || '') + '-auth-token'\r\n      ];\r\n\r\n      storageKeys.forEach(key => {\r\n        if (!this.isPrivateMode) {\r\n          localStorage.removeItem(key);\r\n        }\r\n        sessionStorage.removeItem(key);\r\n      });\r\n\r\n      // Clear IndexedDB\r\n      if (this.isSafari) {\r\n        await this.saveToIndexedDB('session_backup', null);\r\n        // Also clear any other session data\r\n        await this.saveToIndexedDB('supabase_session', null);\r\n      }\r\n\r\n      // Clear cookies\r\n      if (typeof document !== 'undefined') {\r\n        const cookies = document.cookie.split(';');\r\n        cookies.forEach(cookie => {\r\n          const eqPos = cookie.indexOf('=');\r\n          const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();\r\n          if (name.startsWith('sb-') || name.includes('supabase') || name.includes('auth') || name.includes('session')) {\r\n            const domains = [\r\n              window.location.hostname,\r\n              `.${window.location.hostname}`,\r\n              ''\r\n            ];\r\n            domains.forEach(domain => {\r\n              document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;${domain ? `domain=${domain};` : ''}secure;samesite=lax`;\r\n            });\r\n          }\r\n        });\r\n      }\r\n\r\n      // Clear in-memory cache\r\n      this.inMemorySession = null;\r\n\r\n      logger.debug('Session cleared from all storage and cookies');\r\n    } catch (error) {\r\n      logger.error('Failed to clear session:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  destroy(): void {\r\n    if (this.refreshInterval) {\r\n      clearInterval(this.refreshInterval);\r\n      this.refreshInterval = null;\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const sessionManager = SessionManager.getInstance();\r\nexport default sessionManager;\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\lib\\utils\\type-guards.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":12,"column":29,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file lib/utils/type-guards.ts\r\n * @description Runtime type guards for type safety\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { Link, Folder, AppSettings, Platform } from '@/types';\r\n\r\n/**\r\n * Type guard for Link\r\n */\r\nexport function isLink(value: unknown): value is Link {\r\n  if (!value || typeof value !== 'object') return false;\r\n  \r\n  const obj = value as Record<string, unknown>;\r\n  return (\r\n    typeof obj.id === 'string' &&\r\n    typeof obj.url === 'string' &&\r\n    typeof obj.title === 'string' &&\r\n    typeof obj.description === 'string' &&\r\n    typeof obj.thumbnail === 'string' &&\r\n    typeof obj.platform === 'string' &&\r\n    typeof obj.isFavorite === 'boolean' &&\r\n    (obj.folderId === null || typeof obj.folderId === 'string') &&\r\n    (obj.deletedAt === null || typeof obj.deletedAt === 'string') &&\r\n    typeof obj.createdAt === 'string' &&\r\n    typeof obj.updatedAt === 'string'\r\n  );\r\n}\r\n\r\n/**\r\n * Type guard for Folder\r\n */\r\nexport function isFolder(value: unknown): value is Folder {\r\n  if (!value || typeof value !== 'object') return false;\r\n  \r\n  const obj = value as Record<string, unknown>;\r\n  return (\r\n    typeof obj.id === 'string' &&\r\n    typeof obj.name === 'string' &&\r\n    typeof obj.color === 'string' &&\r\n    typeof obj.icon === 'string' &&\r\n    typeof obj.isPlatformFolder === 'boolean' &&\r\n    (obj.parentId === null || typeof obj.parentId === 'string') &&\r\n    typeof obj.createdAt === 'string' &&\r\n    typeof obj.updatedAt === 'string'\r\n  );\r\n}\r\n\r\n/**\r\n * Type guard for AppSettings\r\n */\r\nexport function isAppSettings(value: unknown): value is AppSettings {\r\n  if (!value || typeof value !== 'object') return false;\r\n  \r\n  const obj = value as Record<string, unknown>;\r\n  return (\r\n    (obj.theme === 'light' || obj.theme === 'dark' || obj.theme === 'system') &&\r\n    (obj.viewMode === 'grid' || obj.viewMode === 'list')\r\n  );\r\n}\r\n\r\n/**\r\n * Type guard for Platform\r\n */\r\nexport function isPlatform(value: unknown): value is Platform {\r\n  return (\r\n    typeof value === 'string' &&\r\n    [\r\n      'youtube',\r\n      'twitter',\r\n      'instagram',\r\n      'linkedin',\r\n      'tiktok',\r\n      'github',\r\n      'medium',\r\n      'reddit',\r\n      'facebook',\r\n      'other',\r\n    ].includes(value)\r\n  );\r\n}\r\n\r\n/**\r\n * Type guard for array of Links\r\n */\r\nexport function isLinkArray(value: unknown): value is Link[] {\r\n  return Array.isArray(value) && value.every(isLink);\r\n}\r\n\r\n/**\r\n * Type guard for array of Folders\r\n */\r\nexport function isFolderArray(value: unknown): value is Folder[] {\r\n  return Array.isArray(value) && value.every(isFolder);\r\n}\r\n\r\n/**\r\n * Type guard for valid URL string\r\n */\r\nexport function isValidUrl(value: unknown): value is string {\r\n  if (typeof value !== 'string') return false;\r\n  try {\r\n    new URL(value);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Type guard for non-empty string\r\n */\r\nexport function isNonEmptyString(value: unknown): value is string {\r\n  return typeof value === 'string' && value.trim().length > 0;\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\middleware.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token NextRequest","line":8,"column":29,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file middleware.ts\r\n * @description Enhanced middleware with improved authentication handling and error recovery\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { createServerClient } from '@supabase/ssr';\r\nimport { NextResponse, type NextRequest } from 'next/server';\r\n\r\n// Simple logger for Edge runtime (can't use Node.js modules)\r\nconst logger = {\r\n  error: (...args: unknown[]) => {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.error('[Middleware]', ...args);\r\n    }\r\n  },\r\n  warn: (...args: unknown[]) => {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.warn('[Middleware]', ...args);\r\n    }\r\n  },\r\n  debug: (...args: unknown[]) => {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.debug('[Middleware]', ...args);\r\n    }\r\n  },\r\n};\r\n\r\ninterface RetryConfig {\r\n  maxRetries: number;\r\n  baseDelay: number;\r\n  maxDelay: number;\r\n}\r\n\r\n// OPTIMIZED: Reduced retries from 3 to 1 for faster response\r\n// Session checks are fast, retries usually only help with network glitches\r\nconst RETRY_CONFIG: RetryConfig = {\r\n  maxRetries: 1, // Reduced from 3\r\n  baseDelay: 300, // Reduced from 500ms\r\n  maxDelay: 1000, // Reduced from 5000ms\r\n};\r\n\r\n/**\r\n * Exponential backoff retry mechanism\r\n * @param {Function} operation - Operation to retry\r\n * @param {number} attempt - Current attempt number\r\n * @returns {Promise<T>} Operation result\r\n */\r\nasync function retryWithBackoff<T>(\r\n  operation: () => Promise<T>,\r\n  attempt: number = 0\r\n): Promise<T> {\r\n  try {\r\n    return await operation();\r\n  } catch (error) {\r\n    if (attempt >= RETRY_CONFIG.maxRetries) {\r\n      throw error;\r\n    }\r\n\r\n    const delay = Math.min(\r\n      RETRY_CONFIG.baseDelay * Math.pow(2, attempt),\r\n      RETRY_CONFIG.maxDelay\r\n    );\r\n\r\n    // Only log retries in development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      logger.warn(`Middleware operation failed, retrying in ${delay}ms (attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries})`);\r\n    }\r\n\r\n    await new Promise(resolve => setTimeout(resolve, delay));\r\n    return retryWithBackoff(operation, attempt + 1);\r\n  }\r\n}\r\n\r\n/**\r\n * Check if the path requires authentication\r\n * @param {string} pathname - Request pathname\r\n * @returns {boolean} Whether authentication is required\r\n */\r\nfunction requiresAuth(pathname: string): boolean {\r\n  if (pathname === '/') return false;\r\n  const publicPaths = ['/login', '/signup', '/auth', '/api/auth', '/share'];\r\n  return !publicPaths.some(path => pathname.startsWith(path));\r\n}\r\n\r\n/**\r\n * Check if the path is an auth page\r\n * @param {string} pathname - Request pathname\r\n * @returns {boolean} Whether it's an auth page\r\n */\r\nfunction isAuthPage(pathname: string): boolean {\r\n  return pathname.startsWith('/login') || pathname.startsWith('/signup');\r\n}\r\n\r\n/**\r\n * Enhanced middleware with improved error handling and session management\r\n * @param {NextRequest} request - Next.js request object\r\n * @returns {Promise<NextResponse>} Response object\r\n */\r\nexport async function middleware(request: NextRequest): Promise<NextResponse> {\r\n  const { pathname } = request.nextUrl;\r\n\r\n  // Skip middleware for static files and API routes (except auth)\r\n  if (\r\n    pathname.startsWith('/_next/') ||\r\n    pathname.startsWith('/api/') && !pathname.startsWith('/api/auth') ||\r\n    pathname.includes('.') && !pathname.endsWith('.html')\r\n  ) {\r\n    return NextResponse.next();\r\n  }\r\n\r\n  let response = NextResponse.next({\r\n    request: {\r\n      headers: request.headers,\r\n    },\r\n  });\r\n\r\n  try {\r\n    // OPTIMIZATION: Skip expensive retry logic on auth pages where session isn't expected\r\n    // This significantly speeds up the login page load\r\n    const skipRetries = isAuthPage(pathname);\r\n\r\n    // Create Supabase client\r\n    const supabase = skipRetries\r\n      ? createServerClient(\r\n        process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n        {\r\n          cookies: {\r\n            getAll() {\r\n              return request.cookies.getAll();\r\n            },\r\n            setAll(cookiesToSet) {\r\n              cookiesToSet.forEach(({ name, value, options }) => {\r\n                request.cookies.set(name, value);\r\n                response.cookies.set(name, value, options);\r\n              });\r\n            },\r\n          },\r\n        }\r\n      )\r\n      : await retryWithBackoff(async () => {\r\n        return createServerClient(\r\n          process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n          {\r\n            cookies: {\r\n              getAll() {\r\n                return request.cookies.getAll();\r\n              },\r\n              setAll(cookiesToSet) {\r\n                cookiesToSet.forEach(({ name, value, options }) => {\r\n                  request.cookies.set(name, value);\r\n                  response.cookies.set(name, value, options);\r\n                });\r\n              },\r\n            },\r\n          }\r\n        );\r\n      });\r\n\r\n    // Get user session (skip retries on auth pages for performance)\r\n    const { data: { session }, error: sessionError } = skipRetries\r\n      ? await supabase.auth.getSession()\r\n      : await retryWithBackoff(async () => {\r\n        return supabase.auth.getSession();\r\n      });\r\n\r\n    if (sessionError) {\r\n      logger.error('Auth error in middleware:', sessionError);\r\n\r\n      // Handle specific session errors\r\n      if (sessionError.message?.includes('AuthSessionMissingError')) {\r\n        // Session is missing, redirect to login if auth is required\r\n        if (requiresAuth(pathname)) {\r\n          const loginUrl = new URL('/login', request.url);\r\n          loginUrl.searchParams.set('redirectTo', pathname);\r\n          return NextResponse.redirect(loginUrl);\r\n        }\r\n        return response;\r\n      }\r\n\r\n      // For other auth errors, allow the request to continue but log the error\r\n      if (process.env.NODE_ENV === 'development') {\r\n        logger.warn('Non-critical auth error, continuing:', sessionError);\r\n      }\r\n    }\r\n\r\n    const isAuthenticated = !!session?.user;\r\n\r\n    // Handle authenticated users trying to access auth pages\r\n    if (isAuthenticated && isAuthPage(pathname)) {\r\n      const redirectTo = request.nextUrl.searchParams.get('redirectTo') || '/app';\r\n      return NextResponse.redirect(new URL(redirectTo, request.url));\r\n    }\r\n\r\n    // Handle unauthenticated users trying to access protected pages\r\n    // BUT: Don't redirect if we're already on login page (prevents redirect loops)\r\n    if (!isAuthenticated && requiresAuth(pathname) && !isAuthPage(pathname)) {\r\n      const loginUrl = new URL('/login', request.url);\r\n      loginUrl.searchParams.set('redirectTo', pathname);\r\n      return NextResponse.redirect(loginUrl);\r\n    }\r\n\r\n    // CRITICAL: Allow authenticated users to access /app without redirecting\r\n    // This ensures session persistence works correctly\r\n    if (isAuthenticated && pathname.startsWith('/app')) {\r\n      return response;\r\n    }\r\n\r\n    // OPTIMIZED: Refresh session proactively (within 15 minutes instead of 5)\r\n    // This reduces the number of refresh operations while ensuring session stays valid\r\n    // Only refresh on protected routes to avoid unnecessary work on public pages\r\n    if (session?.expires_at && requiresAuth(pathname)) {\r\n      const expiresAt = session.expires_at * 1000;\r\n      const now = Date.now();\r\n      const fifteenMinutes = 15 * 60 * 1000; // Increased from 5 to 15 minutes\r\n\r\n      if (expiresAt - now < fifteenMinutes) {\r\n        try {\r\n          await retryWithBackoff(async () => {\r\n            const { error } = await supabase.auth.refreshSession();\r\n            if (error) throw error;\r\n          });\r\n        } catch (refreshError) {\r\n          logger.error('Session refresh failed in middleware:', refreshError);\r\n          // If refresh fails and we're on a protected route, redirect to login\r\n          const loginUrl = new URL('/login', request.url);\r\n          loginUrl.searchParams.set('redirectTo', pathname);\r\n          return NextResponse.redirect(loginUrl);\r\n        }\r\n      }\r\n    }\r\n\r\n    return response;\r\n\r\n  } catch (error) {\r\n    logger.error('Critical middleware error:', error);\r\n\r\n    // For critical errors, handle gracefully\r\n    if (requiresAuth(pathname)) {\r\n      // If it's a protected route and we have a critical error, redirect to login\r\n      const loginUrl = new URL('/login', request.url);\r\n      loginUrl.searchParams.set('redirectTo', pathname);\r\n      loginUrl.searchParams.set('error', 'session_error');\r\n      return NextResponse.redirect(loginUrl);\r\n    }\r\n\r\n    // For public routes, allow the request to continue\r\n    return response;\r\n  }\r\n}\r\n\r\nexport const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except for the ones starting with:\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization files)\r\n     * - favicon.ico (favicon file)\r\n     * - public folder files\r\n     */\r\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\r\n  ],\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\scripts\\debug-share.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\services\\auth.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":26,"column":21,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file services/auth.service.ts\r\n * @description Authentication service\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { User } from '@supabase/supabase-js';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\nconst supabase = createClient();\r\n\r\n/**\r\n * Authentication service\r\n * Handles all authentication-related operations\r\n */\r\nexport const authService = {\r\n  /**\r\n   * Signs in a user with email and password\r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @returns {Promise<User>} Authenticated user\r\n   * @throws {Error} When authentication fails\r\n   */\r\n  async signIn(email: string, password: string): Promise<User> {\r\n    const { data, error } = await supabase.auth.signInWithPassword({\r\n      email,\r\n      password,\r\n    });\r\n    \r\n    if (error) {\r\n      logger.error('Sign in error:', {\r\n        error: error.message,\r\n        email,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n    \r\n    if (!data.user) {\r\n      const error = new Error('No user data returned from authentication');\r\n      logger.error('Sign in error:', {\r\n        error: error.message,\r\n        email,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n    \r\n    logger.info('User signed in successfully', { userId: data.user.id });\r\n    return data.user;\r\n  },\r\n  \r\n  /**\r\n   * Signs up a new user with email and password\r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @returns {Promise<User>} Registered user\r\n   * @throws {Error} When registration fails\r\n   */\r\n  async signUp(email: string, password: string): Promise<User> {\r\n    const { data, error } = await supabase.auth.signUp({\r\n      email,\r\n      password,\r\n    });\r\n    \r\n    if (error) {\r\n      logger.error('Sign up error:', {\r\n        error: error.message,\r\n        email,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n    \r\n    if (!data.user) {\r\n      const error = new Error('No user data returned from registration');\r\n      logger.error('Sign up error:', {\r\n        error: error.message,\r\n        email,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n    \r\n    logger.info('User signed up successfully', { userId: data.user.id });\r\n    return data.user;\r\n  },\r\n  \r\n  /**\r\n   * Signs out the current user with comprehensive session clearing\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When sign out fails\r\n   */\r\n  async signOut(): Promise<void> {\r\n    try {\r\n      // Clear all authentication-related storage first\r\n      if (typeof window !== 'undefined') {\r\n        // Clear Supabase auth storage\r\n        localStorage.removeItem('supabase.auth.token');\r\n        sessionStorage.removeItem('supabase.auth.token');\r\n        \r\n        // Clear any other auth-related storage\r\n        const keysToClear = [];\r\n        for (let i = 0; i < localStorage.length; i++) {\r\n          const key = localStorage.key(i);\r\n          if (key && (key.includes('supabase') || key.includes('auth'))) {\r\n            keysToClear.push(key);\r\n          }\r\n        }\r\n        keysToClear.forEach(key => localStorage.removeItem(key));\r\n\r\n        const sessionKeysToClear = [];\r\n        for (let i = 0; i < sessionStorage.length; i++) {\r\n          const key = sessionStorage.key(i);\r\n          if (key && (key.includes('supabase') || key.includes('auth'))) {\r\n            sessionKeysToClear.push(key);\r\n          }\r\n        }\r\n        sessionKeysToClear.forEach(key => sessionStorage.removeItem(key));\r\n\r\n        // Clear cookies\r\n        const cookies = document.cookie.split(';');\r\n        cookies.forEach(cookie => {\r\n          const eqPos = cookie.indexOf('=');\r\n          const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();\r\n          if (name.startsWith('sb-') || name.includes('supabase') || name.includes('auth')) {\r\n            document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=${window.location.hostname};secure;samesite=lax`;\r\n          }\r\n        });\r\n      }\r\n\r\n      // Sign out from Supabase\r\n      const { error } = await supabase.auth.signOut();\r\n      \r\n      if (error) {\r\n        logger.error('Sign out error:', {\r\n          error: error.message,\r\n          timestamp: new Date().toISOString()\r\n        });\r\n        // Continue with cleanup even if Supabase sign out fails\r\n      }\r\n      \r\n      logger.info('User signed out successfully');\r\n    } catch (error) {\r\n      logger.error('Critical sign out error:', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      // Don't throw - ensure logout completes even if there are errors\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Refreshes the current user session\r\n   * @returns {Promise<User | null>} Current user or null if not authenticated\r\n   */\r\n  async refreshSession(): Promise<User | null> {\r\n    try {\r\n      const { data, error } = await supabase.auth.getUser();\r\n      \r\n      if (error) {\r\n        logger.warn('Session refresh warning:', {\r\n          error: error.message,\r\n          timestamp: new Date().toISOString()\r\n        });\r\n        return null;\r\n      }\r\n      \r\n      return data.user;\r\n    } catch (error) {\r\n      logger.error('Session refresh error:', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      return null;\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Gets the current authenticated user\r\n   * @returns {Promise<User | null>} Current user or null if not authenticated\r\n   */\r\n  async getCurrentUser(): Promise<User | null> {\r\n    try {\r\n      const { data, error } = await supabase.auth.getUser();\r\n      \r\n      if (error) {\r\n        logger.warn('Get current user warning:', {\r\n          error: error.message,\r\n          timestamp: new Date().toISOString()\r\n        });\r\n        return null;\r\n      }\r\n      \r\n      return data.user;\r\n    } catch (error) {\r\n      logger.error('Get current user error:', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      return null;\r\n    }\r\n  },\r\n};\r\n\r\nexport type AuthService = typeof authService;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\services\\database.interface.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":13,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file services/database.interface.ts\r\n * @description Database abstraction layer interface for easy migration to Supabase\r\n * @created 2025-10-30\r\n */\r\n\r\nimport { Link, Folder, AppSettings } from '@/types';\r\n\r\n/**\r\n * Database service interface\r\n * Abstracts storage operations to easily switch between localStorage and Supabase\r\n */\r\nexport interface DatabaseService {\r\n  // Link operations\r\n  getLinks(userId?: string): Promise<Link[]>;\r\n  addLink(link: Omit<Link, 'id' | 'createdAt' | 'updatedAt'>): Promise<Link>;\r\n  updateLink(id: string, updates: Partial<Link>): Promise<Link>;\r\n  deleteLink(id: string): Promise<void>;\r\n  \r\n  // Folder operations\r\n  getFolders(userId?: string): Promise<Folder[]>;\r\n  addFolder(folder: Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>): Promise<Folder>;\r\n  updateFolder(id: string, updates: Partial<Folder>): Promise<Folder>;\r\n  deleteFolder(id: string): Promise<void>;\r\n  \r\n  // Settings operations\r\n  getSettings(userId?: string): Promise<AppSettings>;\r\n  updateSettings(settings: Partial<AppSettings>, userId?: string): Promise<AppSettings>;\r\n  \r\n  // Bulk operations\r\n  bulkDeleteLinks(ids: string[]): Promise<void>;\r\n  emptyTrash(userId?: string): Promise<void>;\r\n  \r\n  // Data export/import\r\n  exportData(userId?: string): Promise<string>;\r\n  importData(data: string, userId?: string): Promise<boolean>;\r\n}\r\n\r\n/**\r\n * LocalStorage implementation (current)\r\n * This is the current implementation using localStorage\r\n * When migrating to Supabase, create a SupabaseService that implements DatabaseService\r\n */\r\n\r\n/**\r\n * Future Supabase implementation example:\r\n * \r\n * export class SupabaseService implements DatabaseService {\r\n *   constructor(private supabase: SupabaseClient) {}\r\n *   \r\n *   async getLinks(userId?: string): Promise<Link[]> {\r\n *     const { data, error } = await this.supabase\r\n *       .from('links')\r\n *       .select('*')\r\n *       .eq('userId', userId)\r\n *       .is('deletedAt', null);\r\n *     \r\n *     if (error) throw error;\r\n *     return data;\r\n *   }\r\n *   \r\n *   // ... implement other methods\r\n * }\r\n */\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\services\\folders.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":26,"column":29,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file services/folders.service.ts\r\n * @description Folder management service\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { Folder } from '@/types';\r\nimport { sanitizeFolderData } from '@/lib/utils/sanitization';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\nconst supabase = createClient();\r\n\r\n/**\r\n * Folders service\r\n * Handles all folder-related database operations\r\n */\r\nexport const foldersService = {\r\n  /**\r\n   * Adds a new folder to the database\r\n   * @param {Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>} folderData - Folder data to create\r\n   * @returns {Promise<Folder>} Created folder\r\n   * @throws {Error} When folder creation fails\r\n   */\r\n  async addFolder(folderData: Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>): Promise<Folder> {\r\n    const sanitizedData = sanitizeFolderData(folderData);\r\n    \r\n    const { data, error } = await supabase\r\n      .from('folders')\r\n      .insert({\r\n        user_id: (await supabase.auth.getUser()).data.user?.id,\r\n        name: sanitizedData.name,\r\n        description: sanitizedData.description,\r\n        color: sanitizedData.color,\r\n        icon: sanitizedData.icon,\r\n        parent_id: sanitizedData.parentId,\r\n        is_platform_folder: sanitizedData.isPlatformFolder,\r\n        platform: sanitizedData.platform\r\n      })\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) {\r\n      logger.error('Failed to add folder:', {\r\n        error: error.message,\r\n        folderData: { name: sanitizedData.name },\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to add folder: ${error.message}`);\r\n    }\r\n    \r\n    if (!data) {\r\n      throw new Error('No data returned when creating folder');\r\n    }\r\n    \r\n    logger.debug('Folder added successfully:', { id: data.id, name: data.name });\r\n    return data as Folder;\r\n  },\r\n  \r\n  /**\r\n   * Updates an existing folder\r\n   * @param {string} id - Folder ID\r\n   * @param {Partial<Folder>} updates - Fields to update\r\n   * @returns {Promise<Folder>} Updated folder\r\n   * @throws {Error} When folder update fails\r\n   */\r\n  async updateFolder(id: string, updates: Partial<Folder>): Promise<Folder> {\r\n    const sanitizedUpdates = sanitizeFolderData(updates);\r\n    \r\n    const { data, error } = await supabase\r\n      .from('folders')\r\n      .update({\r\n        ...(sanitizedUpdates.name && { name: sanitizedUpdates.name }),\r\n        ...(sanitizedUpdates.description && { description: sanitizedUpdates.description }),\r\n        ...(sanitizedUpdates.color && { color: sanitizedUpdates.color }),\r\n        ...(sanitizedUpdates.icon && { icon: sanitizedUpdates.icon }),\r\n        ...(sanitizedUpdates.parentId !== undefined && { parent_id: sanitizedUpdates.parentId }),\r\n        ...(sanitizedUpdates.isPlatformFolder !== undefined && { is_platform_folder: sanitizedUpdates.isPlatformFolder }),\r\n        ...(sanitizedUpdates.platform && { platform: sanitizedUpdates.platform }),\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) {\r\n      logger.error('Failed to update folder:', {\r\n        error: error.message,\r\n        folderId: id,\r\n        updates: sanitizedUpdates,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to update folder: ${error.message}`);\r\n    }\r\n    \r\n    if (!data) {\r\n      throw new Error('No data returned when updating folder');\r\n    }\r\n    \r\n    logger.debug('Folder updated successfully:', { id, updates: sanitizedUpdates });\r\n    return data as Folder;\r\n  },\r\n  \r\n  /**\r\n   * Deletes a folder and moves its links to root\r\n   * @param {string} id - Folder ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When folder deletion fails\r\n   */\r\n  async deleteFolder(id: string): Promise<void> {\r\n    // First, move all links in this folder to root (null folder_id)\r\n    const { error: linksError } = await supabase\r\n      .from('links')\r\n      .update({\r\n        folder_id: null,\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('folder_id', id);\r\n    \r\n    if (linksError) {\r\n      logger.error('Failed to move links from deleted folder:', {\r\n        error: linksError.message,\r\n        folderId: id,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to move links from deleted folder: ${linksError.message}`);\r\n    }\r\n    \r\n    // Then delete the folder\r\n    const { error } = await supabase\r\n      .from('folders')\r\n      .delete()\r\n      .eq('id', id);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to delete folder:', {\r\n        error: error.message,\r\n        folderId: id,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to delete folder: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Folder deleted successfully:', { id });\r\n  },\r\n  \r\n  /**\r\n   * Fetches all folders for the current user with optional filtering\r\n   * @param {Object} options - Query options\r\n   * @param {string | null} options.parentId - Filter by parent ID (null for root folders)\r\n   * @param {boolean} options.includePlatform - Include platform folders\r\n   * @param {string} options.searchQuery - Search query\r\n   * @returns {Promise<Folder[]>} Array of folders\r\n   * @throws {Error} When fetching folders fails\r\n   */\r\n  async getFolders(options: {\r\n    parentId?: string | null;\r\n    includePlatform?: boolean;\r\n    searchQuery?: string;\r\n  } = {}): Promise<Folder[]> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    let query = supabase\r\n      .from('folders')\r\n      .select('*')\r\n      .eq('user_id', userId);\r\n    \r\n    // Apply filters\r\n    if (options.parentId !== undefined) {\r\n      query = options.parentId \r\n        ? query.eq('parent_id', options.parentId)\r\n        : query.is('parent_id', null);\r\n    }\r\n    \r\n    if (!options.includePlatform) {\r\n      query = query.eq('is_platform_folder', false);\r\n    }\r\n    \r\n    if (options.searchQuery) {\r\n      query = query.or(`name.ilike.%${options.searchQuery}%,description.ilike.%${options.searchQuery}%`);\r\n    }\r\n    \r\n    query = query.order('created_at', { ascending: true });\r\n    \r\n    const { data, error } = await query;\r\n    \r\n    if (error) {\r\n      logger.error('Failed to fetch folders:', {\r\n        error: error.message,\r\n        options,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to fetch folders: ${error.message}`);\r\n    }\r\n    \r\n    return data || [];\r\n  },\r\n  \r\n  /**\r\n   * Gets a folder by ID with proper error handling\r\n   * @param {string} id - Folder ID\r\n   * @returns {Promise<Folder | null>} Folder or null if not found\r\n   * @throws {Error} When fetching folder fails\r\n   */\r\n  async getFolderById(id: string): Promise<Folder | null> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    const { data, error } = await supabase\r\n      .from('folders')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .eq('user_id', userId)\r\n      .single();\r\n    \r\n    if (error) {\r\n      if (error.code === 'PGRST116') {\r\n        // No rows returned - folder not found\r\n        return null;\r\n      }\r\n      \r\n      logger.error('Failed to fetch folder by ID:', {\r\n        error: error.message,\r\n        folderId: id,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to fetch folder: ${error.message}`);\r\n    }\r\n    \r\n    return data as Folder;\r\n  },\r\n  \r\n  /**\r\n   * Gets all subfolders for a given parent folder\r\n   * @param {string} parentId - Parent folder ID\r\n   * @returns {Promise<Folder[]>} Array of subfolders\r\n   * @throws {Error} When fetching subfolders fails\r\n   */\r\n  async getSubfolders(parentId: string): Promise<Folder[]> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    const { data, error } = await supabase\r\n      .from('folders')\r\n      .select('*')\r\n      .eq('parent_id', parentId)\r\n      .eq('user_id', userId)\r\n      .order('created_at', { ascending: true });\r\n    \r\n    if (error) {\r\n      logger.error('Failed to fetch subfolders:', {\r\n        error: error.message,\r\n        parentId,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to fetch subfolders: ${error.message}`);\r\n    }\r\n    \r\n    return data || [];\r\n  },\r\n  \r\n  /**\r\n   * Gets the folder tree structure for the current user\r\n   * @param {Object} options - Query options\r\n   * @param {boolean} options.includePlatform - Include platform folders\r\n   * @returns {Promise<Folder[]>} Array of folders with hierarchy\r\n   * @throws {Error} When fetching folder tree fails\r\n   */\r\n  async getFolderTree(options: {\r\n    includePlatform?: boolean;\r\n  } = {}): Promise<Folder[]> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    let query = supabase\r\n      .from('folders')\r\n      .select('*')\r\n      .eq('user_id', userId);\r\n    \r\n    if (!options.includePlatform) {\r\n      query = query.eq('is_platform_folder', false);\r\n    }\r\n    \r\n    query = query.order('created_at', { ascending: true });\r\n    \r\n    const { data, error } = await query;\r\n    \r\n    if (error) {\r\n      logger.error('Failed to fetch folder tree:', {\r\n        error: error.message,\r\n        options,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to fetch folder tree: ${error.message}`);\r\n    }\r\n    \r\n    return data || [];\r\n  },\r\n  \r\n  /**\r\n   * Counts the number of links in a folder (excluding deleted links)\r\n   * @param {string} folderId - Folder ID\r\n   * @returns {Promise<number>} Number of links in folder\r\n   * @throws {Error} When counting links fails\r\n   */\r\n  async countLinksInFolder(folderId: string): Promise<number> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    const { count, error } = await supabase\r\n      .from('links')\r\n      .select('*', { count: 'exact', head: true })\r\n      .eq('user_id', userId)\r\n      .eq('folder_id', folderId)\r\n      .is('deleted_at', null);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to count links in folder:', {\r\n        error: error.message,\r\n        folderId,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to count links in folder: ${error.message}`);\r\n    }\r\n    \r\n    return count || 0;\r\n  },\r\n  \r\n  /**\r\n   * Checks if a folder name already exists for the user\r\n   * @param {string} name - Folder name to check\r\n   * @param {string | null} excludeId - Folder ID to exclude from check (for updates)\r\n   * @param {string | null} parentId - Parent folder ID\r\n   * @returns {Promise<boolean>} True if name exists\r\n   * @throws {Error} When checking name existence fails\r\n   */\r\n  async folderNameExists(\r\n    name: string, \r\n    excludeId?: string | null, \r\n    parentId?: string | null\r\n  ): Promise<boolean> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    let query = supabase\r\n      .from('folders')\r\n      .select('id', { count: 'exact', head: true })\r\n      .eq('user_id', userId)\r\n      .eq('name', name);\r\n    \r\n    if (excludeId) {\r\n      query = query.neq('id', excludeId);\r\n    }\r\n    \r\n    if (parentId !== undefined) {\r\n      query = parentId \r\n        ? query.eq('parent_id', parentId)\r\n        : query.is('parent_id', null);\r\n    }\r\n    \r\n    const { count, error } = await query;\r\n    \r\n    if (error) {\r\n      logger.error('Failed to check folder name existence:', {\r\n        error: error.message,\r\n        name,\r\n        excludeId,\r\n        parentId,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to check folder name: ${error.message}`);\r\n    }\r\n    \r\n    return (count || 0) > 0;\r\n  },\r\n};\r\n\r\nexport type FoldersService = typeof foldersService;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\services\\index.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token {","line":15,"column":13,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file services/index.ts\r\n * @description Services exports and composition\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\n// Import services\r\nimport { authService } from './auth.service';\r\nimport { linksService } from './links.service';\r\nimport { foldersService } from './folders.service';\r\nimport { settingsService } from './settings.service';\r\n\r\n// Import types\r\nimport type { AuthService } from './auth.service';\r\nimport type { LinksService } from './links.service';\r\nimport type { FoldersService } from './folders.service';\r\nimport type { SettingsService } from './settings.service';\r\nimport type { User } from '@supabase/supabase-js';\r\nimport type { Link, Folder, AppSettings } from '@/types';\r\n\r\n// Export services\r\nexport { authService, linksService, foldersService, settingsService };\r\n\r\n// Export types\r\nexport type { AuthService, LinksService, FoldersService, SettingsService };\r\nexport type { User, Link, Folder, AppSettings };\r\n\r\n/**\r\n * Combined services interface\r\n * Provides a unified interface to all services\r\n */\r\nexport interface AppServices {\r\n  auth: AuthService;\r\n  links: LinksService;\r\n  folders: FoldersService;\r\n  settings: SettingsService;\r\n}\r\n\r\n/**\r\n * Hook that provides access to all services\r\n * @returns {AppServices} Combined services interface\r\n */\r\nexport function useServices(): AppServices {\r\n  return {\r\n    auth: authService,\r\n    links: linksService,\r\n    folders: foldersService,\r\n    settings: settingsService,\r\n  };\r\n}\r\n\r\n/**\r\n * Creates a service instance with optional overrides for testing\r\n * @param {Partial<AppServices>} overrides - Service overrides for testing\r\n * @returns {AppServices} Service instance with overrides applied\r\n */\r\nexport function createServices(overrides: Partial<AppServices> = {}): AppServices {\r\n  return {\r\n    auth: overrides.auth || authService,\r\n    links: overrides.links || linksService,\r\n    folders: overrides.folders || foldersService,\r\n    settings: overrides.settings || settingsService,\r\n  };\r\n}\r\n\r\n/**\r\n * Service configuration options\r\n */\r\nexport interface ServiceConfig {\r\n  enableLogging?: boolean;\r\n  enableCaching?: boolean;\r\n  cacheTimeout?: number;\r\n  retryAttempts?: number;\r\n  timeout?: number;\r\n}\r\n\r\n/**\r\n * Default service configuration\r\n */\r\nexport const DEFAULT_SERVICE_CONFIG: ServiceConfig = {\r\n  enableLogging: true,\r\n  enableCaching: false,\r\n  cacheTimeout: 5 * 60 * 1000, // 5 minutes\r\n  retryAttempts: 3,\r\n  timeout: 30000, // 30 seconds\r\n};\r\n\r\n/**\r\n * Service utilities and helpers\r\n */\r\nexport const ServiceUtils = {\r\n  /**\r\n   * Wraps a service call with error handling and logging\r\n   * @param {() => Promise<T>} serviceCall - Service function to call\r\n   * @param {string} operationName - Name of the operation for logging\r\n   * @param {ServiceConfig} config - Service configuration\r\n   * @returns {Promise<T>} Service call result\r\n   */\r\n  async withErrorHandling<T>(\r\n    serviceCall: () => Promise<T>,\r\n    operationName: string,\r\n    config: ServiceConfig = DEFAULT_SERVICE_CONFIG\r\n  ): Promise<T> {\r\n    try {\r\n      const result = await serviceCall();\r\n      \r\n      if (config.enableLogging) {\r\n        console.debug(`[SERVICE] ${operationName} completed successfully`);\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      if (config.enableLogging) {\r\n        console.error(`[SERVICE] ${operationName} failed:`, error);\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Validates required authentication for service calls\r\n   * @param {User | null} user - Current user\r\n   * @param {string} operationName - Name of the operation for error message\r\n   */\r\n  requireAuth(user: User | null, operationName: string): void {\r\n    if (!user) {\r\n      throw new Error(`Authentication required for ${operationName}`);\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Validates required parameters for service calls\r\n   * @param {T} param - Parameter to validate\r\n   * @param {string} paramName - Name of the parameter for error message\r\n   * @param {(param: T) => boolean} validator - Validation function\r\n   */\r\n  requireParam<T>(\r\n    param: T,\r\n    paramName: string,\r\n    validator: (param: T) => boolean\r\n  ): void {\r\n    if (!validator(param)) {\r\n      throw new Error(`Invalid parameter: ${paramName}`);\r\n    }\r\n  },\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\services\\links.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":26,"column":25,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file services/links.service.ts\r\n * @description Link management service\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { Link } from '@/types';\r\nimport { sanitizeLinkData } from '@/lib/utils/sanitization';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\nconst supabase = createClient();\r\n\r\n/**\r\n * Links service\r\n * Handles all link-related database operations\r\n */\r\nexport const linksService = {\r\n  /**\r\n   * Adds a new link to the database\r\n   * @param {Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>} linkData - Link data to create\r\n   * @returns {Promise<Link>} Created link\r\n   * @throws {Error} When link creation fails\r\n   */\r\n  async addLink(linkData: Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>): Promise<Link> {\r\n    const sanitizedData = sanitizeLinkData(linkData);\r\n    \r\n    const { data, error } = await supabase\r\n      .from('links')\r\n      .insert({\r\n        user_id: (await supabase.auth.getUser()).data.user?.id,\r\n        url: sanitizedData.url,\r\n        title: sanitizedData.title,\r\n        description: sanitizedData.description,\r\n        thumbnail: sanitizedData.thumbnail,\r\n        favicon_url: sanitizedData.faviconUrl,\r\n        platform: sanitizedData.platform,\r\n        folder_id: sanitizedData.folderId,\r\n        is_favorite: sanitizedData.isFavorite,\r\n        tags: sanitizedData.tags,\r\n        ...(sanitizedData.metadata ? { metadata: sanitizedData.metadata } : {})\r\n      })\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) {\r\n      logger.error('Failed to add link:', {\r\n        error: error.message,\r\n        linkData: { url: sanitizedData.url, title: sanitizedData.title },\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to add link: ${error.message}`);\r\n    }\r\n    \r\n    if (!data) {\r\n      throw new Error('No data returned when creating link');\r\n    }\r\n    \r\n    logger.debug('Link added successfully:', { id: data.id, url: data.url });\r\n    return data as Link;\r\n  },\r\n  \r\n  /**\r\n   * Updates an existing link\r\n   * @param {string} id - Link ID\r\n   * @param {Partial<Link>} updates - Fields to update\r\n   * @returns {Promise<Link>} Updated link\r\n   * @throws {Error} When link update fails\r\n   */\r\n  async updateLink(id: string, updates: Partial<Link>): Promise<Link> {\r\n    const sanitizedUpdates = sanitizeLinkData(updates);\r\n    \r\n    const { data, error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        ...(sanitizedUpdates.url && { url: sanitizedUpdates.url }),\r\n        ...(sanitizedUpdates.title && { title: sanitizedUpdates.title }),\r\n        ...(sanitizedUpdates.description && { description: sanitizedUpdates.description }),\r\n        ...(sanitizedUpdates.thumbnail && { thumbnail: sanitizedUpdates.thumbnail }),\r\n        ...(sanitizedUpdates.faviconUrl && { favicon_url: sanitizedUpdates.faviconUrl }),\r\n        ...(sanitizedUpdates.platform && { platform: sanitizedUpdates.platform }),\r\n        ...(sanitizedUpdates.folderId !== undefined && { folder_id: sanitizedUpdates.folderId }),\r\n        ...(sanitizedUpdates.isFavorite !== undefined && { is_favorite: sanitizedUpdates.isFavorite }),\r\n        ...(sanitizedUpdates.tags && { tags: sanitizedUpdates.tags }),\r\n        ...(sanitizedUpdates.metadata && { metadata: sanitizedUpdates.metadata }),\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) {\r\n      logger.error('Failed to update link:', {\r\n        error: error.message,\r\n        linkId: id,\r\n        updates: sanitizedUpdates,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to update link: ${error.message}`);\r\n    }\r\n    \r\n    if (!data) {\r\n      throw new Error('No data returned when updating link');\r\n    }\r\n    \r\n    logger.debug('Link updated successfully:', { id, updates: sanitizedUpdates });\r\n    return data as Link;\r\n  },\r\n  \r\n  /**\r\n   * Soft deletes a link (moves to trash)\r\n   * @param {string} id - Link ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When link deletion fails\r\n   */\r\n  async deleteLink(id: string): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        deleted_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('id', id);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to delete link:', {\r\n        error: error.message,\r\n        linkId: id,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to delete link: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Link soft deleted:', { id });\r\n  },\r\n  \r\n  /**\r\n   * Restores a link from trash\r\n   * @param {string} id - Link ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When link restoration fails\r\n   */\r\n  async restoreLink(id: string): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        deleted_at: null,\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('id', id);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to restore link:', {\r\n        error: error.message,\r\n        linkId: id,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to restore link: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Link restored from trash:', { id });\r\n  },\r\n  \r\n  /**\r\n   * Permanently deletes a link\r\n   * @param {string} id - Link ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When permanent deletion fails\r\n   */\r\n  async permanentlyDeleteLink(id: string): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('links')\r\n      .delete()\r\n      .eq('id', id);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to permanently delete link:', {\r\n        error: error.message,\r\n        linkId: id,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to permanently delete link: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Link permanently deleted:', { id });\r\n  },\r\n  \r\n  /**\r\n   * Permanently deletes all trashed links for the current user\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When emptying trash fails\r\n   */\r\n  async emptyTrash(): Promise<void> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    const { error } = await supabase\r\n      .from('links')\r\n      .delete()\r\n      .eq('user_id', userId)\r\n      .not('deleted_at', 'is', null);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to empty trash:', {\r\n        error: error.message,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to empty trash: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Trash emptied successfully:', { userId });\r\n  },\r\n  \r\n  /**\r\n   * Restores all trashed links for the current user\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When restoration fails\r\n   */\r\n  async restoreAllFromTrash(): Promise<void> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    const { error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        deleted_at: null,\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .eq('user_id', userId)\r\n      .not('deleted_at', 'is', null);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to restore all from trash:', {\r\n        error: error.message,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to restore all from trash: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('All links restored from trash:', { userId });\r\n  },\r\n  \r\n  /**\r\n   * Bulk updates multiple links\r\n   * @param {string[]} ids - Array of link IDs to update\r\n   * @param {Partial<Link>} updates - Updates to apply to all links\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk update fails\r\n   */\r\n  async bulkUpdateLinks(ids: string[], updates: Partial<Link>): Promise<void> {\r\n    const sanitizedUpdates = sanitizeLinkData(updates);\r\n    \r\n    const { error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        ...(sanitizedUpdates.url && { url: sanitizedUpdates.url }),\r\n        ...(sanitizedUpdates.title && { title: sanitizedUpdates.title }),\r\n        ...(sanitizedUpdates.description && { description: sanitizedUpdates.description }),\r\n        ...(sanitizedUpdates.thumbnail && { thumbnail: sanitizedUpdates.thumbnail }),\r\n        ...(sanitizedUpdates.faviconUrl && { favicon_url: sanitizedUpdates.faviconUrl }),\r\n        ...(sanitizedUpdates.platform && { platform: sanitizedUpdates.platform }),\r\n        ...(sanitizedUpdates.folderId !== undefined && { folder_id: sanitizedUpdates.folderId }),\r\n        ...(sanitizedUpdates.isFavorite !== undefined && { is_favorite: sanitizedUpdates.isFavorite }),\r\n        ...(sanitizedUpdates.tags && { tags: sanitizedUpdates.tags }),\r\n        ...(sanitizedUpdates.metadata && { metadata: sanitizedUpdates.metadata }),\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .in('id', ids);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to bulk update links:', {\r\n        error: error.message,\r\n        linkIds: ids,\r\n        updates: sanitizedUpdates,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to bulk update links: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Links bulk updated:', { count: ids.length, updates: sanitizedUpdates });\r\n  },\r\n  \r\n  /**\r\n   * Bulk soft deletes multiple links\r\n   * @param {string[]} ids - Array of link IDs to delete\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk deletion fails\r\n   */\r\n  async bulkDeleteLinks(ids: string[]): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        deleted_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .in('id', ids);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to bulk delete links:', {\r\n        error: error.message,\r\n        linkIds: ids,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to bulk delete links: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Links bulk deleted:', { count: ids.length });\r\n  },\r\n  \r\n  /**\r\n   * Bulk restores multiple links from trash\r\n   * @param {string[]} ids - Array of link IDs to restore\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk restoration fails\r\n   */\r\n  async bulkRestoreLinks(ids: string[]): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        deleted_at: null,\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .in('id', ids);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to bulk restore links:', {\r\n        error: error.message,\r\n        linkIds: ids,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to bulk restore links: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Links bulk restored from trash:', { count: ids.length });\r\n  },\r\n  \r\n  /**\r\n   * Bulk moves multiple links to a specific folder\r\n   * @param {string[]} ids - Array of link IDs to move\r\n   * @param {string | null} folderId - Target folder ID (null for root)\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk move fails\r\n   */\r\n  async bulkMoveLinks(ids: string[], folderId: string | null): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        folder_id: folderId,\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .in('id', ids);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to bulk move links:', {\r\n        error: error.message,\r\n        linkIds: ids,\r\n        folderId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to bulk move links: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Links bulk moved:', { count: ids.length, folderId });\r\n  },\r\n  \r\n  /**\r\n   * Bulk toggles favorite status for multiple links\r\n   * @param {string[]} ids - Array of link IDs to toggle\r\n   * @param {boolean} isFavorite - New favorite status\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk favorite toggle fails\r\n   */\r\n  async bulkToggleFavoriteLinks(ids: string[], isFavorite: boolean): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('links')\r\n      .update({\r\n        is_favorite: isFavorite,\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .in('id', ids);\r\n    \r\n    if (error) {\r\n      logger.error('Failed to bulk toggle favorites:', {\r\n        error: error.message,\r\n        linkIds: ids,\r\n        isFavorite,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to bulk toggle favorites: ${error.message}`);\r\n    }\r\n    \r\n    logger.debug('Links favorite status bulk updated:', { count: ids.length, isFavorite });\r\n  },\r\n  \r\n  /**\r\n   * Fetches all links for the current user with optional filtering\r\n   * @param {Object} options - Query options\r\n   * @param {string | null} options.folderId - Filter by folder ID (null for all)\r\n   * @param {boolean} options.includeDeleted - Include deleted links\r\n   * @param {string} options.searchQuery - Search query\r\n   * @returns {Promise<Link[]>} Array of links\r\n   * @throws {Error} When fetching links fails\r\n   */\r\n  async getLinks(options: {\r\n    folderId?: string | null;\r\n    includeDeleted?: boolean;\r\n    searchQuery?: string;\r\n  } = {}): Promise<Link[]> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n    \r\n    let query = supabase\r\n      .from('links')\r\n      .select('*')\r\n      .eq('user_id', userId);\r\n    \r\n    // Apply filters\r\n    if (options.folderId !== undefined) {\r\n      query = options.folderId \r\n        ? query.eq('folder_id', options.folderId)\r\n        : query.is('folder_id', null);\r\n    }\r\n    \r\n    if (!options.includeDeleted) {\r\n      query = query.is('deleted_at', null);\r\n    }\r\n    \r\n    if (options.searchQuery) {\r\n      query = query.or(`title.ilike.%${options.searchQuery}%,description.ilike.%${options.searchQuery}%`);\r\n    }\r\n    \r\n    query = query.order('created_at', { ascending: false });\r\n    \r\n    const { data, error } = await query;\r\n    \r\n    if (error) {\r\n      logger.error('Failed to fetch links:', {\r\n        error: error.message,\r\n        options,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to fetch links: ${error.message}`);\r\n    }\r\n    \r\n    return data || [];\r\n  },\r\n};\r\n\r\nexport type LinksService = typeof linksService;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\services\\realtime-subscription-manager.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":14,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file services/realtime-subscription-manager.service.ts\r\n * @description Centralized real-time subscription manager for optimized database subscriptions\r\n * @created 2025-01-01\r\n */\r\n\r\nimport { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';\r\nimport { createClient } from '../lib/supabase/client';\r\nimport { performanceMonitor } from '@/lib/services/performance-monitor.service';\r\n\r\n/**\r\n * Subscription configuration interface\r\n */\r\ninterface SubscriptionConfig {\r\n  table: string;\r\n  event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*';\r\n  filter?: string;\r\n  schema?: string;\r\n}\r\n\r\n/**\r\n * Subscription callback function type\r\n */\r\ntype SubscriptionCallback = (payload: RealtimePostgresChangesPayload<any>) => void;\r\n\r\n/**\r\n * Subscription metadata interface\r\n */\r\ninterface SubscriptionMetadata {\r\n  id: string;\r\n  config: SubscriptionConfig;\r\n  callback: SubscriptionCallback;\r\n  channel?: RealtimeChannel;\r\n  lastUpdate: number;\r\n  updateCount: number;\r\n  isActive: boolean;\r\n  isPaused: boolean;\r\n}\r\n\r\n/**\r\n * Debounced update configuration\r\n */\r\ninterface DebouncedUpdateConfig {\r\n  delay: number;\r\n  maxWait: number;\r\n  leading?: boolean;\r\n  trailing?: boolean;\r\n}\r\n\r\n/**\r\n * Real-time subscription manager service\r\n * Provides centralized management of Supabase real-time subscriptions\r\n * with debounced updates, connection pooling, and performance optimization\r\n */\r\nclass RealtimeSubscriptionManagerService {\r\n  private supabase = createClient();\r\n  private subscriptions = new Map<string, SubscriptionMetadata>();\r\n  private channels = new Map<string, RealtimeChannel>();\r\n  private debouncedCallbacks = new Map<string, NodeJS.Timeout>();\r\n  private updateQueues = new Map<string, RealtimePostgresChangesPayload<any>[]>();\r\n  private connectionPool = new Set<RealtimeChannel>();\r\n  private maxConnections = 10;\r\n  private defaultDebounceConfig: DebouncedUpdateConfig = {\r\n    delay: 300,\r\n    maxWait: 1000,\r\n    leading: false,\r\n    trailing: true\r\n  };\r\n\r\n  /**\r\n   * Subscribe to real-time changes with debounced updates\r\n   * @param config - Subscription configuration\r\n   * @param callback - Callback function for updates\r\n   * @param debounceConfig - Optional debounce configuration\r\n   * @returns Subscription ID for management\r\n   */\r\n  subscribe(\r\n    config: SubscriptionConfig,\r\n    callback: SubscriptionCallback,\r\n    debounceConfig?: Partial<DebouncedUpdateConfig>\r\n  ): string {\r\n    const startTime = performance.now();\r\n    const subscriptionId = this.generateSubscriptionId(config);\r\n    \r\n    try {\r\n      // Check if subscription already exists\r\n      if (this.subscriptions.has(subscriptionId)) {\r\n        const existing = this.subscriptions.get(subscriptionId)!;\r\n        existing.callback = callback;\r\n        existing.lastUpdate = Date.now();\r\n        \r\n        performanceMonitor.trackMetric('subscription_reuse', performance.now() - startTime, {\r\n          subscriptionId,\r\n          table: config.table\r\n        });\r\n        \r\n        return subscriptionId;\r\n      }\r\n\r\n      // Create new subscription\r\n      const channel = this.getOrCreateChannel(config);\r\n      const finalDebounceConfig = { ...this.defaultDebounceConfig, ...debounceConfig };\r\n      \r\n      const debouncedCallback = this.createDebouncedCallback(\r\n        subscriptionId,\r\n        callback,\r\n        finalDebounceConfig\r\n      );\r\n\r\n      // Configure channel subscription with proper event type\r\n      const eventType = config.event || '*';\r\n      \r\n      channel.on(\r\n        'postgres_changes' as any,\r\n        {\r\n          event: eventType,\r\n          schema: config.schema || 'public',\r\n          table: config.table,\r\n          filter: config.filter\r\n        },\r\n        debouncedCallback\r\n      );\r\n\r\n      // Store subscription metadata\r\n      this.subscriptions.set(subscriptionId, {\r\n        id: subscriptionId,\r\n        config,\r\n        callback,\r\n        channel,\r\n        lastUpdate: Date.now(),\r\n        updateCount: 0,\r\n        isActive: true,\r\n        isPaused: false\r\n      });\r\n\r\n      // Subscribe to channel if not already subscribed\r\n      if (channel.state !== 'joined') {\r\n        channel.subscribe((status) => {\r\n          performanceMonitor.trackMetric('channel_subscription_time', performance.now() - startTime, {\r\n            status,\r\n            subscriptionId,\r\n            table: config.table\r\n          });\r\n        });\r\n      }\r\n\r\n      performanceMonitor.trackMetric('subscription_create_time', performance.now() - startTime, {\r\n        subscriptionId,\r\n        table: config.table,\r\n        hasFilter: (!!config.filter).toString()\r\n      });\r\n\r\n      return subscriptionId;\r\n    } catch (error) {\r\n      performanceMonitor.trackError({\r\n        message: 'Failed to create subscription',\r\n        severity: 'high',\r\n        context: {\r\n          action: 'create_subscription',\r\n          table: config.table,\r\n          subscriptionId\r\n        }\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from real-time changes\r\n   * @param subscriptionId - Subscription ID to remove\r\n   */\r\n  unsubscribe(subscriptionId: string): void {\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      const subscription = this.subscriptions.get(subscriptionId);\r\n      if (!subscription) {\r\n        return;\r\n      }\r\n\r\n      // Clear debounced callback\r\n      const debouncedTimeout = this.debouncedCallbacks.get(subscriptionId);\r\n      if (debouncedTimeout) {\r\n        clearTimeout(debouncedTimeout);\r\n        this.debouncedCallbacks.delete(subscriptionId);\r\n      }\r\n\r\n      // Clear update queue\r\n      this.updateQueues.delete(subscriptionId);\r\n\r\n      // Mark as inactive\r\n      subscription.isActive = false;\r\n\r\n      // Remove from channel if no other subscriptions use it\r\n      const channelKey = this.getChannelKey(subscription.config);\r\n      const hasOtherSubscriptions = Array.from(this.subscriptions.values())\r\n        .some(sub => sub.isActive && this.getChannelKey(sub.config) === channelKey && sub.id !== subscriptionId);\r\n\r\n      if (!hasOtherSubscriptions && subscription.channel) {\r\n        subscription.channel.unsubscribe();\r\n        this.channels.delete(channelKey);\r\n        this.connectionPool.delete(subscription.channel);\r\n      }\r\n\r\n      // Remove subscription\r\n      this.subscriptions.delete(subscriptionId);\r\n\r\n      performanceMonitor.trackMetric('subscription_remove_time', performance.now() - startTime, {\r\n        subscriptionId,\r\n        table: subscription.config.table,\r\n        updateCount: subscription.updateCount.toString()\r\n      });\r\n    } catch (error) {\r\n      performanceMonitor.trackError({\r\n        message: 'Failed to remove subscription',\r\n        severity: 'medium',\r\n        context: {\r\n          action: 'remove_subscription',\r\n          subscriptionId\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pause a subscription temporarily\r\n   * @param subscriptionId - Subscription ID to pause\r\n   */\r\n  pauseSubscription(subscriptionId: string): void {\r\n    const subscription = this.subscriptions.get(subscriptionId);\r\n    if (subscription) {\r\n      subscription.isPaused = true;\r\n      \r\n      performanceMonitor.trackMetric('subscription_pause', 0, {\r\n        subscriptionId,\r\n        table: subscription.config.table\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resume a paused subscription\r\n   * @param subscriptionId - Subscription ID to resume\r\n   */\r\n  resumeSubscription(subscriptionId: string): void {\r\n    const subscription = this.subscriptions.get(subscriptionId);\r\n    if (subscription) {\r\n      subscription.isPaused = false;\r\n      \r\n      performanceMonitor.trackMetric('subscription_resume', 0, {\r\n        subscriptionId,\r\n        table: subscription.config.table\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get subscription statistics\r\n   * @returns Subscription statistics object\r\n   */\r\n  getStatistics() {\r\n    const activeSubscriptions = Array.from(this.subscriptions.values()).filter(sub => sub.isActive);\r\n    const totalUpdates = activeSubscriptions.reduce((sum, sub) => sum + sub.updateCount, 0);\r\n    \r\n    return {\r\n      totalSubscriptions: this.subscriptions.size,\r\n      activeSubscriptions: activeSubscriptions.length,\r\n      totalChannels: this.channels.size,\r\n      connectionPoolSize: this.connectionPool.size,\r\n      totalUpdates,\r\n      averageUpdatesPerSubscription: activeSubscriptions.length > 0 ? totalUpdates / activeSubscriptions.length : 0,\r\n      subscriptionsByTable: this.getSubscriptionsByTable()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clean up inactive subscriptions and optimize connections\r\n   */\r\n  optimizeConnections(): void {\r\n    const startTime = performance.now();\r\n    let cleanedCount = 0;\r\n    \r\n    try {\r\n      // Remove inactive subscriptions older than 5 minutes\r\n      const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;\r\n      \r\n      for (const [id, subscription] of this.subscriptions.entries()) {\r\n        if (!subscription.isActive && subscription.lastUpdate < fiveMinutesAgo) {\r\n          this.unsubscribe(id);\r\n          cleanedCount++;\r\n        }\r\n      }\r\n\r\n      // Optimize connection pool\r\n      if (this.connectionPool.size > this.maxConnections) {\r\n        const excessConnections = Array.from(this.connectionPool).slice(this.maxConnections);\r\n        excessConnections.forEach(channel => {\r\n          channel.unsubscribe();\r\n          this.connectionPool.delete(channel);\r\n        });\r\n      }\r\n\r\n      performanceMonitor.trackMetric('connection_optimization_time', performance.now() - startTime, {\r\n        cleanedSubscriptions: cleanedCount.toString(),\r\n        remainingConnections: this.connectionPool.size.toString()\r\n      });\r\n    } catch (error) {\r\n      performanceMonitor.trackError({\r\n        message: 'Failed to optimize connections',\r\n        severity: 'medium',\r\n        context: {\r\n          action: 'optimize_connections',\r\n          cleanedCount\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate unique subscription ID\r\n   * @param config - Subscription configuration\r\n   * @returns Unique subscription ID\r\n   */\r\n  private generateSubscriptionId(config: SubscriptionConfig): string {\r\n    const parts = [\r\n      config.table,\r\n      config.event || '*',\r\n      config.schema || 'public',\r\n      config.filter || 'no-filter'\r\n    ];\r\n    return `sub_${parts.join('_')}_${Date.now()}`;\r\n  }\r\n\r\n  /**\r\n   * Get or create a channel for the subscription\r\n   * @param config - Subscription configuration\r\n   * @returns Realtime channel\r\n   */\r\n  private getOrCreateChannel(config: SubscriptionConfig): RealtimeChannel {\r\n    const channelKey = this.getChannelKey(config);\r\n    \r\n    if (this.channels.has(channelKey)) {\r\n      return this.channels.get(channelKey)!;\r\n    }\r\n\r\n    const channel = this.supabase.channel(channelKey);\r\n    this.channels.set(channelKey, channel);\r\n    this.connectionPool.add(channel);\r\n    \r\n    return channel;\r\n  }\r\n\r\n  /**\r\n   * Generate channel key for connection pooling\r\n   * @param config - Subscription configuration\r\n   * @returns Channel key\r\n   */\r\n  private getChannelKey(config: SubscriptionConfig): string {\r\n    return `${config.schema || 'public'}_${config.table}`;\r\n  }\r\n\r\n  /**\r\n   * Create debounced callback function\r\n   * @param subscriptionId - Subscription ID\r\n   * @param callback - Original callback function\r\n   * @param config - Debounce configuration\r\n   * @returns Debounced callback function\r\n   */\r\n  private createDebouncedCallback(\r\n    subscriptionId: string,\r\n    callback: SubscriptionCallback,\r\n    config: DebouncedUpdateConfig\r\n  ): SubscriptionCallback {\r\n    return (payload: RealtimePostgresChangesPayload<any>) => {\r\n      try {\r\n        const subscription = this.subscriptions.get(subscriptionId);\r\n        if (!subscription || !subscription.isActive || subscription.isPaused) {\r\n          return;\r\n        }\r\n\r\n        // Validate payload\r\n        if (!payload || typeof payload !== 'object') {\r\n          performanceMonitor.trackError({\r\n            message: 'Invalid payload received in realtime subscription',\r\n            severity: 'low',\r\n            context: {\r\n              subscriptionId,\r\n              payloadType: typeof payload,\r\n              table: subscription.config.table\r\n            }\r\n          });\r\n          return;\r\n        }\r\n\r\n        // Add to update queue\r\n        if (!this.updateQueues.has(subscriptionId)) {\r\n          this.updateQueues.set(subscriptionId, []);\r\n        }\r\n        this.updateQueues.get(subscriptionId)!.push(payload);\r\n\r\n        // Clear existing timeout\r\n        const existingTimeout = this.debouncedCallbacks.get(subscriptionId);\r\n        if (existingTimeout) {\r\n          clearTimeout(existingTimeout);\r\n        }\r\n\r\n        // Set new timeout\r\n        const timeout = setTimeout(() => {\r\n          try {\r\n            const queue = this.updateQueues.get(subscriptionId) || [];\r\n            if (queue.length > 0) {\r\n              // Process all queued updates\r\n              const latestPayload = queue[queue.length - 1]; // Use latest update\r\n              callback(latestPayload);\r\n              \r\n              // Update subscription metadata\r\n              subscription.updateCount += queue.length;\r\n              subscription.lastUpdate = Date.now();\r\n              \r\n              // Clear queue\r\n              this.updateQueues.set(subscriptionId, []);\r\n            }\r\n            \r\n            this.debouncedCallbacks.delete(subscriptionId);\r\n          } catch (callbackError) {\r\n            performanceMonitor.trackError({\r\n              message: 'Error in debounced callback execution',\r\n              severity: 'medium',\r\n              context: {\r\n                subscriptionId,\r\n                table: subscription?.config.table,\r\n                error: callbackError instanceof Error ? callbackError.message : 'Unknown error'\r\n              }\r\n            });\r\n          }\r\n        }, config.delay);\r\n\r\n        this.debouncedCallbacks.set(subscriptionId, timeout);\r\n      } catch (error) {\r\n        performanceMonitor.trackError({\r\n          message: 'Error in realtime subscription callback',\r\n          severity: 'medium',\r\n          context: {\r\n            subscriptionId,\r\n            error: error instanceof Error ? error.message : 'Unknown error'\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get subscriptions grouped by table\r\n   * @returns Object with table names as keys and subscription counts as values\r\n   */\r\n  private getSubscriptionsByTable(): Record<string, number> {\r\n    const result: Record<string, number> = {};\r\n    \r\n    for (const subscription of this.subscriptions.values()) {\r\n      if (subscription.isActive) {\r\n        const table = subscription.config.table;\r\n        result[table] = (result[table] || 0) + 1;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const realtimeSubscriptionManager = new RealtimeSubscriptionManagerService();\r\n\r\n// Auto-optimize connections every 5 minutes\r\nsetInterval(() => {\r\n  realtimeSubscriptionManager.optimizeConnections();\r\n}, 5 * 60 * 1000);","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\services\\settings.service.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":25,"column":22,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file services/settings.service.ts\r\n * @description User settings service\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { AppSettings } from '@/types';\r\nimport { sanitizeSettingsData } from '@/lib/utils/sanitization';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\nconst supabase = createClient();\r\n\r\n/**\r\n * Settings service\r\n * Handles all user settings-related database operations\r\n */\r\nexport const settingsService = {\r\n  /**\r\n   * Gets user settings from the database\r\n   * @returns {Promise<AppSettings | null>} User settings or null if not found\r\n   * @throws {Error} When fetching settings fails\r\n   */\r\n  async getSettings(): Promise<AppSettings | null> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n\r\n    const { data, error } = await supabase\r\n      .from('user_settings')\r\n      .select('*')\r\n      .eq('user_id', userId)\r\n      .single();\r\n\r\n    if (error) {\r\n      if (error.code === 'PGRST116') {\r\n        // No rows returned - settings not found, return default\r\n        return null;\r\n      }\r\n\r\n      logger.error('Failed to fetch user settings:', {\r\n        error: error.message,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to fetch settings: ${error.message}`);\r\n    }\r\n\r\n    return data as AppSettings;\r\n  },\r\n\r\n  /**\r\n   * Updates user settings in the database\r\n   * @param {Partial<AppSettings>} updates - Settings to update\r\n   * @returns {Promise<AppSettings>} Updated settings\r\n   * @throws {Error} When updating settings fails\r\n   */\r\n  async updateSettings(updates: Partial<AppSettings>): Promise<AppSettings> {\r\n    const sanitizedUpdates = sanitizeSettingsData(updates);\r\n\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n\r\n    // Use upsert to either insert new settings or update existing ones\r\n    const { data, error } = await supabase\r\n      .from('user_settings')\r\n      .upsert({\r\n        user_id: userId,\r\n        ...sanitizedUpdates,\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      logger.error('Failed to update user settings:', {\r\n        error: error.message,\r\n        updates: sanitizedUpdates,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to update settings: ${error.message}`);\r\n    }\r\n\r\n    if (!data) {\r\n      throw new Error('No data returned when updating settings');\r\n    }\r\n\r\n    logger.debug('User settings updated successfully:', { userId, updates: sanitizedUpdates });\r\n    return data as AppSettings;\r\n  },\r\n\r\n  /**\r\n   * Creates default settings for a new user\r\n   * @param {string} userId - User ID\r\n   * @returns {Promise<AppSettings>} Default settings\r\n   * @throws {Error} When creating default settings fails\r\n   */\r\n  async createDefaultSettings(userId: string): Promise<AppSettings> {\r\n    const defaultSettings: AppSettings = {\r\n      theme: 'system',\r\n      // Add other default settings as needed\r\n    };\r\n\r\n    const { data, error } = await supabase\r\n      .from('user_settings')\r\n      .insert({\r\n        user_id: userId,\r\n        ...defaultSettings,\r\n        created_at: new Date().toISOString(),\r\n        updated_at: new Date().toISOString()\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      logger.error('Failed to create default settings:', {\r\n        error: error.message,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to create default settings: ${error.message}`);\r\n    }\r\n\r\n    if (!data) {\r\n      throw new Error('No data returned when creating default settings');\r\n    }\r\n\r\n    logger.info('Default settings created for new user:', { userId });\r\n    return data as AppSettings;\r\n  },\r\n\r\n  /**\r\n   * Deletes user settings (useful for account cleanup)\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When deleting settings fails\r\n   */\r\n  async deleteSettings(): Promise<void> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n\r\n    const { error } = await supabase\r\n      .from('user_settings')\r\n      .delete()\r\n      .eq('user_id', userId);\r\n\r\n    if (error) {\r\n      logger.error('Failed to delete user settings:', {\r\n        error: error.message,\r\n        userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to delete settings: ${error.message}`);\r\n    }\r\n\r\n    logger.debug('User settings deleted successfully:', { userId });\r\n  },\r\n\r\n  /**\r\n   * Gets settings for a specific user (admin function)\r\n   * @param {string} userId - User ID to fetch settings for\r\n   * @returns {Promise<AppSettings | null>} User settings or null if not found\r\n   * @throws {Error} When fetching settings fails\r\n   */\r\n  async getSettingsForUser(userId: string): Promise<AppSettings | null> {\r\n    const { data, error } = await supabase\r\n      .from('user_settings')\r\n      .select('*')\r\n      .eq('user_id', userId)\r\n      .single();\r\n\r\n    if (error) {\r\n      if (error.code === 'PGRST116') {\r\n        // No rows returned - settings not found\r\n        return null;\r\n      }\r\n\r\n      logger.error('Failed to fetch settings for user:', {\r\n        error: error.message,\r\n        targetUserId: userId,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to fetch settings for user: ${error.message}`);\r\n    }\r\n\r\n    return data as AppSettings;\r\n  },\r\n\r\n  /**\r\n   * Gets all user settings (admin function - should have proper authorization)\r\n   * @param {Object} options - Query options\r\n   * @param {number} options.limit - Maximum number of results\r\n   * @param {string} options.offset - Offset for pagination\r\n   * @returns {Promise<AppSettings[]>} Array of user settings\r\n   * @throws {Error} When fetching all settings fails\r\n   */\r\n  async getAllSettings(options: {\r\n    limit?: number;\r\n    offset?: number;\r\n  } = {}): Promise<AppSettings[]> {\r\n    let query = supabase\r\n      .from('user_settings')\r\n      .select('*')\r\n      .order('updated_at', { ascending: false });\r\n\r\n    if (options.limit) {\r\n      query = query.limit(options.limit);\r\n    }\r\n\r\n    if (options.offset) {\r\n      query = query.range(options.offset, options.offset + (options.limit || 50) - 1);\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      logger.error('Failed to fetch all user settings:', {\r\n        error: error.message,\r\n        options,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to fetch all settings: ${error.message}`);\r\n    }\r\n\r\n    return data || [];\r\n  },\r\n\r\n  /**\r\n   * Resets user settings to default values\r\n   * @returns {Promise<AppSettings>} Reset settings\r\n   * @throws {Error} When resetting settings fails\r\n   */\r\n  async resetToDefaults(): Promise<AppSettings> {\r\n    const userId = (await supabase.auth.getUser()).data.user?.id;\r\n    if (!userId) {\r\n      throw new Error('No authenticated user found');\r\n    }\r\n\r\n    // Delete existing settings and create new ones with defaults\r\n    await this.deleteSettings();\r\n    return await this.createDefaultSettings(userId);\r\n  },\r\n\r\n  /**\r\n   * Validates settings data before saving\r\n   * @param {Partial<AppSettings>} settings - Settings to validate\r\n   * @returns {{ isValid: boolean; errors: string[] }} Validation result\r\n   */\r\n  validateSettings(settings: Partial<AppSettings>): { isValid: boolean; errors: string[] } {\r\n    const errors: string[] = [];\r\n\r\n    // Validate theme\r\n    if (settings.theme && !['light', 'dark', 'system'].includes(settings.theme)) {\r\n      errors.push('Theme must be \"light\", \"dark\", or \"system\"');\r\n    }\r\n\r\n    // Add more validation rules as needed\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Gets the count of users with specific settings\r\n   * @param {Object} criteria - Settings criteria to count\r\n   * @returns {Promise<number>} Number of users matching criteria\r\n   * @throws {Error} When counting fails\r\n   */\r\n  async countUsersBySettings(criteria: Partial<AppSettings>): Promise<number> {\r\n    let query = supabase\r\n      .from('user_settings')\r\n      .select('*', { count: 'exact', head: true });\r\n\r\n    // Apply criteria filters\r\n    Object.entries(criteria).forEach(([key, value]) => {\r\n      if (value !== undefined && value !== null) {\r\n        query = query.eq(key, value);\r\n      }\r\n    });\r\n\r\n    const { count, error } = await query;\r\n\r\n    if (error) {\r\n      logger.error('Failed to count users by settings:', {\r\n        error: error.message,\r\n        criteria,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw new Error(`Failed to count users: ${error.message}`);\r\n    }\r\n\r\n    return count || 0;\r\n  },\r\n};\r\n\r\nexport type SettingsService = typeof settingsService;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\services\\storage.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token <","line":18,"column":10,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file services/storage.ts\r\n * @description LocalStorage service with cross-tab synchronization\r\n * @created 2025-10-18\r\n */\r\n\r\nimport { STORAGE_KEYS } from '@/constants';\r\n\r\n/**\r\n * Generic storage service for localStorage operations\r\n */\r\nclass StorageService {\r\n  /**\r\n   * Gets an item from localStorage\r\n   * @param key - Storage key\r\n   * @returns Parsed value or null if not found\r\n   */\r\n  getItem<T>(key: string): T | null {\r\n    try {\r\n      if (typeof window === 'undefined') return null;\r\n\r\n      const item = localStorage.getItem(key);\r\n      return item ? JSON.parse(item) : null;\r\n    } catch (error) {\r\n      console.error(`Error reading from localStorage (key: ${key}):`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets an item in localStorage\r\n   * @param key - Storage key\r\n   * @param value - Value to store\r\n   * @returns True if successful, false otherwise\r\n   */\r\n  setItem<T>(key: string, value: T): boolean {\r\n    try {\r\n      if (typeof window === 'undefined') return false;\r\n\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n\r\n      // Trigger storage event for cross-tab sync\r\n      window.dispatchEvent(\r\n        new StorageEvent('storage', {\r\n          key,\r\n          newValue: JSON.stringify(value),\r\n          url: window.location.href,\r\n        })\r\n      );\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Error writing to localStorage (key: ${key}):`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an item from localStorage\r\n   * @param key - Storage key\r\n   */\r\n  removeItem(key: string): void {\r\n    try {\r\n      if (typeof window === 'undefined') return;\r\n\r\n      localStorage.removeItem(key);\r\n    } catch (error) {\r\n      console.error(`Error removing from localStorage (key: ${key}):`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears all items from localStorage\r\n   */\r\n  clear(): void {\r\n    try {\r\n      if (typeof window === 'undefined') return;\r\n\r\n      localStorage.clear();\r\n    } catch (error) {\r\n      console.error('Error clearing localStorage:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the total size of data in localStorage\r\n   * @returns Size in bytes\r\n   */\r\n  getStorageSize(): number {\r\n    try {\r\n      if (typeof window === 'undefined') return 0;\r\n\r\n      let total = 0;\r\n      for (const key in localStorage) {\r\n        if (localStorage.hasOwnProperty(key)) {\r\n          total += localStorage[key].length + key.length;\r\n        }\r\n      }\r\n      return total;\r\n    } catch (error) {\r\n      console.error('Error calculating storage size:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Exports all LinkVault data\r\n   * @returns JSON string of all data\r\n   */\r\n  exportData(): string {\r\n    const data = {\r\n      links: this.getItem(STORAGE_KEYS.LINKS),\r\n      folders: this.getItem(STORAGE_KEYS.FOLDERS),\r\n      settings: this.getItem(STORAGE_KEYS.SETTINGS),\r\n      exportedAt: new Date().toISOString(),\r\n      version: '1.0.0',\r\n    };\r\n\r\n    return JSON.stringify(data, null, 2);\r\n  }\r\n\r\n  /**\r\n   * Imports LinkVault data from JSON\r\n   * @param jsonString - JSON string to import\r\n   * @returns True if successful, false otherwise\r\n   */\r\n  importData(jsonString: string): boolean {\r\n    try {\r\n      const data = JSON.parse(jsonString);\r\n\r\n      // Validate data structure\r\n      if (!data.links || !data.folders || !data.settings) {\r\n        throw new Error('Invalid data structure');\r\n      }\r\n\r\n      // Import data\r\n      this.setItem(STORAGE_KEYS.LINKS, data.links);\r\n      this.setItem(STORAGE_KEYS.FOLDERS, data.folders);\r\n      this.setItem(STORAGE_KEYS.SETTINGS, data.settings);\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error importing data:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nexport const storage = new StorageService();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\store\\compatibility-bridge.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":26,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file store/compatibility-bridge.ts\r\n * @description Compatibility bridge between old useStore pattern and new modular stores\r\n * @created 2025-11-12\r\n * \r\n * This bridge allows existing code using useStore to work with new modular stores\r\n * without requiring changes to 18+ files. This enables:\r\n * - Zero-risk deployment\r\n * - Immediate use of new architecture\r\n * - Gradual migration path\r\n * - Backwards compatibility\r\n */\r\n\r\nimport { useLinksStore } from './useLinksStore';\r\nimport { useFoldersStore } from './useFoldersStore';\r\nimport { useSettingsStore } from './useSettingsStore';\r\nimport { useUIStore } from './useUIStore';\r\nimport { useAuthStore } from './useAuthStore';\r\nimport { Link, Folder, AppSettings, SearchFilters } from '@/types';\r\nimport { User } from '@supabase/supabase-js';\r\n\r\n/**\r\n * Combined store interface that matches the old useStore structure\r\n * This ensures complete backwards compatibility\r\n */\r\ninterface CombinedStore {\r\n  // Auth state\r\n  user: User | null;\r\n  isAuthenticated: boolean;\r\n  \r\n  // Data\r\n  links: Link[];\r\n  folders: Folder[];\r\n  settings: AppSettings;\r\n  \r\n  // Loading states\r\n  isLoadingData: boolean;\r\n  isLoadingFolders: boolean;\r\n  isLoadingLinks: boolean;\r\n  isHydrated: boolean;\r\n  \r\n  // UI State\r\n  isAddLinkModalOpen: boolean;\r\n  isCreateFolderModalOpen: boolean;\r\n  isSettingsModalOpen: boolean;\r\n  isProfileModalOpen: boolean;\r\n  isBulkDeleteModalOpen: boolean;\r\n  isBulkMoveModalOpen: boolean;\r\n  isFolderDeleteModalOpen: boolean;\r\n  isEmptyTrashModalOpen: boolean;\r\n  isRestoreAllModalOpen: boolean;\r\n  isShareFolderModalOpen: boolean;\r\n  \r\n  selectedFolderId: string | null;\r\n  editingLinkId: string | null;\r\n  editingFolderId: string | null;\r\n  parentFolderId: string | null;\r\n  currentView: 'all' | 'favorites' | 'trash';\r\n  searchFilters: SearchFilters;\r\n  expandedFolders: Set<string>;\r\n  selectedLinkIds: Set<string>;\r\n  folderToDelete: { id: string; name: string; linkCount: number } | null;\r\n  folderToShare: { id: string; name: string; linkCount: number } | null;\r\n  \r\n  // Actions - Links\r\n  addLink: (link: Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>) => Promise<void>;\r\n  updateLink: (id: string, updates: Partial<Link>) => Promise<void>;\r\n  deleteLink: (id: string) => Promise<void>;\r\n  restoreLink: (id: string) => Promise<void>;\r\n  permanentlyDeleteLink: (id: string) => Promise<void>;\r\n  toggleFavorite: (id: string) => Promise<void>;\r\n  bulkUpdateLinks: (ids: string[], updates: Partial<Link>) => Promise<void>;\r\n  bulkDeleteLinks: (ids: string[]) => Promise<void>;\r\n  bulkRestoreLinks: (ids: string[]) => Promise<void>;\r\n  bulkMoveLinks: (ids: string[], folderId: string | null) => Promise<void>;\r\n  bulkToggleFavoriteLinks: (ids: string[], isFavorite: boolean) => Promise<void>;\r\n  emptyTrash: () => Promise<void>;\r\n  restoreAllFromTrash: () => Promise<void>;\r\n  \r\n  // Actions - Folders\r\n  addFolder: (folder: Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;\r\n  updateFolder: (id: string, updates: Partial<Folder>) => Promise<void>;\r\n  deleteFolder: (id: string) => Promise<void>;\r\n  toggleFolderExpanded: (id: string) => void;\r\n  \r\n  // Actions - Settings\r\n  loadSettings: () => Promise<void>;\r\n  updateSettings: (updates: Partial<AppSettings>) => Promise<void>;\r\n  \r\n  // Actions - UI\r\n  setAddLinkModalOpen: (isOpen: boolean) => void;\r\n  setCreateFolderModalOpen: (isOpen: boolean) => void;\r\n  setSettingsModalOpen: (isOpen: boolean) => void;\r\n  setProfileModalOpen: (isOpen: boolean) => void;\r\n  setBulkDeleteModalOpen: (isOpen: boolean) => void;\r\n  setBulkMoveModalOpen: (isOpen: boolean) => void;\r\n  setFolderDeleteModalOpen: (isOpen: boolean) => void;\r\n  setEmptyTrashModalOpen: (isOpen: boolean) => void;\r\n  setRestoreAllModalOpen: (isOpen: boolean) => void;\r\n  setShareFolderModalOpen: (isOpen: boolean) => void;\r\n  setSelectedFolder: (folderId: string | null) => void;\r\n  setEditingLink: (linkId: string | null) => void;\r\n  setEditingFolder: (folderId: string | null) => void;\r\n  setParentFolder: (folderId: string | null) => void;\r\n  setCurrentView: (view: 'all' | 'favorites' | 'trash') => void;\r\n  setSearchFilters: (filters: Partial<SearchFilters>) => void;\r\n  toggleLinkSelection: (linkId: string) => void;\r\n  clearLinkSelection: () => void;\r\n  selectAllLinks: (linkIds: string[]) => void;\r\n  setFolderToDelete: (folder: { id: string; name: string; linkCount: number } | null) => void;\r\n  setFolderToShare: (folder: { id: string; name: string; linkCount: number } | null) => void;\r\n  resetUIState: () => void;\r\n  \r\n  // Auth actions\r\n  signIn: (email: string, password: string) => Promise<void>;\r\n  signUp: (email: string, password: string) => Promise<void>;\r\n  signOut: () => Promise<void>;\r\n  refreshSession: () => Promise<void>;\r\n  \r\n  // Legacy compatibility methods\r\n  loadFromStorage: () => Promise<void>;\r\n  clearData: () => void;\r\n  exportData: () => string;\r\n  importData: (jsonString: string) => Promise<boolean>;\r\n}\r\n\r\n/**\r\n * Compatibility hook that combines all modular stores\r\n * Usage remains exactly the same as old useStore:\r\n * \r\n * @example\r\n * const { links, addLink, folders } = useStore();\r\n * const links = useStore((state) => state.links);\r\n */\r\nexport function useStoreCompat<T = CombinedStore>(\r\n  selector?: (state: CombinedStore) => T\r\n): T extends undefined ? CombinedStore : T {\r\n  // Get all modular stores\r\n  const authStore = useAuthStore();\r\n  const linksStore = useLinksStore();\r\n  const foldersStore = useFoldersStore();\r\n  const settingsStore = useSettingsStore();\r\n  const uiStore = useUIStore();\r\n  \r\n  // Combine all stores into single interface\r\n  const combined: CombinedStore = {\r\n    // Auth\r\n    user: authStore.user,\r\n    isAuthenticated: authStore.isAuthenticated,\r\n    signIn: authStore.signIn,\r\n    signUp: authStore.signUp,\r\n    signOut: authStore.signOut,\r\n    refreshSession: authStore.refreshSession,\r\n    \r\n    // Links\r\n    links: linksStore.links,\r\n    isLoadingLinks: linksStore.isLoading,\r\n    addLink: linksStore.addLink,\r\n    updateLink: linksStore.updateLink,\r\n    deleteLink: linksStore.deleteLink,\r\n    restoreLink: linksStore.restoreLink,\r\n    permanentlyDeleteLink: linksStore.permanentlyDeleteLink,\r\n    toggleFavorite: linksStore.toggleFavorite,\r\n    bulkUpdateLinks: linksStore.bulkUpdateLinks,\r\n    bulkDeleteLinks: linksStore.bulkDeleteLinks,\r\n    bulkRestoreLinks: linksStore.bulkRestoreLinks,\r\n    bulkMoveLinks: linksStore.bulkMoveLinks,\r\n    bulkToggleFavoriteLinks: linksStore.bulkToggleFavoriteLinks,\r\n    emptyTrash: linksStore.emptyTrash,\r\n    restoreAllFromTrash: linksStore.restoreAllFromTrash,\r\n    \r\n    // Folders\r\n    folders: foldersStore.folders,\r\n    isLoadingFolders: foldersStore.isLoading,\r\n    expandedFolders: foldersStore.expandedFolders,\r\n    addFolder: foldersStore.addFolder,\r\n    updateFolder: foldersStore.updateFolder,\r\n    deleteFolder: foldersStore.deleteFolder,\r\n    toggleFolderExpanded: foldersStore.toggleFolderExpanded,\r\n    \r\n    // Settings\r\n    settings: settingsStore.settings,\r\n    loadSettings: settingsStore.loadSettings,\r\n    updateSettings: settingsStore.updateSettings,\r\n    \r\n    // UI\r\n    isAddLinkModalOpen: uiStore.isAddLinkModalOpen,\r\n    isCreateFolderModalOpen: uiStore.isCreateFolderModalOpen,\r\n    isSettingsModalOpen: uiStore.isSettingsModalOpen,\r\n    isProfileModalOpen: uiStore.isProfileModalOpen,\r\n    isBulkDeleteModalOpen: uiStore.isBulkDeleteModalOpen,\r\n    isBulkMoveModalOpen: uiStore.isBulkMoveModalOpen,\r\n    isFolderDeleteModalOpen: uiStore.isFolderDeleteModalOpen,\r\n    isEmptyTrashModalOpen: uiStore.isEmptyTrashModalOpen,\r\n    isRestoreAllModalOpen: uiStore.isRestoreAllModalOpen,\r\n    isShareFolderModalOpen: uiStore.isShareFolderModalOpen,\r\n    selectedFolderId: uiStore.selectedFolderId,\r\n    editingLinkId: uiStore.editingLinkId,\r\n    editingFolderId: uiStore.editingFolderId,\r\n    parentFolderId: uiStore.parentFolderId,\r\n    currentView: uiStore.currentView,\r\n    searchFilters: uiStore.searchFilters,\r\n    selectedLinkIds: uiStore.selectedLinkIds,\r\n    folderToDelete: uiStore.folderToDelete,\r\n    folderToShare: uiStore.folderToShare,\r\n    setAddLinkModalOpen: uiStore.setAddLinkModalOpen,\r\n    setCreateFolderModalOpen: uiStore.setCreateFolderModalOpen,\r\n    setSettingsModalOpen: uiStore.setSettingsModalOpen,\r\n    setProfileModalOpen: uiStore.setProfileModalOpen,\r\n    setBulkDeleteModalOpen: uiStore.setBulkDeleteModalOpen,\r\n    setBulkMoveModalOpen: uiStore.setBulkMoveModalOpen,\r\n    setFolderDeleteModalOpen: uiStore.setFolderDeleteModalOpen,\r\n    setEmptyTrashModalOpen: uiStore.setEmptyTrashModalOpen,\r\n    setRestoreAllModalOpen: uiStore.setRestoreAllModalOpen,\r\n    setShareFolderModalOpen: uiStore.setShareFolderModalOpen,\r\n    setSelectedFolder: uiStore.setSelectedFolder,\r\n    setEditingLink: uiStore.setEditingLink,\r\n    setEditingFolder: uiStore.setEditingFolder,\r\n    setParentFolder: uiStore.setParentFolder,\r\n    setCurrentView: uiStore.setCurrentView,\r\n    setSearchFilters: uiStore.setSearchFilters,\r\n    toggleLinkSelection: uiStore.toggleLinkSelection,\r\n    clearLinkSelection: uiStore.clearLinkSelection,\r\n    selectAllLinks: uiStore.selectAllLinks,\r\n    setFolderToDelete: uiStore.setFolderToDelete,\r\n    setFolderToShare: uiStore.setFolderToShare,\r\n    resetUIState: uiStore.resetUIState,\r\n    \r\n    // Combined loading states\r\n    isLoadingData: uiStore.isLoadingData, // NEW: Use the dedicated data loading state\r\n    isHydrated: uiStore.isHydrated, // NEW: Use the UI store's hydration state\r\n    \r\n    // Legacy compatibility methods\r\n    loadFromStorage: async () => {\r\n      await Promise.all([\r\n        settingsStore.loadSettings(),\r\n        // Links and folders are loaded automatically by their stores\r\n      ]);\r\n    },\r\n    clearData: () => {\r\n      // Clear all stores\r\n      linksStore.setLinks([]);\r\n      foldersStore.setFolders([]);\r\n      uiStore.resetUIState();\r\n    },\r\n    exportData: () => {\r\n      // Export all data as JSON\r\n      const exportObject = {\r\n        links: linksStore.links,\r\n        folders: foldersStore.folders,\r\n        settings: settingsStore.settings,\r\n        version: '1.0',\r\n        exportDate: new Date().toISOString(),\r\n      };\r\n      return JSON.stringify(exportObject, null, 2);\r\n    },\r\n    importData: async (jsonString: string) => {\r\n      try {\r\n        const data = JSON.parse(jsonString);\r\n        \r\n        // Validate data structure\r\n        if (!data.links || !data.folders || !data.settings) {\r\n          throw new Error('Invalid data format');\r\n        }\r\n        \r\n        // Import data into stores\r\n        linksStore.setLinks(data.links);\r\n        foldersStore.setFolders(data.folders);\r\n        await settingsStore.updateSettings(data.settings);\r\n        \r\n        return true;\r\n      } catch (error) {\r\n        console.error('Failed to import data:', error);\r\n        return false;\r\n      }\r\n    },\r\n  };\r\n  \r\n  // Apply selector if provided, otherwise return full store\r\n  if (selector) {\r\n    return selector(combined) as any;\r\n  }\r\n  \r\n  return combined as any;\r\n}\r\n\r\n// Export as both useStore (for compatibility) and useStoreCompat (for clarity)\r\nexport { useStoreCompat as useStore };\r\nexport default useStoreCompat;\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\store\\index.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":28,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file store/index.ts\r\n * @description Store composition and exports\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\n// Export individual stores\r\nexport { useAuthStore } from './useAuthStore';\r\nexport { useLinksStore } from './useLinksStore';\r\nexport { useFoldersStore } from './useFoldersStore';\r\nexport { useSettingsStore } from './useSettingsStore';\r\nexport { useUIStore } from './useUIStore';\r\n\r\n// Import types for the combined store\r\nimport { User } from '@supabase/supabase-js';\r\nimport { Link, Folder, AppSettings, SearchFilters } from '@/types';\r\nimport { useAuthStore } from './useAuthStore';\r\nimport { useLinksStore } from './useLinksStore';\r\nimport { useFoldersStore } from './useFoldersStore';\r\nimport { useSettingsStore } from './useSettingsStore';\r\nimport { useUIStore } from './useUIStore';\r\n\r\n/**\r\n * Combined store interface for convenience\r\n * Provides a unified interface to all stores\r\n */\r\nexport interface AppStore {\r\n  // Auth Store\r\n  auth: {\r\n    user: User | null;\r\n    isAuthenticated: boolean;\r\n    isLoading: boolean;\r\n    error: string | null;\r\n    signIn: (email: string, password: string) => Promise<void>;\r\n    signUp: (email: string, password: string) => Promise<void>;\r\n    signOut: () => Promise<void>;\r\n    refreshSession: () => Promise<void>;\r\n    clearError: () => void;\r\n  };\r\n  \r\n  // Links Store\r\n  links: {\r\n    links: Link[];\r\n    isLoading: boolean;\r\n    editingLinkId: string | null;\r\n    addLink: (linkData: Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>) => Promise<void>;\r\n    updateLink: (id: string, updates: Partial<Link>) => Promise<void>;\r\n    deleteLink: (id: string) => Promise<void>;\r\n    restoreLink: (id: string) => Promise<void>;\r\n    permanentlyDeleteLink: (id: string) => Promise<void>;\r\n    toggleFavorite: (id: string) => Promise<void>;\r\n    bulkUpdateLinks: (ids: string[], updates: Partial<Link>) => Promise<void>;\r\n    bulkDeleteLinks: (ids: string[]) => Promise<void>;\r\n    bulkRestoreLinks: (ids: string[]) => Promise<void>;\r\n    bulkMoveLinks: (ids: string[], folderId: string | null) => Promise<void>;\r\n    bulkToggleFavoriteLinks: (ids: string[], isFavorite: boolean) => Promise<void>;\r\n    emptyTrash: () => Promise<void>;\r\n    restoreAllFromTrash: () => Promise<void>;\r\n    setEditingLink: (linkId: string | null) => void;\r\n  };\r\n  \r\n  // Folders Store\r\n  folders: {\r\n    folders: Folder[];\r\n    isLoading: boolean;\r\n    editingFolderId: string | null;\r\n    parentFolderId: string | null;\r\n    expandedFolders: Set<string>;\r\n    addFolder: (folderData: Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;\r\n    updateFolder: (id: string, updates: Partial<Folder>) => Promise<void>;\r\n    deleteFolder: (id: string) => Promise<void>;\r\n    toggleFolderExpanded: (id: string) => void;\r\n    setParentFolder: (folderId: string | null) => void;\r\n    setEditingFolder: (folderId: string | null) => void;\r\n  };\r\n  \r\n  // Settings Store\r\n  settings: {\r\n    settings: AppSettings;\r\n    isLoading: boolean;\r\n    error: string | null;\r\n    loadSettings: () => Promise<void>;\r\n    updateSettings: (updates: Partial<AppSettings>) => Promise<void>;\r\n    clearError: () => void;\r\n  };\r\n  \r\n  // UI Store\r\n  ui: {\r\n    // Modal States\r\n    isAddLinkModalOpen: boolean;\r\n    isCreateFolderModalOpen: boolean;\r\n    isSettingsModalOpen: boolean;\r\n    isProfileModalOpen: boolean;\r\n    isBulkDeleteModalOpen: boolean;\r\n    isBulkMoveModalOpen: boolean;\r\n    isFolderDeleteModalOpen: boolean;\r\n    isEmptyTrashModalOpen: boolean;\r\n    isRestoreAllModalOpen: boolean;\r\n    isShareFolderModalOpen: boolean;\r\n    \r\n    // Selection States\r\n    selectedFolderId: string | null;\r\n    editingLinkId: string | null;\r\n    editingFolderId: string | null;\r\n    parentFolderId: string | null;\r\n    \r\n    // View States\r\n    currentView: 'all' | 'favorites' | 'trash';\r\n    searchFilters: SearchFilters;\r\n    expandedFolders: Set<string>;\r\n    \r\n    // Bulk Selection State\r\n    selectedLinkIds: Set<string>;\r\n    \r\n    // Folder to Delete State\r\n    folderToDelete: { id: string; name: string; linkCount: number } | null;\r\n    // Folder to Share State\r\n    folderToShare: { id: string; name: string; linkCount: number } | null;\r\n    \r\n    // Actions\r\n    setAddLinkModalOpen: (isOpen: boolean) => void;\r\n    setCreateFolderModalOpen: (isOpen: boolean) => void;\r\n    setSettingsModalOpen: (isOpen: boolean) => void;\r\n    setProfileModalOpen: (isOpen: boolean) => void;\r\n    setBulkDeleteModalOpen: (isOpen: boolean) => void;\r\n    setBulkMoveModalOpen: (isOpen: boolean) => void;\r\n    setFolderDeleteModalOpen: (isOpen: boolean) => void;\r\n    setEmptyTrashModalOpen: (isOpen: boolean) => void;\r\n    setRestoreAllModalOpen: (isOpen: boolean) => void;\r\n    setShareFolderModalOpen: (isOpen: boolean) => void;\r\n    setSelectedFolder: (folderId: string | null) => void;\r\n    setEditingLink: (linkId: string | null) => void;\r\n    setEditingFolder: (folderId: string | null) => void;\r\n    setParentFolder: (folderId: string | null) => void;\r\n    setCurrentView: (view: 'all' | 'favorites' | 'trash') => void;\r\n    setSearchFilters: (filters: Partial<SearchFilters>) => void;\r\n    toggleFolderExpanded: (id: string) => void;\r\n    toggleLinkSelection: (linkId: string) => void;\r\n    clearLinkSelection: () => void;\r\n    selectAllLinks: (linkIds: string[]) => void;\r\n    setFolderToDelete: (folder: { id: string; name: string; linkCount: number } | null) => void;\r\n    setFolderToShare: (folder: { id: string; name: string; linkCount: number } | null) => void;\r\n    resetUIState: () => void;\r\n  };\r\n}\r\n\r\n/**\r\n * Hook that combines all stores for convenience\r\n * @returns {AppStore} Combined store interface\r\n * @example\r\n * const { auth, links, folders, settings, ui } = useAppStore();\r\n * \r\n * // Use individual stores\r\n * auth.signIn(email, password);\r\n * links.addLink(linkData);\r\n * folders.addFolder(folderData);\r\n * settings.updateSettings(newSettings);\r\n * ui.setAddLinkModalOpen(true);\r\n */\r\nexport function useAppStore(): AppStore {\r\n  const authStore = useAuthStore();\r\n  const linksStore = useLinksStore();\r\n  const foldersStore = useFoldersStore();\r\n  const settingsStore = useSettingsStore();\r\n  const uiStore = useUIStore();\r\n  \r\n  return {\r\n    auth: {\r\n      user: authStore.user,\r\n      isAuthenticated: authStore.isAuthenticated,\r\n      isLoading: authStore.isLoading,\r\n      error: authStore.error,\r\n      signIn: authStore.signIn,\r\n      signUp: authStore.signUp,\r\n      signOut: authStore.signOut,\r\n      refreshSession: authStore.refreshSession,\r\n      clearError: authStore.clearError,\r\n    },\r\n    \r\n    links: {\r\n      links: linksStore.links,\r\n      isLoading: linksStore.isLoading,\r\n      editingLinkId: linksStore.editingLinkId,\r\n      addLink: linksStore.addLink,\r\n      updateLink: linksStore.updateLink,\r\n      deleteLink: linksStore.deleteLink,\r\n      restoreLink: linksStore.restoreLink,\r\n      permanentlyDeleteLink: linksStore.permanentlyDeleteLink,\r\n      toggleFavorite: linksStore.toggleFavorite,\r\n      bulkUpdateLinks: linksStore.bulkUpdateLinks,\r\n      bulkDeleteLinks: linksStore.bulkDeleteLinks,\r\n      bulkRestoreLinks: linksStore.bulkRestoreLinks,\r\n      bulkMoveLinks: linksStore.bulkMoveLinks,\r\n      bulkToggleFavoriteLinks: linksStore.bulkToggleFavoriteLinks,\r\n      emptyTrash: linksStore.emptyTrash,\r\n      restoreAllFromTrash: linksStore.restoreAllFromTrash,\r\n      setEditingLink: linksStore.setEditingLink,\r\n    },\r\n    \r\n    folders: {\r\n      folders: foldersStore.folders,\r\n      isLoading: foldersStore.isLoading,\r\n      editingFolderId: foldersStore.editingFolderId,\r\n      parentFolderId: foldersStore.parentFolderId,\r\n      expandedFolders: foldersStore.expandedFolders,\r\n      addFolder: foldersStore.addFolder,\r\n      updateFolder: foldersStore.updateFolder,\r\n      deleteFolder: foldersStore.deleteFolder,\r\n      toggleFolderExpanded: foldersStore.toggleFolderExpanded,\r\n      setParentFolder: foldersStore.setParentFolder,\r\n      setEditingFolder: foldersStore.setEditingFolder,\r\n    },\r\n    \r\n    settings: {\r\n      settings: settingsStore.settings,\r\n      isLoading: settingsStore.isLoading,\r\n      error: settingsStore.error,\r\n      loadSettings: settingsStore.loadSettings,\r\n      updateSettings: settingsStore.updateSettings,\r\n      clearError: settingsStore.clearError,\r\n    },\r\n    \r\n    ui: {\r\n      // Modal States\r\n      isAddLinkModalOpen: uiStore.isAddLinkModalOpen,\r\n      isCreateFolderModalOpen: uiStore.isCreateFolderModalOpen,\r\n      isSettingsModalOpen: uiStore.isSettingsModalOpen,\r\n      isProfileModalOpen: uiStore.isProfileModalOpen,\r\n      isBulkDeleteModalOpen: uiStore.isBulkDeleteModalOpen,\r\n      isBulkMoveModalOpen: uiStore.isBulkMoveModalOpen,\r\n      isFolderDeleteModalOpen: uiStore.isFolderDeleteModalOpen,\r\n      isEmptyTrashModalOpen: uiStore.isEmptyTrashModalOpen,\r\n      isRestoreAllModalOpen: uiStore.isRestoreAllModalOpen,\r\n      isShareFolderModalOpen: uiStore.isShareFolderModalOpen,\r\n      \r\n      // Selection States\r\n      selectedFolderId: uiStore.selectedFolderId,\r\n      editingLinkId: uiStore.editingLinkId,\r\n      editingFolderId: uiStore.editingFolderId,\r\n      parentFolderId: uiStore.parentFolderId,\r\n      \r\n      // View States\r\n      currentView: uiStore.currentView,\r\n      searchFilters: uiStore.searchFilters,\r\n      expandedFolders: uiStore.expandedFolders,\r\n      \r\n      // Bulk Selection State\r\n      selectedLinkIds: uiStore.selectedLinkIds,\r\n      \r\n      // Folder to Delete State\r\n      folderToDelete: uiStore.folderToDelete,\r\n      // Folder to Share State\r\n      folderToShare: uiStore.folderToShare,\r\n      \r\n      // Actions\r\n      setAddLinkModalOpen: uiStore.setAddLinkModalOpen,\r\n      setCreateFolderModalOpen: uiStore.setCreateFolderModalOpen,\r\n      setSettingsModalOpen: uiStore.setSettingsModalOpen,\r\n      setProfileModalOpen: uiStore.setProfileModalOpen,\r\n      setBulkDeleteModalOpen: uiStore.setBulkDeleteModalOpen,\r\n      setBulkMoveModalOpen: uiStore.setBulkMoveModalOpen,\r\n      setFolderDeleteModalOpen: uiStore.setFolderDeleteModalOpen,\r\n      setEmptyTrashModalOpen: uiStore.setEmptyTrashModalOpen,\r\n      setRestoreAllModalOpen: uiStore.setRestoreAllModalOpen,\r\n      setShareFolderModalOpen: uiStore.setShareFolderModalOpen,\r\n      setSelectedFolder: uiStore.setSelectedFolder,\r\n      setEditingLink: uiStore.setEditingLink,\r\n      setEditingFolder: uiStore.setEditingFolder,\r\n      setParentFolder: uiStore.setParentFolder,\r\n      setCurrentView: uiStore.setCurrentView,\r\n      setSearchFilters: uiStore.setSearchFilters,\r\n      toggleFolderExpanded: uiStore.toggleFolderExpanded,\r\n      toggleLinkSelection: uiStore.toggleLinkSelection,\r\n      clearLinkSelection: uiStore.clearLinkSelection,\r\n      selectAllLinks: uiStore.selectAllLinks,\r\n      setFolderToDelete: uiStore.setFolderToDelete,\r\n      setFolderToShare: uiStore.setFolderToShare,\r\n      resetUIState: uiStore.resetUIState,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Alternative hook that provides direct access to individual stores\r\n * @returns {Object} Object containing all store hooks\r\n * @example\r\n * const stores = useStores();\r\n * stores.auth.signIn(email, password);\r\n * stores.links.addLink(linkData);\r\n */\r\nexport function useStores() {\r\n  return {\r\n    auth: useAuthStore,\r\n    links: useLinksStore,\r\n    folders: useFoldersStore,\r\n    settings: useSettingsStore,\r\n    ui: useUIStore,\r\n  };\r\n}\r\n\r\n// Re-export types for convenience (types are not exported from individual stores)\r\nexport type { User } from '@supabase/supabase-js';\r\nexport type { Link, Folder, AppSettings, SearchFilters } from '@/types';","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\store\\useAuthStore.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":15,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file store/useAuthStore.ts\r\n * @description Authentication state management\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { create } from 'zustand';\r\nimport { User } from '@supabase/supabase-js';\r\nimport { createClient } from '@/lib/supabase/client';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\nconst supabase = createClient();\r\n\r\ninterface AuthState {\r\n  // State\r\n  user: User | null;\r\n  isAuthenticated: boolean;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  \r\n  // Actions\r\n  signIn: (email: string, password: string) => Promise<void>;\r\n  signUp: (email: string, password: string) => Promise<void>;\r\n  signOut: () => Promise<void>;\r\n  refreshSession: () => Promise<void>;\r\n  clearError: () => void;\r\n}\r\n\r\nexport const useAuthStore = create<AuthState>((set, get) => ({\r\n  // Initial state\r\n  user: null,\r\n  isAuthenticated: false,\r\n  isLoading: false,\r\n  error: null,\r\n  \r\n  /**\r\n   * Signs in a user with email and password\r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When authentication fails\r\n   */\r\n  signIn: async (email: string, password: string) => {\r\n    set({ isLoading: true, error: null });\r\n    \r\n    try {\r\n      const { data, error } = await supabase.auth.signInWithPassword({\r\n        email,\r\n        password,\r\n      });\r\n      \r\n      if (error) {\r\n        throw error;\r\n      }\r\n      \r\n      if (!data.user) {\r\n        throw new Error('No user data returned from authentication');\r\n      }\r\n      \r\n      set({ \r\n        user: data.user, \r\n        isAuthenticated: true, \r\n        isLoading: false,\r\n        error: null\r\n      });\r\n      \r\n      logger.info('User signed in successfully', { userId: data.user.id });\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Authentication failed';\r\n      \r\n      logger.error('Sign in error:', { \r\n        error: errorMessage,\r\n        email,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      set({ \r\n        isLoading: false, \r\n        error: errorMessage,\r\n        isAuthenticated: false,\r\n        user: null\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Signs up a new user with email and password\r\n   * @param {string} email - User email\r\n   * @param {string} password - User password\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When registration fails\r\n   */\r\n  signUp: async (email: string, password: string) => {\r\n    set({ isLoading: true, error: null });\r\n    \r\n    try {\r\n      const { data, error } = await supabase.auth.signUp({\r\n        email,\r\n        password,\r\n      });\r\n      \r\n      if (error) {\r\n        throw error;\r\n      }\r\n      \r\n      if (!data.user) {\r\n        throw new Error('No user data returned from registration');\r\n      }\r\n      \r\n      set({ \r\n        user: data.user, \r\n        isAuthenticated: true, \r\n        isLoading: false,\r\n        error: null\r\n      });\r\n      \r\n      logger.info('User signed up successfully', { userId: data.user.id });\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Registration failed';\r\n      \r\n      logger.error('Sign up error:', { \r\n        error: errorMessage,\r\n        email,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      set({ \r\n        isLoading: false, \r\n        error: errorMessage,\r\n        isAuthenticated: false,\r\n        user: null\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Signs out the current user\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When sign out fails\r\n   */\r\n  signOut: async () => {\r\n    set({ isLoading: true });\r\n    \r\n    try {\r\n      const { error } = await supabase.auth.signOut();\r\n      \r\n      if (error) {\r\n        throw error;\r\n      }\r\n      \r\n      set({ \r\n        user: null, \r\n        isAuthenticated: false, \r\n        isLoading: false,\r\n        error: null\r\n      });\r\n      \r\n      logger.info('User signed out successfully');\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Sign out failed';\r\n      \r\n      logger.error('Sign out error:', { \r\n        error: errorMessage,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      set({ isLoading: false });\r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Refreshes the current user session\r\n   * @returns {Promise<void>}\r\n   */\r\n  refreshSession: async () => {\r\n    set({ isLoading: true });\r\n    \r\n    try {\r\n      const { data, error } = await supabase.auth.getUser();\r\n      \r\n      if (error) {\r\n        // If there's an error, user is not authenticated\r\n        set({ \r\n          user: null, \r\n          isAuthenticated: false, \r\n          isLoading: false,\r\n          error: null\r\n        });\r\n        return;\r\n      }\r\n      \r\n      if (data.user) {\r\n        set({ \r\n          user: data.user, \r\n          isAuthenticated: true, \r\n          isLoading: false,\r\n          error: null\r\n        });\r\n      } else {\r\n        set({ \r\n          user: null, \r\n          isAuthenticated: false, \r\n          isLoading: false,\r\n          error: null\r\n        });\r\n      }\r\n    } catch (error) {\r\n      logger.error('Session refresh error:', { \r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      set({ isLoading: false });\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Clears any authentication errors\r\n   */\r\n  clearError: () => {\r\n    set({ error: null });\r\n  },\r\n}));","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\store\\useFoldersStore.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":14,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file store/useFoldersStore.ts\r\n * @description Folder state management\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { create } from 'zustand';\r\nimport { Folder } from '@/types';\r\nimport { supabaseDatabaseService } from '@/lib/services/supabase-database.service';\r\nimport { sanitizeFolderData } from '@/lib/utils/sanitization';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface FoldersState {\r\n  // State\r\n  folders: Folder[];\r\n  isLoading: boolean;\r\n  editingFolderId: string | null;\r\n  parentFolderId: string | null; // For creating sub-folders\r\n  expandedFolders: Set<string>;\r\n\r\n  // Actions - State Management\r\n  setFolders: (folders: Folder[]) => void;\r\n  setLoading: (isLoading: boolean) => void;\r\n\r\n  // Actions - Single Folder Operations\r\n  addFolder: (folderData: Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;\r\n  updateFolder: (id: string, updates: Partial<Folder>) => Promise<void>;\r\n  deleteFolder: (id: string) => Promise<void>;\r\n  toggleFolderExpanded: (id: string) => void;\r\n  setParentFolder: (folderId: string | null) => void;\r\n\r\n  // Actions - UI State\r\n  setEditingFolder: (folderId: string | null) => void;\r\n}\r\n\r\nexport const useFoldersStore = create<FoldersState>((set, get) => ({\r\n  // Initial State\r\n  folders: [],\r\n  isLoading: false,\r\n  editingFolderId: null,\r\n  parentFolderId: null,\r\n  expandedFolders: new Set<string>(),\r\n\r\n  /**\r\n   * Sets the folders array directly\r\n   * @param {Folder[]} folders - Array of folders to set\r\n   */\r\n  setFolders: (folders) => set({ folders }),\r\n\r\n  /**\r\n   * Sets the loading state\r\n   * @param {boolean} isLoading - Loading state\r\n   */\r\n  setLoading: (isLoading) => set({ isLoading }),\r\n\r\n  /**\r\n   * Adds a new folder with sanitization and validation\r\n   * @param {Omit<Folder, 'id' | 'createdAt' | 'updatedAt'>} folderData - Folder data to create\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When folder creation fails\r\n   */\r\n  addFolder: async (folderData) => {\r\n    const tempId = `temp-${Date.now()}`; // Declare outside try block for catch block access\r\n\r\n    try {\r\n      // CRITICAL: Sanitize input data to prevent XSS\r\n      const sanitizedData = sanitizeFolderData(folderData);\r\n\r\n      const tempFolder: Folder = {\r\n        ...sanitizedData,\r\n        id: tempId,\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString(),\r\n      };\r\n\r\n      // Optimistic update\r\n      set((state) => ({ folders: [...state.folders, tempFolder] }));\r\n\r\n      // ENHANCED: Add timeout protection with better error message\r\n      const savePromise = supabaseDatabaseService.addFolder(sanitizedData);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Folder creation timeout - please check your connection and try again')), 5000)\r\n      );\r\n\r\n      const newFolder = await Promise.race([savePromise, timeoutPromise]);\r\n\r\n      // Replace temp folder with real folder from database\r\n      set((state) => ({\r\n        folders: state.folders.map((folder) => (folder.id === tempId ? newFolder : folder)),\r\n      }));\r\n\r\n      logger.debug('Folder added successfully:', { id: newFolder.id, name: newFolder.name });\r\n    } catch (error) {\r\n      // Revert optimistic update on error\r\n      set((state) => ({\r\n        folders: state.folders.filter((folder) => folder.id !== tempId && !folder.id.startsWith('temp-')),\r\n      }));\r\n\r\n      logger.error('Error adding folder:', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        folderData: { name: folderData.name },\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Updates an existing folder with sanitization and validation\r\n   * @param {string} id - Folder ID\r\n   * @param {Partial<Folder>} updates - Fields to update\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When folder update fails\r\n   */\r\n  updateFolder: async (id, updates) => {\r\n    try {\r\n      const originalFolder = get().folders.find((folder) => folder.id === id);\r\n      if (!originalFolder) {\r\n        throw new Error(`Folder with ID ${id} not found`);\r\n      }\r\n\r\n      // CRITICAL: Sanitize update data to prevent XSS\r\n      const sanitizedUpdates = sanitizeFolderData(updates);\r\n\r\n      // Optimistic update with validation\r\n      const updatedFolder = {\r\n        ...originalFolder,\r\n        ...sanitizedUpdates,\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n\r\n      set((state) => ({\r\n        folders: state.folders.map((folder) =>\r\n          folder.id === id ? updatedFolder : folder\r\n        ),\r\n      }));\r\n\r\n      // ENHANCED: Add timeout protection with better error message\r\n      const updatePromise = supabaseDatabaseService.updateFolder(id, sanitizedUpdates);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Update folder timeout - please check your connection and try again')), 10000)\r\n      );\r\n\r\n      await Promise.race([updatePromise, timeoutPromise]);\r\n\r\n      logger.debug('Folder updated successfully:', { id, updates });\r\n    } catch (error) {\r\n      // Revert optimistic update on error\r\n      const originalFolder = get().folders.find((folder) => folder.id === id);\r\n      if (originalFolder) {\r\n        set((state) => ({\r\n          folders: state.folders.map((folder) => (folder.id === id ? originalFolder : folder)),\r\n        }));\r\n      }\r\n\r\n      logger.error('Error updating folder:', {\r\n        folderId: id,\r\n        updates,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Deletes a folder and moves its links to root\r\n   * @param {string} id - Folder ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When folder deletion fails\r\n   */\r\n  deleteFolder: async (id) => {\r\n    // Store original state for rollback BEFORE optimistic update\r\n    const originalFolders = [...get().folders];\r\n\r\n    try {\r\n      const folderToDelete = get().folders.find((folder) => folder.id === id);\r\n      if (!folderToDelete) {\r\n        throw new Error(`Folder with ID ${id} not found`);\r\n      }\r\n\r\n      // Optimistic update - remove folder immediately\r\n      // Note: Links are handled separately by the database service (folderId set to null)\r\n      set((state) => ({\r\n        folders: state.folders.filter((folder) => folder.id !== id),\r\n      }));\r\n\r\n      // ENHANCED: Add timeout protection with better error message\r\n      const deletePromise = supabaseDatabaseService.deleteFolder(id);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Delete folder timeout - please check your connection and try again')), 10000)\r\n      );\r\n\r\n      await Promise.race([deletePromise, timeoutPromise]);\r\n\r\n      logger.debug('Folder deleted successfully:', { id, name: folderToDelete.name });\r\n    } catch (error) {\r\n      // Revert optimistic update on error - restore original state\r\n      const folderToDelete = get().folders.find((folder) => folder.id === id);\r\n      if (!folderToDelete) {\r\n        // Restore folder if it was deleted optimistically - use captured original state\r\n        set((state) => ({\r\n          folders: originalFolders,\r\n        }));\r\n      }\r\n\r\n      logger.error('Error deleting folder:', {\r\n        folderId: id,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Toggles the expanded state of a folder\r\n   * @param {string} id - Folder ID\r\n   */\r\n  toggleFolderExpanded: (id) => {\r\n    set((state) => {\r\n      const newExpanded = new Set(state.expandedFolders);\r\n      if (newExpanded.has(id)) {\r\n        newExpanded.delete(id);\r\n      } else {\r\n        newExpanded.add(id);\r\n      }\r\n      return { expandedFolders: newExpanded };\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Sets the parent folder ID for creating sub-folders\r\n   * @param {string | null} folderId - Parent folder ID (null for root)\r\n   */\r\n  setParentFolder: (folderId) => {\r\n    set({ parentFolderId: folderId });\r\n  },\r\n\r\n  /**\r\n   * Sets the currently editing folder ID\r\n   * @param {string | null} folderId - Folder ID to edit\r\n   */\r\n  setEditingFolder: (folderId) => {\r\n    set({ editingFolderId: folderId });\r\n  },\r\n}));","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\store\\useLinksStore.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":16,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file store/useLinksStore.ts\r\n * @description Link state management\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { create } from 'zustand';\r\nimport { Link } from '@/types';\r\nimport { linksDatabaseService } from '@/lib/services/links-database.service';\r\nimport { sanitizeLinkData } from '@/lib/utils/sanitization';\r\nimport { logger } from '@/lib/utils/logger';\r\nimport { detectMobileBrowser } from '@/lib/utils/platform';\r\nimport { createClient } from '@/lib/supabase/client';\r\n\r\ninterface LinksState {\r\n  // State\r\n  links: Link[];\r\n  isLoading: boolean;\r\n  editingLinkId: string | null;\r\n\r\n  // Actions - State Management\r\n  setLinks: (links: Link[]) => void;\r\n  setLoading: (isLoading: boolean) => void;\r\n\r\n  // Actions - Single Link Operations\r\n  addLink: (linkData: Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>) => Promise<void>;\r\n  updateLink: (id: string, updates: Partial<Link>) => Promise<void>;\r\n  deleteLink: (id: string) => Promise<void>;\r\n  restoreLink: (id: string) => Promise<void>;\r\n  permanentlyDeleteLink: (id: string) => Promise<void>;\r\n  toggleFavorite: (id: string) => Promise<void>;\r\n\r\n  // Actions - Bulk Link Operations\r\n  bulkUpdateLinks: (ids: string[], updates: Partial<Link>) => Promise<void>;\r\n  bulkDeleteLinks: (ids: string[]) => Promise<void>;\r\n  bulkRestoreLinks: (ids: string[]) => Promise<void>;\r\n  bulkMoveLinks: (ids: string[], folderId: string | null) => Promise<void>;\r\n  bulkToggleFavoriteLinks: (ids: string[], isFavorite: boolean) => Promise<void>;\r\n\r\n  // Actions - Trash Operations\r\n  emptyTrash: () => Promise<void>;\r\n  restoreAllFromTrash: () => Promise<void>;\r\n\r\n  // Actions - UI State\r\n  setEditingLink: (linkId: string | null) => void;\r\n}\r\n\r\nexport const useLinksStore = create<LinksState>((set, get) => ({\r\n  // Initial State\r\n  links: [],\r\n  isLoading: false,\r\n  editingLinkId: null,\r\n\r\n  /**\r\n   * Sets the links array directly\r\n   * @param {Link[]} links - Array of links to set\r\n   */\r\n  setLinks: (links) => set({ links }),\r\n\r\n  /**\r\n   * Sets the loading state\r\n   * @param {boolean} isLoading - Loading state\r\n   */\r\n  setLoading: (isLoading) => set({ isLoading }),\r\n\r\n  /**\r\n   * Adds a new link with enhanced session validation and reliability\r\n   * @param {Omit<Link, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>} linkData - Link data to create\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When link creation fails\r\n   */\r\n  addLink: async (linkData) => {\r\n    const browserInfo = detectMobileBrowser();\r\n\r\n    try {\r\n      // CRITICAL: Sanitize input data to prevent XSS\r\n      const sanitizedData = sanitizeLinkData(linkData);\r\n\r\n      // ENHANCED: Validate session before attempting to save\r\n      let user = null;\r\n      try {\r\n        const { data: { user: currentUser } } = await createClient().auth.getUser();\r\n        user = currentUser;\r\n\r\n        if (!user) {\r\n          throw new Error('User not authenticated. Please log in again.');\r\n        }\r\n      } catch (sessionError) {\r\n        logger.warn('Session validation failed before adding link:', sessionError);\r\n        // Wait a moment and retry session validation (helps with timing issues)\r\n        await new Promise(resolve => setTimeout(resolve, 500));\r\n        const { data: { user: retryUser } } = await createClient().auth.getUser();\r\n        user = retryUser;\r\n\r\n        if (!user) {\r\n          throw new Error('Session expired. Please refresh the page and try again.');\r\n        }\r\n      }\r\n\r\n      // Generate temporary ID for optimistic update\r\n      const tempId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n      const tempLink: Link = {\r\n        ...sanitizedData,\r\n        id: tempId,\r\n        deletedAt: null,\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString(),\r\n      };\r\n\r\n      // Optimistic update with conflict detection\r\n      set((state) => {\r\n        // Check for existing links with same URL to prevent duplicates\r\n        const existingLink = state.links.find(link =>\r\n          !link.id.startsWith('temp-') &&\r\n          link.url === linkData.url &&\r\n          link.deletedAt === null\r\n        );\r\n\r\n        if (existingLink) {\r\n          logger.warn('Duplicate link detected, skipping optimistic update');\r\n          return state;\r\n        }\r\n\r\n        return { links: [...state.links, tempLink] };\r\n      });\r\n\r\n      // ENHANCED: Add timeout protection with mobile-specific duration and retry logic\r\n      const timeoutDuration = browserInfo.isMobile ? 8000 : 5000; // Reduced timeout for better UX (5s desktop, 8s mobile)\r\n      const maxRetries = 1; // Reduce retries to 1 to fail faster\r\n      let lastError: Error | null = null;\r\n\r\n      for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n        try {\r\n          const savePromise = linksDatabaseService.addLink(sanitizedData);\r\n          const timeoutPromise = new Promise<never>((_, reject) =>\r\n            setTimeout(() => reject(new Error('Add link timeout - please check your connection')), timeoutDuration)\r\n          );\r\n\r\n          const newLink = await Promise.race([savePromise, timeoutPromise]);\r\n\r\n          // Replace temp link with real link, handling potential conflicts\r\n          set((state) => {\r\n            const filteredLinks = state.links.filter((link) => link.id !== tempId);\r\n            // Check if real link already exists (from real-time subscription)\r\n            const existingRealLink = filteredLinks.find(link => link.id === newLink.id);\r\n            if (existingRealLink) {\r\n              logger.debug('Link already exists from real-time update, skipping duplicate');\r\n              return { links: filteredLinks };\r\n            }\r\n            return { links: [...filteredLinks, newLink] };\r\n          });\r\n\r\n          logger.debug('Link added successfully:', {\r\n            id: newLink.id,\r\n            url: newLink.url,\r\n            attempt: attempt + 1\r\n          });\r\n          return; // Success, exit the function\r\n\r\n        } catch (error) {\r\n          lastError = error instanceof Error ? error : new Error('Unknown error');\r\n\r\n          // Don't retry on certain errors that won't improve\r\n          if (error instanceof Error && (\r\n            error.message?.includes('authentication') ||\r\n            error.message?.includes('not authenticated') ||\r\n            error.message?.includes('timeout'))) {\r\n            break;\r\n          }\r\n\r\n          // Wait before retry with exponential backoff\r\n          if (attempt < maxRetries) {\r\n            const delay = 500 * Math.pow(2, attempt); // 500ms, 1s\r\n            logger.warn(`Link save attempt ${attempt + 1} failed, retrying in ${delay}ms:`, error);\r\n            await new Promise(resolve => setTimeout(resolve, delay));\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we get here, all retries failed\r\n      throw lastError || new Error('Failed to save link after multiple attempts');\r\n\r\n    } catch (error) {\r\n      // Enhanced error handling with rollback\r\n      set((state) => ({\r\n        links: state.links.filter((link) => !link.id.startsWith('temp-')),\r\n      }));\r\n\r\n      logger.error('Error adding link:', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        linkData: { url: linkData.url, title: linkData.title },\r\n        isMobile: browserInfo.isMobile,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Updates an existing link with sanitization and validation\r\n   * @param {string} id - Link ID\r\n   * @param {Partial<Link>} updates - Fields to update\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When link update fails\r\n   */\r\n  updateLink: async (id, updates) => {\r\n    try {\r\n      const originalLink = get().links.find((link) => link.id === id);\r\n      if (!originalLink) {\r\n        throw new Error(`Link with ID ${id} not found`);\r\n      }\r\n\r\n      // CRITICAL: Sanitize update data to prevent XSS\r\n      const sanitizedUpdates = sanitizeLinkData(updates);\r\n\r\n      // Optimistic update with validation\r\n      const updatedLink = {\r\n        ...originalLink,\r\n        ...sanitizedUpdates,\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          link.id === id ? updatedLink : link\r\n        ),\r\n      }));\r\n\r\n      // ENHANCED: Add timeout protection to prevent hanging updates\r\n      const updatePromise = linksDatabaseService.updateLink(id, sanitizedUpdates);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Update link timeout - please check your connection and try again')), 10000)\r\n      );\r\n\r\n      await Promise.race([updatePromise, timeoutPromise]);\r\n    } catch (error) {\r\n      // Revert optimistic update on error\r\n      const originalLink = get().links.find((link) => link.id === id);\r\n      if (originalLink) {\r\n        set((state) => ({\r\n          links: state.links.map((link) => (link.id === id ? originalLink : link)),\r\n        }));\r\n      }\r\n\r\n      logger.error('Error updating link:', {\r\n        linkId: id,\r\n        updates,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Soft deletes a link (moves to trash)\r\n   * @param {string} id - Link ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When link deletion fails\r\n   */\r\n  deleteLink: async (id) => {\r\n    const deletedAt = new Date().toISOString();\r\n    const originalLink = get().links.find((link) => link.id === id);\r\n\r\n    if (!originalLink) {\r\n      throw new Error(`Link with ID ${id} not found`);\r\n    }\r\n\r\n    try {\r\n      // Optimistic update with validation\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          link.id === id ? { ...link, deletedAt, updatedAt: deletedAt } : link\r\n        ),\r\n      }));\r\n\r\n      // ENHANCED: Add timeout protection to prevent hanging deletes\r\n      const deletePromise = linksDatabaseService.deleteLink(id);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Delete link timeout - please check your connection and try again')), 10000)\r\n      );\r\n\r\n      await Promise.race([deletePromise, timeoutPromise]);\r\n    } catch (error) {\r\n      // Revert optimistic update on error\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          link.id === id ? { ...link, deletedAt: null, updatedAt: originalLink.updatedAt } : link\r\n        ),\r\n      }));\r\n\r\n      logger.error('Error deleting link:', {\r\n        linkId: id,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Restores a link from trash\r\n   * @param {string} id - Link ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When link restoration fails\r\n   */\r\n  restoreLink: async (id) => {\r\n    try {\r\n      // Optimistic update\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          link.id === id\r\n            ? { ...link, deletedAt: null, updatedAt: new Date().toISOString() }\r\n            : link\r\n        ),\r\n      }));\r\n\r\n      // Update in database\r\n      await linksDatabaseService.restoreLink(id);\r\n    } catch (error) {\r\n      // Revert on error\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          link.id === id\r\n            ? { ...link, deletedAt: new Date().toISOString() }\r\n            : link\r\n        ),\r\n      }));\r\n      logger.error('Error restoring link:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Permanently deletes a link\r\n   * @param {string} id - Link ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When permanent deletion fails\r\n   */\r\n  permanentlyDeleteLink: async (id) => {\r\n    // Store for rollback BEFORE optimistic update\r\n    const linkToDelete = get().links.find((link) => link.id === id);\r\n    if (!linkToDelete) {\r\n      throw new Error('Link not found');\r\n    }\r\n\r\n    try {\r\n      // Optimistic delete\r\n      set((state) => ({ links: state.links.filter((link) => link.id !== id) }));\r\n\r\n      // Delete from database\r\n      await linksDatabaseService.permanentlyDeleteLink(id);\r\n    } catch (error) {\r\n      // Revert on error - restore the deleted link\r\n      set((state) => ({ links: [...state.links, linkToDelete] }));\r\n      logger.error('Error permanently deleting link:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Toggles favorite status of a link\r\n   * @param {string} id - Link ID\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When favorite toggle fails\r\n   */\r\n  toggleFavorite: async (id) => {\r\n    try {\r\n      const link = get().links.find((l) => l.id === id);\r\n      if (!link) return;\r\n\r\n      const newFavoriteState = !link.isFavorite;\r\n\r\n      // Optimistic update\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          link.id === id\r\n            ? { ...link, isFavorite: newFavoriteState, updatedAt: new Date().toISOString() }\r\n            : link\r\n        ),\r\n      }));\r\n\r\n      // Update in database\r\n      await linksDatabaseService.updateLink(id, { isFavorite: newFavoriteState });\r\n    } catch (error) {\r\n      // Revert on error\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          link.id === id ? { ...link, isFavorite: !link.isFavorite } : link\r\n        ),\r\n      }));\r\n      logger.error('Error toggling favorite:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Bulk updates multiple links with the same updates\r\n   * @param {string[]} ids - Array of link IDs to update\r\n   * @param {Partial<Link>} updates - Updates to apply to all links\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk update fails\r\n   */\r\n  bulkUpdateLinks: async (ids, updates) => {\r\n    if (ids.length === 0) return;\r\n\r\n    const browserInfo = detectMobileBrowser();\r\n\r\n    try {\r\n      // Store original links for rollback with enhanced conflict detection\r\n      const originalLinks = get().links.filter(link => ids.includes(link.id));\r\n\r\n      // Optimistic update with conflict detection\r\n      set((state) => {\r\n        const updatedLinks = state.links.map((link) => {\r\n          if (ids.includes(link.id)) {\r\n            // Check for version conflicts (if updatedAt is newer)\r\n            const original = originalLinks.find(orig => orig.id === link.id);\r\n            if (original && link.updatedAt > original.updatedAt) {\r\n              logger.warn('Version conflict detected, skipping optimistic update for link:', link.id);\r\n              return link; // Keep the newer version\r\n            }\r\n            return { ...link, ...updates, updatedAt: new Date().toISOString() };\r\n          }\r\n          return link;\r\n        });\r\n        return { links: updatedLinks };\r\n      });\r\n\r\n      // Update in database with timeout protection\r\n      const timeoutDuration = browserInfo.isMobile ? 20000 : 15000;\r\n      const updatePromise = linksDatabaseService.bulkUpdateLinks(ids, updates);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Bulk update timeout - please check your connection')), timeoutDuration)\r\n      );\r\n\r\n      await Promise.race([updatePromise, timeoutPromise]);\r\n    } catch (error) {\r\n      // Enhanced rollback with conflict resolution\r\n      const originalLinks = get().links.filter(link => ids.includes(link.id));\r\n      set((state) => ({\r\n        links: state.links.map((link) => {\r\n          const original = originalLinks.find(orig => orig.id === link.id);\r\n          return original || link;\r\n        }),\r\n      }));\r\n\r\n      logger.error('Error bulk updating links:', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        linkIds: ids,\r\n        updates,\r\n        isMobile: browserInfo.isMobile,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Bulk soft deletes multiple links (moves to trash)\r\n   * @param {string[]} ids - Array of link IDs to delete\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk deletion fails\r\n   */\r\n  bulkDeleteLinks: async (ids) => {\r\n    if (ids.length === 0) return;\r\n\r\n    const deletedAt = new Date().toISOString();\r\n\r\n    try {\r\n      // Optimistic update\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          ids.includes(link.id)\r\n            ? { ...link, deletedAt, updatedAt: deletedAt }\r\n            : link\r\n        ),\r\n      }));\r\n\r\n      // Update in database\r\n      await linksDatabaseService.bulkDeleteLinks(ids);\r\n    } catch (error) {\r\n      // Revert on error\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          ids.includes(link.id) ? { ...link, deletedAt: null } : link\r\n        ),\r\n      }));\r\n      logger.error('Error bulk deleting links:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Bulk restores multiple links from trash\r\n   * @param {string[]} ids - Array of link IDs to restore\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk restoration fails\r\n   */\r\n  bulkRestoreLinks: async (ids) => {\r\n    if (ids.length === 0) return;\r\n\r\n    try {\r\n      // Optimistic update\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          ids.includes(link.id)\r\n            ? { ...link, deletedAt: null, updatedAt: new Date().toISOString() }\r\n            : link\r\n        ),\r\n      }));\r\n\r\n      // Update in database\r\n      await linksDatabaseService.bulkRestoreLinks(ids);\r\n    } catch (error) {\r\n      // Revert on error\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          ids.includes(link.id)\r\n            ? { ...link, deletedAt: new Date().toISOString() }\r\n            : link\r\n        ),\r\n      }));\r\n      logger.error('Error bulk restoring links:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Bulk moves multiple links to a specific folder\r\n   * @param {string[]} ids - Array of link IDs to move\r\n   * @param {string | null} folderId - Target folder ID (null for root)\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk move fails\r\n   */\r\n  bulkMoveLinks: async (ids, folderId) => {\r\n    if (ids.length === 0) return;\r\n\r\n    // Store original folder IDs for rollback BEFORE optimistic update\r\n    const originalLinks = get().links\r\n      .filter(link => ids.includes(link.id))\r\n      .map(link => ({ id: link.id, folderId: link.folderId }));\r\n\r\n    try {\r\n      // Optimistic update\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          ids.includes(link.id)\r\n            ? { ...link, folderId, updatedAt: new Date().toISOString() }\r\n            : link\r\n        ),\r\n      }));\r\n\r\n      // Update in database with timeout protection\r\n      await Promise.race([\r\n        linksDatabaseService.bulkMoveLinks(ids, folderId),\r\n        new Promise<never>((_, reject) =>\r\n          setTimeout(() => reject(new Error('Move links timeout - please check your connection')), 10000)\r\n        )\r\n      ]);\r\n    } catch (error) {\r\n      // Revert on error - restore original folder IDs\r\n      set((state) => ({\r\n        links: state.links.map((link) => {\r\n          const original = originalLinks.find(orig => orig.id === link.id);\r\n          return original ? { ...link, folderId: original.folderId } : link;\r\n        }),\r\n      }));\r\n      logger.error('Error bulk moving links:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Bulk toggles favorite status for multiple links\r\n   * @param {string[]} ids - Array of link IDs to toggle\r\n   * @param {boolean} isFavorite - New favorite status\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When bulk favorite toggle fails\r\n   */\r\n  bulkToggleFavoriteLinks: async (ids, isFavorite) => {\r\n    if (ids.length === 0) return;\r\n\r\n    try {\r\n      // Store original favorite states for rollback\r\n      const originalLinks = get().links.filter(link => ids.includes(link.id));\r\n\r\n      // Optimistic update\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          ids.includes(link.id)\r\n            ? { ...link, isFavorite, updatedAt: new Date().toISOString() }\r\n            : link\r\n        ),\r\n      }));\r\n\r\n      // Update in database\r\n      await linksDatabaseService.bulkToggleFavoriteLinks(ids, isFavorite);\r\n    } catch (error) {\r\n      // Revert on error\r\n      const originalLinks = get().links.filter(link => ids.includes(link.id));\r\n      set((state) => ({\r\n        links: state.links.map((link) => {\r\n          const original = originalLinks.find(orig => orig.id === link.id);\r\n          return original || link;\r\n        }),\r\n      }));\r\n      logger.error('Error bulk toggling favorites:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Permanently deletes all trashed links\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When emptying trash fails\r\n   */\r\n  emptyTrash: async () => {\r\n    // Store deleted links for rollback BEFORE optimistic update\r\n    const deletedLinks = get().links.filter((link) => link.deletedAt !== null);\r\n\r\n    try {\r\n      // Optimistic delete\r\n      set((state) => ({\r\n        links: state.links.filter((link) => link.deletedAt === null),\r\n      }));\r\n\r\n      // Delete from database\r\n      await linksDatabaseService.emptyTrash();\r\n    } catch (error) {\r\n      // Revert on error - restore deleted links\r\n      set((state) => ({ links: [...state.links, ...deletedLinks] }));\r\n      logger.error('Error emptying trash:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Restores all trashed links\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When restoring all from trash fails\r\n   */\r\n  restoreAllFromTrash: async () => {\r\n    // Store original state BEFORE optimistic update\r\n    const originalLinks = get().links.map(link => ({ ...link }));\r\n\r\n    try {\r\n      // Optimistic update\r\n      set((state) => ({\r\n        links: state.links.map((link) =>\r\n          link.deletedAt !== null\r\n            ? { ...link, deletedAt: null, updatedAt: new Date().toISOString() }\r\n            : link\r\n        ),\r\n      }));\r\n\r\n      // Update in database\r\n      await linksDatabaseService.restoreAllFromTrash();\r\n    } catch (error) {\r\n      // Revert on error - restore original state\r\n      set({ links: originalLinks });\r\n      logger.error('Error restoring all from trash:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets the currently editing link ID\r\n   * @param {string | null} linkId - Link ID to edit\r\n   */\r\n  setEditingLink: (linkId) => {\r\n    set({ editingLinkId: linkId });\r\n  },\r\n}));","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\store\\useSettingsStore.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":14,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file store/useSettingsStore.ts\r\n * @description User settings state management\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { create } from 'zustand';\r\nimport { AppSettings } from '@/types';\r\nimport { supabaseDatabaseService } from '@/lib/services/supabase-database.service';\r\nimport { sanitizeSettingsData } from '@/lib/utils/sanitization';\r\nimport { logger } from '@/lib/utils/logger';\r\n\r\ninterface SettingsState {\r\n  // State\r\n  settings: AppSettings;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n\r\n  // Actions\r\n  setSettings: (settings: AppSettings) => void;\r\n  loadSettings: () => Promise<void>;\r\n  updateSettings: (updates: Partial<AppSettings>) => Promise<void>;\r\n  clearError: () => void;\r\n}\r\n\r\nexport const useSettingsStore = create<SettingsState>((set, get) => ({\r\n  // Initial State\r\n  settings: {\r\n    theme: 'light', // Changed from 'system' to 'light' for better default UX\r\n  },\r\n  isLoading: false,\r\n  error: null,\r\n\r\n  /**\r\n   * Sets the settings directly (for initialization)\r\n   * @param {AppSettings} settings - Settings to set\r\n   */\r\n  setSettings: (settings) => set({ settings }),\r\n\r\n  /**\r\n   * Loads user settings from database\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When settings load fails\r\n   */\r\n  loadSettings: async () => {\r\n    set({ isLoading: true, error: null });\r\n\r\n    try {\r\n      const settings = await supabaseDatabaseService.getSettings();\r\n\r\n      if (settings) {\r\n        set({\r\n          settings,\r\n          isLoading: false,\r\n          error: null\r\n        });\r\n      } else {\r\n        // Use default settings if none exist\r\n        set({\r\n          isLoading: false,\r\n          error: null\r\n        });\r\n      }\r\n\r\n      logger.debug('Settings loaded successfully');\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to load settings';\r\n\r\n      logger.error('Error loading settings:', {\r\n        error: errorMessage,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      set({\r\n        isLoading: false,\r\n        error: errorMessage\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Updates user settings with sanitization and validation\r\n   * @param {Partial<AppSettings>} updates - Settings to update\r\n   * @returns {Promise<void>}\r\n   * @throws {Error} When settings update fails\r\n   */\r\n  updateSettings: async (updates) => {\r\n    const currentSettings = get().settings;\r\n\r\n    set({ isLoading: true, error: null });\r\n\r\n    try {\r\n      // CRITICAL: Sanitize input data to prevent XSS\r\n      const sanitizedUpdates = sanitizeSettingsData(updates);\r\n\r\n      // Validate input settings\r\n      if (!sanitizedUpdates || typeof sanitizedUpdates !== 'object') {\r\n        throw new Error('Invalid settings object provided');\r\n      }\r\n\r\n      // Optimistically update UI with validation\r\n      const updatedSettings = { ...currentSettings, ...sanitizedUpdates };\r\n      set({ settings: updatedSettings });\r\n\r\n      // ENHANCED: Add timeout protection to prevent hanging updates\r\n      const updatePromise = supabaseDatabaseService.updateSettings(sanitizedUpdates);\r\n      const timeoutPromise = new Promise<never>((_, reject) =>\r\n        setTimeout(() => reject(new Error('Update settings timeout - please check your connection and try again')), 8000)\r\n      );\r\n\r\n      await Promise.race([updatePromise, timeoutPromise]);\r\n\r\n      logger.debug('Settings updated successfully', { updates: sanitizedUpdates });\r\n    } catch (error) {\r\n      // Revert optimistic update on error\r\n      set({ settings: currentSettings });\r\n\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to update settings';\r\n\r\n      logger.error('Error updating settings:', {\r\n        newSettings: updates,\r\n        error: errorMessage,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      set({\r\n        isLoading: false,\r\n        error: errorMessage\r\n      });\r\n\r\n      // Re-throw for component-level error handling\r\n      throw error;\r\n    } finally {\r\n      set({ isLoading: false });\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Clears any settings errors\r\n   */\r\n  clearError: () => {\r\n    set({ error: null });\r\n  },\r\n}));","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\store\\useStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\store\\useUIStore.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":11,"column":1,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file store/useUIStore.ts\r\n * @description UI state management\r\n * @created 2025-11-12\r\n * @modified 2025-11-12\r\n */\r\n\r\nimport { create } from 'zustand';\r\nimport { SearchFilters } from '@/types';\r\n\r\ninterface UIState {\r\n  // App State\r\n  isHydrated: boolean;\r\n  isLoadingData: boolean; // NEW: Track overall data loading state\r\n  \r\n  // Modal States\r\n  isAddLinkModalOpen: boolean;\r\n  isCreateFolderModalOpen: boolean;\r\n  isSettingsModalOpen: boolean;\r\n  isProfileModalOpen: boolean;\r\n  isBulkDeleteModalOpen: boolean;\r\n  isBulkMoveModalOpen: boolean;\r\n  isFolderDeleteModalOpen: boolean;\r\n  isEmptyTrashModalOpen: boolean;\r\n  isRestoreAllModalOpen: boolean;\r\n  isShareFolderModalOpen: boolean;\r\n  \r\n  // Selection States\r\n  selectedFolderId: string | null;\r\n  editingLinkId: string | null;\r\n  editingFolderId: string | null;\r\n  parentFolderId: string | null; // For creating sub-folders\r\n  \r\n  // View States\r\n  currentView: 'all' | 'favorites' | 'trash';\r\n  searchFilters: SearchFilters;\r\n  expandedFolders: Set<string>;\r\n  \r\n  // Bulk Selection State\r\n  selectedLinkIds: Set<string>;\r\n  \r\n  // Folder to Delete State\r\n  folderToDelete: { id: string; name: string; linkCount: number } | null;\r\n  // Folder to Share State\r\n  folderToShare: { id: string; name: string; linkCount: number } | null;\r\n  \r\n  // Actions - App State\r\n  setHydrated: (isHydrated: boolean) => void;\r\n  setIsLoadingData: (isLoading: boolean) => void; // NEW: Track data loading\r\n  \r\n  // Actions - Modal Controls\r\n  setAddLinkModalOpen: (isOpen: boolean) => void;\r\n  setCreateFolderModalOpen: (isOpen: boolean) => void;\r\n  setSettingsModalOpen: (isOpen: boolean) => void;\r\n  setProfileModalOpen: (isOpen: boolean) => void;\r\n  setBulkDeleteModalOpen: (isOpen: boolean) => void;\r\n  setBulkMoveModalOpen: (isOpen: boolean) => void;\r\n  setFolderDeleteModalOpen: (isOpen: boolean) => void;\r\n  setEmptyTrashModalOpen: (isOpen: boolean) => void;\r\n  setRestoreAllModalOpen: (isOpen: boolean) => void;\r\n  setShareFolderModalOpen: (isOpen: boolean) => void;\r\n  \r\n  // Actions - Selection Controls\r\n  setSelectedFolder: (folderId: string | null) => void;\r\n  setEditingLink: (linkId: string | null) => void;\r\n  setEditingFolder: (folderId: string | null) => void;\r\n  setParentFolder: (folderId: string | null) => void;\r\n  \r\n  // Actions - View Controls\r\n  setCurrentView: (view: 'all' | 'favorites' | 'trash') => void;\r\n  setSearchFilters: (filters: Partial<SearchFilters>) => void;\r\n  toggleFolderExpanded: (id: string) => void;\r\n  \r\n  // Actions - Bulk Selection\r\n  toggleLinkSelection: (linkId: string) => void;\r\n  clearLinkSelection: () => void;\r\n  selectAllLinks: (linkIds: string[]) => void;\r\n  \r\n  // Actions - Folder Delete\r\n  setFolderToDelete: (folder: { id: string; name: string; linkCount: number } | null) => void;\r\n  // Actions - Folder Share\r\n  setFolderToShare: (folder: { id: string; name: string; linkCount: number } | null) => void;\r\n  \r\n  // Actions - UI State Reset\r\n  resetUIState: () => void;\r\n}\r\n\r\nexport const useUIStore = create<UIState>((set, get) => ({\r\n  // Initial App State\r\n  isHydrated: false,\r\n  isLoadingData: false, // NEW: Initial state\r\n  \r\n  // Initial Modal States\r\n  isAddLinkModalOpen: false,\r\n  isCreateFolderModalOpen: false,\r\n  isSettingsModalOpen: false,\r\n  isProfileModalOpen: false,\r\n  isBulkDeleteModalOpen: false,\r\n  isBulkMoveModalOpen: false,\r\n  isFolderDeleteModalOpen: false,\r\n  isEmptyTrashModalOpen: false,\r\n  isRestoreAllModalOpen: false,\r\n  isShareFolderModalOpen: false,\r\n  \r\n  // Initial Selection States\r\n  selectedFolderId: null,\r\n  editingLinkId: null,\r\n  editingFolderId: null,\r\n  parentFolderId: null,\r\n  \r\n  // Initial View States\r\n  currentView: 'all',\r\n  searchFilters: {\r\n    query: '',\r\n  },\r\n  expandedFolders: new Set<string>(),\r\n  \r\n  // Initial Bulk Selection State\r\n  selectedLinkIds: new Set<string>(),\r\n  \r\n  // Initial Folder to Delete State\r\n  folderToDelete: null,\r\n  // Initial Folder to Share State\r\n  folderToShare: null,\r\n  \r\n  /**\r\n   * Sets the hydration state of the app\r\n   * @param {boolean} isHydrated - Whether the app has been hydrated\r\n   */\r\n  setHydrated: (isHydrated) => set({ isHydrated }),\r\n  \r\n  /**\r\n   * Sets the overall data loading state\r\n   * @param {boolean} isLoading - Whether data is loading\r\n   */\r\n  setIsLoadingData: (isLoading) => set({ isLoadingData: isLoading }),\r\n  \r\n  /**\r\n   * Sets the add link modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setAddLinkModalOpen: (isOpen) => {\r\n    set({ isAddLinkModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the create folder modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setCreateFolderModalOpen: (isOpen) => {\r\n    set({ isCreateFolderModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the settings modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setSettingsModalOpen: (isOpen) => {\r\n    set({ isSettingsModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the profile modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setProfileModalOpen: (isOpen) => {\r\n    set({ isProfileModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the bulk delete modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setBulkDeleteModalOpen: (isOpen) => {\r\n    set({ isBulkDeleteModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the bulk move modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setBulkMoveModalOpen: (isOpen) => {\r\n    set({ isBulkMoveModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the folder delete modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setFolderDeleteModalOpen: (isOpen) => {\r\n    set({ isFolderDeleteModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the empty trash modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setEmptyTrashModalOpen: (isOpen) => {\r\n    set({ isEmptyTrashModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the restore all modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setRestoreAllModalOpen: (isOpen) => {\r\n    set({ isRestoreAllModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the share folder modal open state\r\n   * @param {boolean} isOpen - Whether modal should be open\r\n   */\r\n  setShareFolderModalOpen: (isOpen) => {\r\n    set({ isShareFolderModalOpen: isOpen });\r\n  },\r\n  \r\n  /**\r\n   * Sets the selected folder ID\r\n   * @param {string | null} folderId - Folder ID to select\r\n   */\r\n  setSelectedFolder: (folderId) => {\r\n    set({ selectedFolderId: folderId });\r\n  },\r\n  \r\n  /**\r\n   * Sets the currently editing link ID\r\n   * @param {string | null} linkId - Link ID to edit\r\n   */\r\n  setEditingLink: (linkId) => {\r\n    set({ editingLinkId: linkId });\r\n  },\r\n  \r\n  /**\r\n   * Sets the currently editing folder ID\r\n   * @param {string | null} folderId - Folder ID to edit\r\n   */\r\n  setEditingFolder: (folderId) => {\r\n    set({ editingFolderId: folderId });\r\n  },\r\n  \r\n  /**\r\n   * Sets the parent folder ID for creating sub-folders\r\n   * @param {string | null} folderId - Parent folder ID (null for root)\r\n   */\r\n  setParentFolder: (folderId) => {\r\n    set({ parentFolderId: folderId });\r\n  },\r\n  \r\n  /**\r\n   * Sets the current view (all, favorites, or trash)\r\n   * @param {'all' | 'favorites' | 'trash'} view - View to set\r\n   */\r\n  setCurrentView: (view) => {\r\n    set({ currentView: view });\r\n  },\r\n  \r\n  /**\r\n   * Updates search filters\r\n   * @param {Partial<SearchFilters>} filters - Filters to update\r\n   */\r\n  setSearchFilters: (filters) => {\r\n    set((state) => ({\r\n      searchFilters: { ...state.searchFilters, ...filters },\r\n    }));\r\n  },\r\n  \r\n  /**\r\n   * Toggles the expanded state of a folder\r\n   * @param {string} id - Folder ID\r\n   */\r\n  toggleFolderExpanded: (id) => {\r\n    set((state) => {\r\n      const newExpanded = new Set(state.expandedFolders);\r\n      if (newExpanded.has(id)) {\r\n        newExpanded.delete(id);\r\n      } else {\r\n        newExpanded.add(id);\r\n      }\r\n      return { expandedFolders: newExpanded };\r\n    });\r\n  },\r\n  \r\n  /**\r\n   * Toggles the selection state of a link\r\n   * @param {string} linkId - Link ID to toggle\r\n   */\r\n  toggleLinkSelection: (linkId) => {\r\n    set((state) => {\r\n      const newSelected = new Set(state.selectedLinkIds);\r\n      if (newSelected.has(linkId)) {\r\n        newSelected.delete(linkId);\r\n      } else {\r\n        newSelected.add(linkId);\r\n      }\r\n      return { selectedLinkIds: newSelected };\r\n    });\r\n  },\r\n  \r\n  /**\r\n   * Clears all link selections\r\n   */\r\n  clearLinkSelection: () => {\r\n    set({ selectedLinkIds: new Set<string>() });\r\n  },\r\n  \r\n  /**\r\n   * Selects all links (would need to be called with actual link IDs)\r\n   * @param {string[]} linkIds - Array of all link IDs to select\r\n   */\r\n  selectAllLinks: (linkIds) => {\r\n    set({ selectedLinkIds: new Set(linkIds) });\r\n  },\r\n  \r\n  /**\r\n   * Sets the folder to delete with its metadata\r\n   * @param {{ id: string; name: string; linkCount: number } | null} folder - Folder to delete\r\n   */\r\n  setFolderToDelete: (folder) => {\r\n    set({ folderToDelete: folder });\r\n  },\r\n  \r\n  /**\r\n   * Sets the folder to share with its metadata\r\n   * @param {{ id: string; name: string; linkCount: number } | null} folder - Folder to share\r\n   */\r\n  setFolderToShare: (folder) => {\r\n    set({ folderToShare: folder });\r\n  },\r\n  \r\n  /**\r\n   * Resets all UI state to initial values\r\n   */\r\n  resetUIState: () => {\r\n    set({\r\n      // Reset Modal States\r\n      isAddLinkModalOpen: false,\r\n      isCreateFolderModalOpen: false,\r\n      isSettingsModalOpen: false,\r\n      isProfileModalOpen: false,\r\n      isBulkDeleteModalOpen: false,\r\n      isBulkMoveModalOpen: false,\r\n      isFolderDeleteModalOpen: false,\r\n      isEmptyTrashModalOpen: false,\r\n      isRestoreAllModalOpen: false,\r\n      isShareFolderModalOpen: false,\r\n      \r\n      // Reset Selection States\r\n      selectedFolderId: null,\r\n      editingLinkId: null,\r\n      editingFolderId: null,\r\n      parentFolderId: null,\r\n      \r\n      // Reset View States\r\n      currentView: 'all',\r\n      searchFilters: { query: '' },\r\n      expandedFolders: new Set<string>(),\r\n      \r\n      // Reset Bulk Selection State\r\n      selectedLinkIds: new Set<string>(),\r\n      \r\n      // Reset Folder to Delete State\r\n      folderToDelete: null,\r\n      // Reset Folder to Share State\r\n      folderToShare: null,\r\n      \r\n      // Reset Data Loading State\r\n      isLoadingData: false, // NEW: Reset data loading state\r\n    });\r\n  },\r\n}));","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\types\\index.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":7,"column":8,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file types/index.ts\r\n * @description Central type definitions for LinkVault application\r\n * @created 2025-10-18\r\n */\r\n\r\nexport interface Link {\r\n  id: string;\r\n  url: string;\r\n  title: string;\r\n  description: string;\r\n  thumbnail: string;\r\n  faviconUrl?: string; // Favicon URL for the link\r\n  platform: Platform;\r\n  folderId: string | null;\r\n  isFavorite: boolean;\r\n  tags?: string[]; // Tags for categorization\r\n  deletedAt: string | null;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  // Supabase integration fields\r\n  userId?: string; // Owner of the link\r\n  syncedAt?: string; // Last sync timestamp\r\n}\r\n\r\nexport interface Folder {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  color: string;\r\n  icon: string;\r\n  parentId: string | null;\r\n  isPlatformFolder: boolean;\r\n  platform?: Platform;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  // Supabase integration fields\r\n  userId?: string; // Owner of the folder\r\n  syncedAt?: string; // Last sync timestamp\r\n  // Sharing functionality\r\n  shareable?: boolean; // Whether the folder is shared\r\n  shareId?: string; // Unique share identifier\r\n  shareCreatedAt?: string; // When sharing was enabled\r\n}\r\n\r\nexport interface AppSettings {\r\n  theme: 'light' | 'dark' | 'system';\r\n}\r\n\r\nexport type Platform =\r\n  | 'youtube'\r\n  | 'twitter'\r\n  | 'instagram'\r\n  | 'linkedin'\r\n  | 'tiktok'\r\n  | 'github'\r\n  | 'medium'\r\n  | 'reddit'\r\n  | 'facebook'\r\n  | 'other';\r\n\r\nexport interface MetadataResponse {\r\n  title: string;\r\n  image: string;\r\n  description: string;\r\n}\r\n\r\nexport interface SearchFilters {\r\n  query: string;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\utils\\date.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":12,"column":40,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file utils/date.ts\r\n * @description Date formatting and manipulation utilities\r\n * @created 2025-10-18\r\n */\r\n\r\n/**\r\n * Formats a date to relative time (e.g., \"2 hours ago\")\r\n * @param date - The date to format\r\n * @returns Formatted relative time string\r\n */\r\nexport function formatRelativeTime(date: string | Date): string {\r\n  const now = new Date();\r\n  const targetDate = typeof date === 'string' ? new Date(date) : date;\r\n  const diffInSeconds = Math.floor((now.getTime() - targetDate.getTime()) / 1000);\r\n\r\n  if (diffInSeconds < 60) {\r\n    return 'just now';\r\n  }\r\n\r\n  const diffInMinutes = Math.floor(diffInSeconds / 60);\r\n  if (diffInMinutes < 60) {\r\n    return `${diffInMinutes} ${diffInMinutes === 1 ? 'minute' : 'minutes'} ago`;\r\n  }\r\n\r\n  const diffInHours = Math.floor(diffInMinutes / 60);\r\n  if (diffInHours < 24) {\r\n    return `${diffInHours} ${diffInHours === 1 ? 'hour' : 'hours'} ago`;\r\n  }\r\n\r\n  const diffInDays = Math.floor(diffInHours / 24);\r\n  if (diffInDays < 7) {\r\n    return `${diffInDays} ${diffInDays === 1 ? 'day' : 'days'} ago`;\r\n  }\r\n\r\n  const diffInWeeks = Math.floor(diffInDays / 7);\r\n  if (diffInWeeks < 4) {\r\n    return `${diffInWeeks} ${diffInWeeks === 1 ? 'week' : 'weeks'} ago`;\r\n  }\r\n\r\n  const diffInMonths = Math.floor(diffInDays / 30);\r\n  if (diffInMonths < 12) {\r\n    return `${diffInMonths} ${diffInMonths === 1 ? 'month' : 'months'} ago`;\r\n  }\r\n\r\n  const diffInYears = Math.floor(diffInDays / 365);\r\n  return `${diffInYears} ${diffInYears === 1 ? 'year' : 'years'} ago`;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\utils\\folder-utils.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":30,"column":11,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file utils/folder-utils.ts\r\n * @description Utility functions for folder operations and hierarchy management\r\n * @created 2025-10-18\r\n */\r\n\r\nimport { Folder } from '@/types';\r\n\r\n/**\r\n * Maximum number of sub-folders allowed per parent folder\r\n * Only parent folders (root level) can have sub-folders\r\n * Sub-folders cannot have their own sub-folders (1 level nesting only)\r\n */\r\nexport const MAX_SUB_FOLDERS_PER_FOLDER = 10;\r\n\r\n/**\r\n * Gets all descendant folder IDs recursively for a given parent folder\r\n * Used to filter links that belong to a folder and all its sub-folders\r\n * \r\n * @param folderId - Parent folder ID to get descendants for\r\n * @param folders - Array of all folders\r\n * @returns Array of folder IDs including the parent and all descendants\r\n * \r\n * @example\r\n * // Folder structure: Work > Projects > ClientA\r\n * getAllDescendantFolderIds('work-id', folders)\r\n * // Returns: ['work-id', 'projects-id', 'clienta-id']\r\n */\r\nexport function getAllDescendantFolderIds(\r\n  folderId: string,\r\n  folders: Folder[]\r\n): string[] {\r\n  const descendants: string[] = [folderId];\r\n  const visited = new Set<string>([folderId]); // Prevent infinite loops\r\n  \r\n  /**\r\n   * Recursively gets all children of a parent folder.\r\n   * Prevents circular references by tracking visited nodes.\r\n   * @param parentId - Parent folder ID to get children for\r\n   */\r\n  const getChildren = (parentId: string) => {\r\n    const children = folders.filter(f => f.parentId === parentId);\r\n    \r\n    children.forEach(child => {\r\n      // Prevent circular references\r\n      if (visited.has(child.id)) {\r\n        console.error(`Circular reference detected: ${child.id} already visited`);\r\n        return;\r\n      }\r\n      \r\n      visited.add(child.id);\r\n      descendants.push(child.id);\r\n      getChildren(child.id); // Recursive call\r\n    });\r\n  };\r\n  \r\n  getChildren(folderId);\r\n  return descendants;\r\n}\r\n\r\n/**\r\n * Calculates the nesting depth of a folder\r\n * Depth is the number of parent folders above the given folder\r\n * \r\n * @param folderId - Folder ID to calculate depth for\r\n * @param folders - Array of all folders\r\n * @returns Depth level (0 for root folders, 1+ for nested folders)\r\n * \r\n * @example\r\n * // Root folder\r\n * getFolderDepth('root-id', folders) // Returns: 0\r\n * \r\n * // Nested folder: Root > Level1 > Level2\r\n * getFolderDepth('level2-id', folders) // Returns: 2\r\n */\r\nexport function getFolderDepth(\r\n  folderId: string,\r\n  folders: Folder[]\r\n): number {\r\n  let depth = 0;\r\n  let currentId: string | null = folderId;\r\n  const visited = new Set<string>(); // Prevent infinite loops\r\n  \r\n  while (currentId) {\r\n    const folder = folders.find(f => f.id === currentId);\r\n    \r\n    if (!folder) {\r\n      console.warn(`Folder not found: ${currentId}`);\r\n      break;\r\n    }\r\n    \r\n    if (!folder.parentId) {\r\n      // Reached root folder\r\n      break;\r\n    }\r\n    \r\n    // Check for circular reference\r\n    if (visited.has(folder.parentId)) {\r\n      console.error(`Circular reference detected at folder: ${folder.id}`);\r\n      break;\r\n    }\r\n    \r\n    visited.add(currentId);\r\n    currentId = folder.parentId;\r\n    depth++;\r\n  }\r\n  \r\n  return depth;\r\n}\r\n\r\n/**\r\n * Checks if a folder is allowed to have sub-folders\r\n * Only root folders (folders with no parent) can have sub-folders\r\n * This enforces a single level of nesting: Parent ΓåÆ Sub-folder (no deeper)\r\n * \r\n * @param folderId - Folder ID to check\r\n * @param folders - Array of all folders\r\n * @returns True if folder can have sub-folders, false if it's already a sub-folder\r\n * \r\n * @example\r\n * // Root folder (parentId: null)\r\n * canHaveSubFolders('root-id', folders) // Returns: true\r\n * \r\n * // Sub-folder (parentId: 'root-id')\r\n * canHaveSubFolders('sub-id', folders) // Returns: false\r\n */\r\nexport function canHaveSubFolders(\r\n  folderId: string,\r\n  folders: Folder[]\r\n): boolean {\r\n  const folder = folders.find(f => f.id === folderId);\r\n  // Only folders with no parent (root level) can have sub-folders\r\n  return folder ? folder.parentId === null : false;\r\n}\r\n\r\n/**\r\n * Checks if a folder can accept more sub-folders based on the limit\r\n * Maximum of 10 sub-folders per parent folder is enforced\r\n * Also checks if the parent folder is allowed to have sub-folders\r\n * \r\n * @param parentId - Parent folder ID to check\r\n * @param folders - Array of all folders\r\n * @returns True if more sub-folders can be added, false otherwise\r\n * \r\n * @example\r\n * canAddSubFolder('parent-id', folders) // Returns: true if < 10 sub-folders exist and parent is root\r\n */\r\nexport function canAddSubFolder(\r\n  parentId: string,\r\n  folders: Folder[]\r\n): boolean {\r\n  // First check if this folder is allowed to have sub-folders\r\n  if (!canHaveSubFolders(parentId, folders)) {\r\n    return false;\r\n  }\r\n  \r\n  const existingSubFolders = folders.filter(f => f.parentId === parentId);\r\n  return existingSubFolders.length < MAX_SUB_FOLDERS_PER_FOLDER;\r\n}\r\n\r\n/**\r\n * Gets the count of immediate sub-folders for a given folder\r\n * \r\n * @param parentId - Parent folder ID\r\n * @param folders - Array of all folders\r\n * @returns Number of direct sub-folders\r\n */\r\nexport function getSubFolderCount(\r\n  parentId: string,\r\n  folders: Folder[]\r\n): number {\r\n  return folders.filter(f => f.parentId === parentId).length;\r\n}\r\n\r\n/**\r\n * Validates if a folder can be set as a parent of another folder\r\n * Prevents circular references where a folder becomes its own ancestor\r\n * \r\n * @param folderId - Folder being moved/created\r\n * @param newParentId - Proposed parent folder ID\r\n * @param folders - Array of all folders\r\n * @returns True if valid parent assignment, false if circular reference would occur\r\n * \r\n * @example\r\n * // Prevent Work > Projects, then Projects > Work\r\n * validateFolderParent('work-id', 'projects-id', folders)\r\n * // Returns: false (circular reference)\r\n */\r\nexport function validateFolderParent(\r\n  folderId: string,\r\n  newParentId: string,\r\n  folders: Folder[]\r\n): boolean {\r\n  // Can't be its own parent\r\n  if (folderId === newParentId) {\r\n    return false;\r\n  }\r\n  \r\n  // Check if newParent is a descendant of folder\r\n  // This would create a circular reference\r\n  const descendants = getAllDescendantFolderIds(folderId, folders);\r\n  return !descendants.includes(newParentId);\r\n}\r\n\r\n/**\r\n * Gets all root folders (folders with no parent)\r\n * \r\n * @param folders - Array of all folders\r\n * @returns Array of root folders\r\n */\r\nexport function getRootFolders(folders: Folder[]): Folder[] {\r\n  return folders.filter(f => f.parentId === null);\r\n}\r\n\r\n/**\r\n * Gets immediate children of a folder\r\n * \r\n * @param parentId - Parent folder ID (null for root level)\r\n * @param folders - Array of all folders\r\n * @returns Array of child folders\r\n */\r\nexport function getChildFolders(\r\n  parentId: string | null,\r\n  folders: Folder[]\r\n): Folder[] {\r\n  return folders.filter(f => f.parentId === parentId);\r\n}\r\n\r\n/**\r\n * Builds a folder breadcrumb path from root to the given folder\r\n * \r\n * @param folderId - Target folder ID\r\n * @param folders - Array of all folders\r\n * @returns Array of folder objects from root to target\r\n * \r\n * @example\r\n * // Folder path: Work > Projects > Client A\r\n * getFolderPath('clienta-id', folders)\r\n * // Returns: [Work, Projects, Client A] folder objects\r\n */\r\nexport function getFolderPath(\r\n  folderId: string,\r\n  folders: Folder[]\r\n): Folder[] {\r\n  const path: Folder[] = [];\r\n  let currentId: string | null = folderId;\r\n  const visited = new Set<string>();\r\n  \r\n  while (currentId) {\r\n    const folder = folders.find(f => f.id === currentId);\r\n    \r\n    if (!folder || visited.has(currentId)) {\r\n      break;\r\n    }\r\n    \r\n    visited.add(currentId);\r\n    path.unshift(folder); // Add to beginning of array\r\n    currentId = folder.parentId;\r\n  }\r\n  \r\n  return path;\r\n}\r\n\r\n/**\r\n * Checks if a folder has any sub-folders\r\n * \r\n * @param folderId - Folder ID to check\r\n * @param folders - Array of all folders\r\n * @returns True if folder has children, false otherwise\r\n */\r\nexport function hasSubFolders(\r\n  folderId: string,\r\n  folders: Folder[]\r\n): boolean {\r\n  return folders.some(f => f.parentId === folderId);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\utils\\image.utils.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":22,"column":41,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file utils/image.utils.ts\r\n * @description Image optimization and validation utilities\r\n * @created 2025-11-21\r\n */\r\n\r\nimport { IMAGE_CONSTANTS, FETCH_PRIORITY } from '@/constants/image.constants';\r\n\r\n/**\r\n * Check if an image URL is from an allowed domain for Next.js Image optimization\r\n * \r\n * @example\r\n * isAllowedImageDomain('https://img.youtube.com/vi/abc/maxresdefault.jpg')\r\n * // Returns: true\r\n * \r\n * isAllowedImageDomain('https://unknown-domain.com/image.jpg')\r\n * // Returns: false\r\n * \r\n * @param url - Image URL to validate\r\n * @returns Whether the domain is in the allowed list\r\n */\r\nexport function isAllowedImageDomain(url: string): boolean {\r\n    try {\r\n        const urlObj = new URL(url);\r\n        return IMAGE_CONSTANTS.ALLOWED_DOMAINS.some(\r\n            domain => urlObj.hostname === domain || urlObj.hostname.endsWith(`.${domain}`)\r\n        );\r\n    } catch {\r\n        // If URL parsing fails, assume it's not allowed\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Get image quality based on priority\r\n * Priority images use higher quality for better LCP (Largest Contentful Paint)\r\n * Non-priority images use lower quality to reduce bandwidth usage\r\n * \r\n * @example\r\n * getImageQuality(true)  // Returns: 75\r\n * getImageQuality(false) // Returns: 60\r\n * \r\n * @param priority - Whether this is a priority/above-the-fold image\r\n * @returns Image quality value (0-100)\r\n */\r\nexport function getImageQuality(priority: boolean): number {\r\n    return priority ? IMAGE_CONSTANTS.QUALITY_HIGH : IMAGE_CONSTANTS.QUALITY_STANDARD;\r\n}\r\n\r\n/**\r\n * Get fetchPriority attribute value for browser-level optimization\r\n * Priority images get \"high\" to load them faster\r\n * Non-priority images get \"low\" to defer loading\r\n * \r\n * @example\r\n * getFetchPriority(true)  // Returns: 'high'\r\n * getFetchPriority(false) // Returns: 'low'\r\n * \r\n * @param priority - Whether this is a priority/above-the-fold image\r\n * @returns fetchPriority attribute value\r\n */\r\nexport function getFetchPriority(priority: boolean): typeof FETCH_PRIORITY.HIGH | typeof FETCH_PRIORITY.LOW {\r\n    return priority ? FETCH_PRIORITY.HIGH : FETCH_PRIORITY.LOW;\r\n}\r\n\r\n/**\r\n * Get blur data URL for priority images\r\n * Only priority images should use blur placeholders to reduce overhead\r\n * \r\n * @example\r\n * getBlurDataURL(true)  // Returns: 'data:image/svg+xml;base64...'\r\n * getBlurDataURL(false) // Returns: undefined\r\n * \r\n * @param priority - Whether this is a priority/above-the-fold image\r\n * @returns Blur data URL or undefined\r\n */\r\nexport function getBlurDataURL(priority: boolean): string | undefined {\r\n    return priority ? IMAGE_CONSTANTS.BLUR_DATA_URL : undefined;\r\n}\r\n\r\n/**\r\n * Get placeholder type for Next.js Image component\r\n * \r\n * @example\r\n * getPlaceholder(true)  // Returns: 'blur'\r\n * getPlaceholder(false) // Returns: 'empty'\r\n * \r\n * @param priority - Whether this is a priority/above-the-fold image\r\n * @returns Placeholder type for Image component\r\n */\r\nexport function getPlaceholder(priority: boolean): 'blur' | 'empty' {\r\n    return priority ? 'blur' : 'empty';\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Samee\\Desktop\\MyLib\\linkvault-merged\\linkvault\\utils\\platform.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":15,"column":35,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @file utils/platform.ts\r\n * @description Platform detection and URL utilities\r\n * @created 2025-10-18\r\n */\r\n\r\nimport { Platform } from '@/types';\r\nimport { PLATFORM_CONFIG } from '@/constants';\r\n\r\n/**\r\n * Detects the platform from a given URL\r\n * @param url - The URL to analyze\r\n * @returns The detected platform type\r\n */\r\nexport function detectPlatform(url: string): Platform {\r\n  try {\r\n    const urlObj = new URL(url);\r\n    const hostname = urlObj.hostname.toLowerCase().replace('www.', '');\r\n\r\n    for (const [platform, config] of Object.entries(PLATFORM_CONFIG)) {\r\n      if (config.domains.some((domain) => hostname.includes(domain))) {\r\n        return platform as Platform;\r\n      }\r\n    }\r\n\r\n    return 'other';\r\n  } catch (error) {\r\n    return 'other';\r\n  }\r\n}\r\n\r\n/**\r\n * Validates if a string is a valid URL\r\n * @param url - The string to validate\r\n * @returns True if valid URL, false otherwise\r\n */\r\nexport function isValidUrl(url: string): boolean {\r\n  try {\r\n    new URL(url);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets platform configuration\r\n * @param platform - The platform type\r\n * @returns Platform configuration object\r\n */\r\nexport function getPlatformConfig(platform: Platform) {\r\n  return PLATFORM_CONFIG[platform] || PLATFORM_CONFIG['other'];\r\n}\r\n\r\n/**\r\n * Extracts domain from URL\r\n * @param url - The URL to extract domain from\r\n * @returns The domain name or empty string\r\n */\r\nexport function extractDomain(url: string): string {\r\n  try {\r\n    const urlObj = new URL(url);\r\n    return urlObj.hostname.replace('www.', '');\r\n  } catch {\r\n    return '';\r\n  }\r\n}\r\n","usedDeprecatedRules":[]}]
